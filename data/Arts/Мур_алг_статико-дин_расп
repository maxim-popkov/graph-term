Программные системы и инструменты. Тематический сборник № 8, М.: Изд-во факультета ВМиК МГУ, 2007. – С.148-156.

Балаханов В.А., Костенко В.А.

Способы сведения задачи построения статико-динамического однопроцессорного расписания для систем реального времени к задаче нахождения на графе маршрута.

Введение
Алгоритмы оптимизации, имитирующие кооперативное поведение муравьев в колонии, впервые были предложены в 1992 году [1] для решения задачи коммивояжера. Впоследствии муравьиные алгоритмы были успешно использованы для решения таких комбинаторных задач, как квадратичная задача о назначениях [2], задача упаковки в контейнеры [3], задачи построения расписаний [4,5,6]. 
Идея муравьиных алгоритмов основана на моделировании поведения муравьев при нахождении кратчайшего пути от муравейника к источнику пищи. Муравьи при перемещении оставляют особое вещество феромон, который используется в дальнейшем другими муравьями при выборе маршрута. Чем выше концентрация феромона на том или ином маршруте, тем выше вероятность того, что муравьи будут выбирать для движения именно этот маршрут.
Общую схему работы муравьиных алгоритмов можно представить в следующем виде:
1. Задание начального количества феромона на ребрах графа.
2. Определение количества и начального положения муравьев.
3. Поиск муравьями решений в соответствии с заданным алгоритмом построения маршрута.
4. Обновление количества феромона на ребрах в зависимости от качества полученных решений.
5. Если условие останова не выполнено, то переход к п.2.
Муравьи строят маршруты, последовательно переходя от вершины к вершине, руководствуясь при этом определенным алгоритмом для определения списка вершин, доступных на данном этапе (например, при решении задачи коммивояжера используется табу-список недоступных вершин, в который добавляются пройденные муравьем вершины). Выбор очередной вершины зависит от количества феромонов и значения локальной эвристической функции на ребрах, ведущих из текущей вершины в доступные. Эти значения определяют вероятность перехода в ту или иную вершину, после чего очередная вершина определяется по правилу рулетки.
В конце каждой итерации для каждого найденного маршрута вычисляется значение целевой функции. Оно используется для вычисления количества феромона, добавляемого на ребра, входящие в данный маршрут.
Основными задачами, которые необходимо решить для того, чтобы использовать муравьиный алгоритм для решения конкретной задачи оптимизации, являются:
1. Сведение задачи оптимизации к задаче нахождения на графе маршрута, обладающего определенными свойствами.
2. Задание локальной эвристической функции на ребрах графа.
3. Определение алгоритма построения маршрута муравьем (например, определение правила формирования табу-списка вершин).
В данной работе рассматриваются два способа сведения задачи построения статико-динамического однопроцессорного расписания для систем реального времени к задаче нахождения на графе маршрута.
1. Задача построения статико-динамического однопроцессорного расписания для систем реального времени
Статико-динамическое расписание представляет собой набор окон, каждое из которых характеризуется временем открытия, временем закрытия и списком работ, выполняющихся внутри окна. При этом порядок выполнения работ внутри окна определяется динамически и заранее неизвестен. Длина окна должна быть не меньше, чем суммарное время выполнения работ внутри него. Наряду с заданным списком прикладных задач в вычислительной системе могут выполняться системные задачи, список которых заранее неизвестен. На выполнение системных задач в каждом окне должен быть отведен определенный резерв времени.
Использование таких расписаний при работе систем реального времени позволяет уменьшить время реакции на прерывания и переключение режимов работы. Однако системы реального времени накладывают дополнительные ограничения на расписание. Кроме времени выполнения, каждая работа характеризуется также директивным интервалом, в пределах которого возможно ее выполнение. При этом временной интервал окна должен лежать внутри каждого из директивных интервалов работ, выполняющихся в данном окне, чтобы гарантировать, что директивные интервалы работ не будут нарушены.
Примером систем реального времени, использующих статико-динамические расписания, являются системы, работающие по стандарту ARINC-653 [7]. Одним из основных понятий стандарта является понятие раздела: в системе имеется определенный набор разделов, и каждая работа характеризуется номером раздела. Работы из одного раздела могут выполняться непосредственно одна за другой, без задержек; для перехода из одного раздела в другой необходимо переключение контекста, которое требует определенного времени. Все работы внутри окна должны принадлежать одному разделу, таким образом, работы внутри окна могут выполняться непосредственно друг за другом, без временных затрат на переключение контекста, которое может производиться только между закрытием одного окна и открытием следующего. Таким образом, для каждой работы задано время выполнения, номер раздела и директивный временной интервал выполнения.
В данной работе будут рассматриваться системы, работающие в соответствии со стандартом ARINC-653. Приведем формальную постановку задачи построения расписания для таких систем:
Пусть задано множество работ: 
SW={ai=<si,fi,ti,pi>|i[1..n]}, где 
[si,fi) – директивный временной интервал;
ti – время выполнения работы;
pi – номер раздела работы.
В дальнейшем будем предполагать, что для i[1..n]:sifi и tifi–si.
Кроме того, заданы два параметра:  и , определяющие, соответственно, временные затраты на переключение контекста между окнами и резерв свободного времени внутри каждого окна.
Требуется построить расписание, представляющее собой набор окон:
SP={wi=<Si,Fi,SWi>|i[1..m]}, где
Si – время открытия окна;
Fi  – время закрытия окна;
SWi={aij}SW – множество работ, выполняемых внутри окна.
Будем предполагать, что окна упорядочены в порядке возрастания времени открытия Si.
При этом должны выполняться следующие ограничения:
1. (i,j)[1..m],ij:SWiSWj= – множества работ, размещенных внутри окон, не пересекаются;
2. i[1..n],j[1..m],aiSWj:siSj<Fjfi – временной интервал окна лежит внутри директивных интервалов работ, выполняющихся в окне;
3. (i,j)[1..n],k[1..m],ai,ajSWk:pi=pj – разделы работ, размещенных внутри одного окна, совпадают;
4. (i,j)[1..m],i<j:SjFi+ – окна не пересекаются и между любыми двумя соседними окнами есть промежуток не короче времени, необходимого на переключение контекста;
5.  – суммарное время выполнения всех работ из одного окна с учетом резерва времени не больше, чем длина окна.
Критерием оптимальности расписания является отношение количества размещенных работ к общему количеству заданных работ.
2. Первый способ сведения задачи построения статико-динамического расписания к задаче нахождения на графе маршрута
Построим полносвязный граф G=<N,A>, где:
N={ni|i[1..n]}{O} – множество вершин;
A={(ni,nj)|i,j[1..n],ij}{(O,ni)|i[1..n]}> – множество ребер. 
Каждой вершине графа соответствует одна из размещаемых работ. Кроме того, добавляется еще одна вершина О, соответствующая началу расписания. 
Муравьиный алгоритм строит маршруты, в которых все вершины включены ровно один раз. Каждому такому маршруту соответствует последовательность работ, такая что, в нее включены все работы из исходно заданного набора и каждая работа включена в данную последовательность один раз. Опишем алгоритм для построения расписания по такой последовательности работ. Пусть дана последовательность работ SL={aik|aikSW;i,k[1..n]}. Первый индекс означает номер работы, второй - номер места работы в последовательности. Построим расписание SP по следующему алгоритму:
1. Инициализация расписания: Time=0 – текущая длина расписания; k=1 – номер места размещаемой работы в SL; SW0= – список работ в добавляемом окне;
2. Установка начальных параметров окна: S=max(Time,sik), F=fik – границы добавляемого окна; T=2 – минимальная необходимая длина окна с учетом добавленных работ; R=rik – раздел для работ в окне;
3. Обновление значений параметров окна с учетом новой добавляемой работы: S’=max(S,sik), F’=min(F,fik),  T’=T+tik;
4. Добавление работы в текущее окно: если rik=R , T’F’–S’ (условия корректности не нарушаются), то:    S=S’, F=F’, T=T’, SW0=SW0{aik}, k=k+1, если kn (список SL еще не пройден), переход к п.3;
5. Проверка возможности добавления работы в новое окно: если fik–F–<tik , то k=k+1, если kn переход к п.3 – данная работа не может быть размещена ни в текущее окно, ни в новое окно (дальше в списке еще могут быть работы, которые можно разместить в текущее окно);
6. Закрытие окна: F=S+T – устанавливаем время закрытия окна минимально возможным;
7. Добавление данного окна в расписание: SP=SP{<S,F,SW0>};
8. Пересчет длины расписания: Time=F+, k=k+1; 
9. Если k  n (список еще не пройден), переход к п.2.
Расписание, построенное при помощи данного алгоритма, будет удовлетворять всем условиям корректности:
1. Условие корректности 1 выполняется, т.к. каждая вершина встречается в построенном маршруте ровно один раз, и соответствующая ей работа размещается лишь в одно окно;
2. Условие 2 выполняется, т.к. S’=max(S,sik)sik; F’=min(F,fik)fik  (п.3);
3. Выполнение условий 3 и 5 обеспечивается проверками в п.4 алгоритма – если ограничения нарушаются, работа не размещается в данное окно;
4. Условие 4 выполняется, т.к. Si+1Time (п.2), где Time=Fi+п.8
Таким образом, при помощи описанного алгоритма по заданной последовательности работ однозначно строится корректное расписание. Фактически, данный алгоритм устанавливает соответствие между пространством расписаний и пространством последовательностей работ, которое, в свою очередь, является пространством поиска для муравьиного алгоритма. 
Недостатком данного подхода является то, что множество корректных расписаний содержит больше элементов, чем множество последовательностей работ, т.е. существуют расписания, для которых не существует соответствующих им цепочек работ. Причина заключается в том, что последовательность работ не задает однозначно распределение работ по окнам. Более того, можно привести пример задач, для которых оптимальное расписание не будет принадлежать к пространству поиска муравьиного алгоритма. Пример исходных данных такой задачи: SW={a1=<0,11,4,1>,a2=<4,11,2,1>,a3=<4,11,2,1>}, ==1 (рис.1). Прямоугольниками показаны директивные интервалы, заштрихованными областями – время выполнения работ. Раздел у всех работ одинаковый.



Рисунок 1. Исходные данные.

На рис.2 показаны все возможные расписания, которые могут быть построены приведенным алгоритмом по различным маршрутам в графе. Все эти расписания не являются оптимальными.


Рисунок 2. Построенные расписания.

При этом расписание, в котором все работы размещены, существует (рис.3).


Рисунок 3. Оптимальное расписание.

Можно выдвинуть гипотезу, что не существует детерминированного полиномиального алгоритма A построения расписания по маршруту в графе G такого, что для (SW,,):SL:A(SL)=SP0, где SP0 – оптимальное расписание. Т.е. не существует детерминированного полиномиального алгоритма, который для любой частной задачи мог бы построить оптимальное расписание по одному из возможных маршрутов. По крайне мере, пока такой алгоритм найти не удалось, однако нет и доказательства, что такого алгоритма не существует.
3. Второй способ сведения задачи построения статико-динамического расписания к задаче нахождения на графе маршрута
Чтобы устранить недостаток первого подхода, предлагается использовать измененное представление задачи в виде поиска маршрута на графе, в котором каждой работе будет соответствовать не одна, а две вершины. Появление в маршруте первой из этих вершин будет означать размещение работы без закрытия текущего окна. Другая вершина будет соответствовать размещению работы с закрытием окна. Соответственно, в маршруте может присутствовать одна и только одна вершина из каждой такой пары.
Построим граф G’=<N’,A’>, где
N’={ni+,ni–|i[1..n]}{O} – множество вершин; вершина ni+ соответствует размещению работы без закрытия текущего окна, ni– – размещению работы с закрытием окна. Вершина О является началом всех маршрутов.
A’={(ni+,nj–),(ni+,nj+),(ni–,nj–)|i,j[1..n],ij} {(O,ni+),(O,ni–)|i[1..n]} – множество ребер. Вершины, соответствующие одной работе, ребрами не связаны.
Алгоритм построения расписания по заданной последовательности работ полностью аналогичен предыдущему, за исключением того, что в п.4 при размещении работы, соответствующей вершине nj– текущее окно закрывается принудительно (происходит переход к п.6). Расписание, построенное при помощи такого алгоритма, также будет удовлетворять условиям корректности.
Заметим, что расписания, которые строятся приведенными алгоритмами (как базовым, так и модифицированным), помимо условий корректности, обладают следующими свойствами: 
 - длина временного интервала окна является минимально допустимой.
(1)
 - время открытия окна является минимальным, без нарушения ограничений 2 и 4.
(2)
Покажем, что модифицированный алгоритм всегда может построить оптимальное расписание по некоторому пути в G’.
Теорема. Для любого корректного расписания SP можно найти такую последовательность вершин SL, что по данной последовательности модифицированный алгоритм восстановления расписания построит такое корректное расписание SP*, что i[1..k]:SWi*=SWi , количество окон в SP* не меньше количества окон в SP.
Доказательство: построим искомую последовательность SL={nip|nipN’,i[1..n],p{+,–}} следующим образом: SL=SL1SL2…SLm, где SLi – последовательность из вершин, соответствующих работам из i-го окна такая, что все вершины, за исключением последней соответствуют размещению работы без закрытия окна. Т.е., фактически, данная последовательность состоит из размещенных работ, упорядоченных по времени открытия окна, в которое они размещены. Вершины, соответствующие работам, не размещенным в SP, добавляются в конец последовательности SL в произвольном порядке (добавляется одна произвольная вершина из двух). При этом в последовательности SL присутствует только одна вершина, соответствующая каждой работе.
Докажем совпадение списков работ в окнах расписания SP* и расписания SP по индукции.
1. Базис индукции: Т.к. все вершины, соответствующие работам из первого окна, стоят в последовательности вершин друг за другом, не прерываются вершиной с закрытием окна, то они будут размещаться в одно и то же окно. Т.к. исходное расписание является корректным, это возможно без нарушения условий корректности 1-5. Следовательно, списки работ в первом окне в SP и SP* будут совпадать (поскольку список вершин, соответствующих работам из первого окна, заканчивается вершиной с закрытием окна, в данное окно не попадут «лишние» работы). Время открытия и закрытия первого окна могут различаться в SP* и SP, но при этом из свойств (1) и (2) следует, что S*1S1, F*1F1.
2. Шаг индукции: F*i-1Fi-1, и, следовательно (из свойства (2)), S*iSi, F*iFi; далее повторяя предыдущие рассуждения, получаем, что корректность i-го окна в SP гарантирует корректность соответствующего окна в SP* и совпадение списка работ, размещенных в них.
Неразмещенные в SP работы могут оказаться добавлены только в новые окна, т.к. последовательность вершин, соответствующих размещенным в SP работам, заканчивается вершиной с закрытием окна.
Теорема доказана.
Из утверждения теоремы также следует, что значение целевой функции для расписания SP* не меньше, чем для SP. Таким образом, доказано, что для любого корректного расписания SP существует последовательность вершин графа G’ такая, что модифицированный алгоритм способен построить корректное расписание, по крайней мере, не хуже данного с точки зрения целевой функции.
Следствие. Если SP0 корректное оптимальное расписание для множества работ SW, то существует такая последовательность вершин SL, что модифицированный алгоритм построит по ней корректное оптимальное расписание. Построенное расписание будет совпадать с расписанием SP0 по количеству размещенных в нем работ, количеству окон, по множеству работ выполняемых внутри каждого окна, но может отличаться по времени открытия и закрытия окон.
Заключение
Способ сведения задачи построения статико-динамических расписаний к задаче нахождения маршрута на графе, в котором каждой работе соответствуют две вершины, увеличивает пространство поиска муравьиного алгоритма. Однако, в отличие от способа, в котором каждой работе соответствует одна вершина графа, гарантирует принадлежность оптимального расписания к пространству поиска муравьиного алгоритма.
Список литературы
1. Dorigo M. Optimization, Learning and Natural Algorithms. // PhD Thesis. Dipartimento di Elettronica, Politechnico Di Milano, Milano. 1992.
2. Stuzle T., Dorigo M. ACO Algorithms for the Quadratic Assignment Problem. // New Ideas in Optimization, McGraw-Hills, 1999. P. 33-50.
3. Levine J., Ducatelle F. Ant Colony Optimization and Local Search for Bin Packing and Cutting Stock Problems. // Journal of the Operational Research Society, 2003.
4. Ritchie G. Static Multi-processor Scheduling with Ant Colony Optimization and Local Search. // Master’s Thesis. University of Edinburgh, Edinburgh. 2003.
5. Blum C., Sampels M. Ant Colony Optimization for FOP Shop Scheduling: A case study on different pheromone representation // In Proceedings of the 2002 Congress on Evolutionary Computations, Honolulu. 2002.
6. Гафаров Е.Р. Гибридный алгоритм решения задачи минимизации суммарного запаздывания для одного прибора // Москва, ВЦ РАН. 2006.
7. Arinc Specification 653. Airlines Electronic Engineering Committee. [PDF] (http://www.arinc.com).