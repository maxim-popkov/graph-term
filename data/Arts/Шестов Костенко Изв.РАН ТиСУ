Костенко В.А., Шестов П.Е. Жадный алгоритм совместного планирования вычислений и обменов в системах реального времени // Известия РАН. Теория и системы управления. - 2012. - № 5 - С.35-49.

УДК 004.031.43

ЖАДНЫЙ АЛГОРИТМ СОВМЕСТНОГО ПЛАНИРОВАНИЯ ВЫЧИСЛЕНИЙ И ОБМЕНОВ В СИСТЕМАХ РЕАЛЬНОГО ВРЕМЕНИ
© 2012 г., В. А. Костенко, П. Е. Шестов
Москва, МГУ
Поступила в редакцию 20.12.11 г.
Приведена математическая постановка задачи построения согласованных расписаний выполнения прикладных задач и передачи сообщений для исходно заданных наборов прикладных задач и сообщений. Данная задача возникает при проектировании информационно-управляющих систем реального времени. Проведен анализ возможных подходов к построению алгоритмов для решения сформулированной задачи, описан разработанный жадный алгоритм и приведены результаты его экспериментального исследования.

Введение. Одним из важнейших требований к функционированию информационно–управляющих систем реального времени (ИУС РВ) является соблюдение директивных сроков выполнения прикладных программ. При нарушении директивных сроков, ИУС РВ теряет свою работоспособность. При разработке и отладке прикладного программного обеспечения для каждой версии программного обеспечения ИУС РВ необходимо строить расписание выполнения прикладных программ и расписание обмена данными для проверки возможности выполнения ограничений реального времени. При построении расписаний необходимо учитывать технологические ограничения ИУС РВ, обусловленные особенностями используемых аппаратных и системных программных средств. Приведенная в работе задача совместного планирования вычислений и обменов возникает при модификации ИУС РВ (например, при добавлении новых подсистем), а также при разработке новых ИУС РВ на базе существующих.
В данной статье задача совместного планирования вычислений и обменов рассматривается для ИУС РВ, в которой в качестве среды обмена используется канал с централизованным управлением. К основным особенностям задачи можно отнести:
в качестве исходных данных задаются набор прикладных программ, подлежащих планированию, и набор сообщений, посредством которых прикладные программы взаимодействуют друг с другом и подсистемами, изменение которых недопустимо;
время передачи сообщения зависит от расписания выполнения прикладных программ;
присутствуют технологические ограничения на корректность расписания обменов, а не только ограничения на передачу каждого сообщения в рамках его директивного интервала.
В работе приведена математическая постановка задачи, рассмотрены основные особенности задачи, отличающие её от других задач построения расписаний, проведен анализ возможных подходов к построению алгоритмов решения сформулированной задачи, предложен алгоритм, основанный на жадных стратегиях, и приведены результаты его численного исследования.
1. Задача совместного планирования вычислений и обменов. В данной главе введем понятия расписания выполнения работ и расписания передачи сообщений, сформулируем условия корректности расписаний и условия их совместимости, приведем математическую постановку задачи совместного планирования вычислений и обменов. Исходными данными для задачи совместного планирования вычислений и обменов являются набор прикладных программ (работ) и набор сообщений, посредством передачи и приема которых работы взаимодействуют друг с другом и подсистемами. Для каждой работы задан директивный интервал, в рамках которого она должна быть выполнена, и набор вычислительных модулей, на которые работа может быть размещена. Для каждого сообщения задан директивный интервал, в рамках которого оно должно быть передано. Прерывание выполнения работ и передачи сообщений недопустимо. ИУС РВ рассматривается как система, состоящая из набора вычислительных модулей и подсистем, подключенных к единой среде передачи данных. Каждая подсистема может быть представлена как набор работ (в дальнейшем работы-подсистемы), исполняющихся на отдельном вычислительном модуле, на который недопустимо назначение работ из исходного набора. Для множества работ-подсистем известно расписание. Задача совместного планирования вычислений и обменов заключается в построении согласованных статических расписаний выполнения исходно заданных работ и обменов.
Модель набора работ и сообщений, подлежащих планированию. Исходный набор работ и сообщений будем представлять ориентированным ациклическим графом (возможно, несвязным) с двумя типами вершин . Первый тип вершин соответствует работам (в том числе работам-подсистемам), второй – сообщениям. Дугами графа задаётся частичный порядок на множествах работ и сообщений. Пример графа приведен на рисунке. Квадратами отмечены вершины-работы, кругами – вершины-сообщения. Дополнительно вершины, соответствующие работам-подсистемам, отмечены пунктиром. Работы-подсистемы не подлежат планированию, но участвуют в передаче сообщений наряду с другими работами. Каждая вершина-сообщение передаёт данные от вершины-работы, являющейся её предшественником, вершинам-работам, являющимся её преемниками. Если у вершины-работы среди предшественников есть вершины-работы (как, например, вершины-работы 4 – 6), то все они вместе с исходной вершиной-работой должны быть запланированы на один и тот же вычислительный модуль, а обмен данными происходит через внутреннюю память этого модуля. При этом каждой вершине-сообщению инцидентны ровно одна входящая дуга и не менее одной исходящей дуги. Другими словами мы предполагаем, что данные, передаваемые в сообщении, формируются специальной работой, которая может брать слова данных от других работ, выполняющихся на этом же вычислительном модуле. Такой способ используется во многих ИУС РВ, в которых есть каналы с централизованным управлением. 
Обозначим через  множество вычислительных модулей,  – множество работ из исходно заданного набора, которые подлежат планированию,  – множество всех сообщений.
Для каждой вершины-работы из множества  известны:
– директивный срок начала выполнения работы (должно начаться не раньше этого срока);
 – директивный срок завершения выполнения работы (должно завершиться до наступления этого срока);
 – набор вычислительных модулей, на которые допустимо назначение этой работы для выполнения.
Также известна функция , определяющая длительность выполнения заданной работы на заданном вычислительном модуле. Здесь и далее  обозначает множество натуральных чисел. Аналогично для каждой вершины-сообщения из множества M известны: 
 – директивный срок начала передачи сообщения;
 – директивный срок завершения передачи сообщения;
Если среди предшественников или преемников вершины-сообщения есть работы из множества , то длительность передачи сообщения зависит от того, на какие вычислительные модули эти работы будут назначены. Более того, если все предшественники и преемники вершины-сообщения будут запланированы на один вычислительный модуль, то сообщение вообще не требуется передавать по среде передачи данных. В состав исходных данных входит функция, позволяющая определить длительность передачи сообщения, однако формальное её представление будет введено ниже, так как требует введения понятия привязки работ к вычислительным модулям.
Расписание выполнения работ. Расписание представляет собой множество троек вида <работа, номер вычислительного модуля на котором выполняется работа , планируемое время старта работы >: . Промежуток времени  будем называть интервалом выполнения работы . Для простоты, когда известно (или не важно), о каком расписании работ идёт речь, будем обозначать длительность выполнения работы  в нём как .
Привязкой работ к вычислительным модулям назовём множество пар <работа, вычислительный модуль>: . Будем говорить, что расписанию  соответствует привязка , если для каждой тройки в расписании есть соответствующая пара в привязке и наоборот: . Расписание  называется корректным, если выполнены следующие ограничения корректности (ограничения для многоприборных систем без прерывания работ):
1) каждая работа из набора включена не более чем в одну тройку: , где

2) требование реального времени (каждая работа выполняется в рамках своего директивного интервала): , где

3) на одном и том же вычислительном модуле в каждый момент времени может выполняться только одна работа: , где

4) каждая работа должна быть запланирована только на допустимый для неё вычислительный модуль: , где

Расписание  называется полным, если каждая работа из набора W включена в расписание. Множество всех расписаний работ (в том числе некорректных и неполных) обозначим через .
Расписание передачи сообщений. Расписание представляет собой множество пар вида <сообщение, время старта>: . Множество всех расписаний передачи сообщений из набора M обозначим через . Функция, позволяющая определить длительность передачи сообщений, выглядит следующим образом: . Поскольку длительность передачи сообщений зависит от привязки работ к вычислительным модулям, то рассматривать корректность расписания сообщений возможно только в контексте расписания выполнения работ и соответствующей ему привязке работ. Промежуток времени  будем называть интервалом передачи сообщения i. Для простоты, когда известно (или не важно), в контексте какого расписания работ идёт речь, будем обозначать длительность передачи сообщения  в нём как .
Введём две функции:
 и 
– минимальная и максимальная длительности передачи сообщения по всем возможным привязкам работ к вычислительным модулям (которые могут быть построены для данного неполного расписания). 
Расписание  называется корректным, если выполнены следующие ограничения корректности:
1) общие ограничения для одноприборных систем без прерывания работ:
1) каждое сообщение из набора включено не более чем в одну пару: , где

2) требование реального времени (каждое сообщение должно быть передано в рамках своего директивного срока) , где

3) в каждый момент времени может передаваться только одно сообщение: , где

2) ограничения корректности, обусловленные технологическими требованиями к обмену данными: , где  - функция, принимающая значение 0, если расписание обменов удовлетворяет этим ограничениям, и 1 – в противном случае.
Формализация ограничений из последнего пункта для канала с централизованным управлением приведена ниже. Расписание  называется полным, если каждое сообщение из набора M включено в расписание.
Каждое передающееся сообщение однозначно относится к некоторому множеству сообщений, называемому цепочкой, которая является последовательностью сообщений, передающихся непрерывно друг за другом, т.е.  причем :
;
;
.
Используя определение цепочки сообщений, можно ввести формальное определение ограничений корректности, обусловленных технологическими требованиями к обмену данными:
суммарная длительность передачи сообщений в цепочке не должна превышать заданного значения  (максимальная длительность цепочки сообщений):
;
число сообщений в цепочке не должно превышать заданного значения  (максимальное количество сообщений в цепочке):
;
между цепочками сообщений должен быть свободный промежуток времени, длительность которого должна быть не меньше заданного значения  (минимальный интервал между цепочками):

Совместное расписание выполнения работ и передачи сообщений. Расписание представляет собой пару расписаний вычислений и обменов . Для определения условий совместимости расписания выполнения работ и расписания передачи сообщения введём дополнительные обозначения. Для каждой вершины-работы  в графе исходных данных примем:
 – множество вершин-сообщений – непосредственных предшественников;
 – множество вершин-сообщений – непосредственных потомков;
 – множество вершин-работ – непосредственных предшественников;
 – множество вершин-работ – непосредственных потомков.
Для каждой вершины-сообщения j в графе исходных данных запишем:
 – вершина-работа – непосредственных предшественников;
 – множество вершин-работ – непосредственных потомков.
Совместное расписание H называется корректным, если выполнены следующие ограничения корректности:
1) ограничения корректности для расписания выполнения работ;
2) ограничения корректности для расписания передачи сообщений;
3) в расписании передачи сообщений запланированы все сообщения, передающие данные, необходимые для выполнения запланированных работ: , где

4) в расписании выполнения работ запланированы все работы, формирующие данные, передающиеся в запланированных в расписании обменов сообщениях: , где

5) в расписании выполнения работ все работы, передающие данные запланированным работам через внутреннюю память вычислительных модулей, запланированы  на тот же вычислительный модуль, что и получатели данных:
 Совместное расписание называется полным, если являются полными оба расписания вычислений и обменов.
Формальная постановка задачи построения согласованных расписаний выполнения работ и передачи сообщений. Число элементов в расписании выполнения работ, т.е. число запланированных работ, равно . Аналогично число элементов в расписании обменов, т.е. число запланированных сообщений, равно . Общее число запланированных элементов в совместном расписании . Пусть заданы: набор вычислительных модулей , на которые возможно планирование работ; граф исходных данных с атрибутами работ и сообщений; функция , вычисляющая время выполнения работ; функция , определяющая время передачи сообщений; конкретные значения характеристик канала с централизованным управлением: ,  и .
Задача построения совместного расписания выполнения работ и передачи сообщений заключается в построении расписания, которое содержит максимально возможное число вершин графа G и удовлетворяет условиям корректности:

К основным особенностям данной задачи, отличающим ее от других задач построения расписаний, можно отнести:
в графе исходных данных содержатся вершины двух типов: вершины-сообщения и вершины-работы, которые соответствуют прикладным задачам;
вершины-работы могут быть двух типов: работы, выполнение которых должно быть запланировано на заданном наборе вычислительных модулей, и работы, которые не подлежат планированию и выполняются на отдельном вычислительном модуле, на который недопустимо назначение других работ;
время передачи сообщения зависит от расписания выполнения работ;
присутствуют ограничения корректности сразу на все расписание сообщений, а не только временные ограничения на каждое сообщение в отдельности.
2. Известные алгоритмы, проблемы их применения и возможные подходы к решению задачи. В данном разделе обсуждаются две известные из литературы близкие задачи и алгоритмы их решения, а также четыре возможных подхода к построению алгоритмов решения рассматриваемой задачи. Под близкими задачами мы понимаем задачи, для которых набор работ, подлежащий планированию, содержит работы двух типов: работы-задачи и работы-сообщения. 
В [1] рассматривается следующая задача1. Заданы набор периодических заданий и набор вычислительных узлов системы. На размещение заданий на вычислительные узлы могут быть наложены такие ограничения, как:
два задания должны быть размещены на один и тот же узел;
два задания должны быть размещены на разные узлы;
задание может быть размещено только на узлы из некоторого подмножества всех узлов системы.
Каждое задание состоит из модулей, минимальных единиц планирования. На множестве модулей одного задания может быть определено отношение предшествования. Модули бывают двух типов: вычислительные и коммуникационные. Время выполнения вычислительного модуля зависит от узла, на который он назначен. Каждому коммуникационному модулю соответствует партнёр по коммуникации – коммуникационный модуль другого задания. Время выполнения коммуникационного модуля Mj зависит от того, на какой узел назначен партнёр, и равно , если партнёр выполняется на том же узле (локальная коммуникация), и , если на другом (удаленная коммуникация), причем . Временные задержки (например, на передачу служебных слов) при передаче сообщения между коммуникационными модулями Mi и Mj, выполняющимися на разных узлах системы, фиксированы и заданы.
Отношение времени, которое прошло от директивного срока начала задания до завершения выполнения задания, к длительности директивного срока называется нормализованным временем отклика. В [1] ставится задача нахождения расписания, в котором минимизируется максимум нормализованного времени отклика, взятый по всем заданиям и зависящий от конкретного размещения модулей заданий по узлам системы. Напомним, что в понятие расписания также включается размещение заданий по вычислительным узлам.
Алгоритм решения основан на методе ветвей и границ. Дерево поиска состоит из частичных или полных расписаний. У каждой вершины ровно столько потомков, сколько вычислительных узлов в системе. Если считать, что задано для планирования m заданий, то на уровне k дерева поиска запланировано ровно k заданий (корень считается вершиной уровня 0). Вершины уровня m представляет собой полные расписания – кандидаты в решения задачи. Вершины, в которых нарушены ограничения на размещение заданий по узлам, отбрасываются сразу же без вычисления значения критерия. В [1] предложен алгоритм оценки нижней границы значения критерия оптимальности расписания в вершине, имеющий сложность O(nM2), где n – количество вычислительных узлов, M – общее количество модулей.
При использовании описанных выше результатов применительно к решению рассматриваемой в данной статье задачи логично отождествить вычислительные модули заданий из [1] с работами, а пары коммуникационных модулей – с сообщениями. Основные отличия задачи из [1], которые препятствуют её использованию, следующие:
1) у каждого сообщения может быть только один получатель;
2) нет ограничений на расписание сообщений в целом (технологических ограничений);
3) в среде передачи данных отсутствуют конфликты, два и более сообщения могут передаваться одновременно;
4) другой критерий оптимальности расписания.
Учет этих различий будет означать построение нового алгоритма, основанного на методе ветвей и границ без использования результатов [1].
В [2] рассматривается набор периодических работ, который должен быть запланирован на набор вычислительных модулей. Работы взаимодействуют путем отправки сообщений. Каждое сообщение отправляется с минимальной частотой двух взаимодействующих работ. Для сообщений не вводится директивных сроков, но есть ограничение сверху на время между началом выполнения передающей работы и концом выполнения принимающей работы. В этот интервал должно передаться сообщение. Время на передачу каждого сообщения фиксировано. В каждый момент времени по среде может передаваться только одно сообщение. Допускаются циклические зависимости между работами. Например, экземпляр работы A шлет сообщение экземпляру работы B, который шлет сообщение следующему экземпляру работы A, и т.д. В [2] решается задача нахождения расписания, минимизирующего суммарные нарушения временных ограничений (в том числе нарушения директивных сроков).
Алгоритм, предложенный в [2], основан на схеме имитации отжига, которая используется для нахождения размещения работ по вычислительным модулям. Расписание для каждого размещения строится при помощи жадного алгоритма. Целевая функция алгоритма совпадает с целевой функцией поставленной задачи. Для нахождения очередного размещения в алгоритме имитации отжига используются четыре операции:
случайный перенос работы с более загруженного модуля на менее загруженный;
случайный выбор двух работ на разных модулях и их обмен местами;
перенос двух случайных работ с разных процессоров на один;
обмен местами двух работ, нарушающих временные ограничения.
Основные отличия задачи из [2], которые препятствуют использованию алгоритма ее решения, следующие:
1) у каждого сообщения может быть только один получатель;
2) нет ограничений на расписание сообщений в целом (технологических ограничений);
3) директивные сроки работ могут нарушаться (минимизируются суммарные нарушения временных ограничений).
Перейдем к рассмотрению возможных подходов для решения поставленной задачи. Первые два подхода основаны на декомпозиции рассматриваемой задачи на две подзадачи: построение расписания выполнения работ и построение расписания передачи сообщений.
Первый подход:
1) построить расписание передачи сообщений;
2) сузить директивные интервалы работ в соответствии с расписанием передачи сообщений;
3) построить расписание выполнение работ.
Второй подход:
1) построить расписание выполнения работ;
2) сузить директивные интервалы сообщений в соответствии с расписанием выполнения работ;
3) построить расписание передачи сообщений.
Рассмотрим возможность применения в рамках этих подходов известных алгоритмов. Задача построения расписания передачи сообщений является задачей построения одноприборных расписаний без прерываний для набора работ с индивидуально заданными директивными интервалами и известными временами выполнения. Использование алгоритмов из [3, 4] невозможно или требует значительной модификации алгоритма (практически построение нового алгоритма) из-за наличия технологических ограничений  на корректность расписания передачи сообщений. Построение расписаний передачи сообщений, удовлетворяющих ограничениям , возможно алгоритмами [5 – 7]. Однако для первого подхода не известны набор сообщений, подлежащих планированию, и времена передачи сообщений, так как набор сообщений и время передачи сообщения зависят от расписания выполнения работ, а именно от привязки работ к вычислительным модулям. Другими словами, применение первого подхода возможно, когда в качестве исходных данных для алгоритмов [5 – 7] задается множество сообщений, которые подлежат планированию, содержащее все сообщения из графа G, и время передачи каждого сообщения известно для наихудшего случая размещения работ, взаимодействующих через это сообщение (т.е. максимально возможное время передачи сообщения). Такое определение исходных данных для алгоритма построения расписания сообщений может привести к тому, что для ряда индивидуальных задач существует полное совместимое расписание , но алгоритм, разработанный на основе первого подхода, такое расписание построить не может в принципе. Это утверждение может быть доказано путем приведения примера такой индивидуальной задачи.
Для решения задачи построения расписания работ в рамках первых двух подходов граф G должен быть преобразован в граф работ G', который содержит только вершины–работы, ребра определяют отношение частичного порядка на множестве работ. Если в графе G есть ребро (работа i, сообщение j) и ребро (сообщение j, работа k), то в графе G' есть ребро (работа i, работа k). Для каждой работы графа заданы: время выполнения работы, директивный интервал, множество вычислительных модулей, на которых может выполняться работа. Существуют алгоритмы, решающие данную задачу, но основная проблема их использования следующая: алгоритм должен строить расписание работ так, чтобы по минимуму сужались директивные интервалы сообщений. Для ряда индивидуальных задач при существовании полного совместного расписания сужение директивных интервалов сообщений может привести к тому, что используемый алгоритм не будет находить полного решения.
Третий подход заключается в рассмотрении сообщений как своеобразных работ, а среды передачи данных – как процессора с технологическими ограничениями. В таком случае для построения алгоритма решения задачи можно использовать известные алгоритмы, в том числе основанные на:
жадной схеме [8], когда каждой работе (и сообщению) сопоставляется приоритет, согласно которому на каждой итерации алгоритма выбирается очередная работа для размещения в расписание; такой подход обеспечивает минимальную временную сложность, однако не всегда гарантирует нахождение точного решения;
методе ветвей и границ [9], который гарантирует нахождение точного решения задачи, а также позволяет учесть любые дополнительные ограничения на расписание, но, с другой стороны, метод обладает большой вычислительной сложностью; отдельной задачей является разработка процедуры оценки верхних и нижних границ для оптимального значения решения на подобласти дерева поиска;
методе имитации отжига [10] или генетических алгоритмов [11], которые не гарантируют нахождения точного решения, их применение требует тонкой настройки параметров (размер популяции, схема понижения температуры и т.п.) и разработки специализированных операций преобразования текущего приближения расписания (создание таких операций становится проблематичным для случая, когда заданы индивидуальные директивные интервалы работ и их нарушение недопустимо).
Все они требуют значительной модификации, но такой подход лишен основного недостатка первых двух подходов – сужения директивных сроков работ и сообщений.
Четвертый подход предполагает модификацию известного метода критического пути [12], который заключается в следующем:
1) найти в графе G самый длинный путь (критический путь); под длиной пути понимается суммарный вес вершин его составляющих или их количество,
2) запланировать одновременно все вершины из найденного пути на один и тот же процессор,
3) исключить из графа все вершины из найденного пути и дуги, которым эти вершины инцидентны,
4) повторять с п.1, пока не будет построено полное расписание.
Сложность адаптации обусловлена наличием вершин двух типов: вершин-работ и вершин-сообщений, а также заданием для вершин-работ набора вычислительных модулей, на которое допустимо назначение работы для выполнения. В составе критического пути могут присутствовать вершины разных типов и вершины работы, которые не могут быть запланированы на один вычислительный модуль.
3. Алгоритм совместного построения совместимых расписания выполнения работ и передачи сообщений. Предлагаемый алгоритм является жадным и относится к классу конструктивных алгоритмов, которые на каждом шаге достраивают частичное расписание, добавляя в него работы и сообщения. Главная проблема построения конструктивных алгоритмов – следующая особенность задачи: точная длительность передачи сообщения становится известной только после планирования (а точнее, привязки к вычислительным модулям) работ, получающих данное сообщение. Вместе с тем для любого неполного (и полного тоже) расписания можно вычислить минимальное и максимальное возможные значения времени передачи сообщения. Предлагаемый подход состоит в том, что длительность передачи сообщения считается равной максимально возможной (для данного сообщения при возможно неполной привязке работ на момент планирования). После размещения в расписание каждой работы просматриваются ранее запланированные сообщения на предмет изменения расчетной длительности передачи. На каждой итерации выбор очередной работы или сообщения для планирования происходит только среди тех, для которых уже запланированы все предшественники.
В процессе работы алгоритма ведётся список работ и сообщений, которые алгоритм не может запланировать, а также упорядоченный список PL, хранящий порядок, в котором работы или сообщения добавлялись в расписание. Ниже приведена укрупненная схема одной итерации алгоритма, в которой отражены принцип построения и основные особенности алгоритма. Детальная схема алгоритма с выделением основных операций и описанием алгоритмов их выполнения приведена в Приложении. Перед началом каждой итерации известно текущее неполное расписание. В результате выполнения итерации получается  расписание, содержащее дополнительную работу или сообщение, или становится известна точная длительность передачи ранее запланированного сообщения. Одна итерация алгоритма может быть представлена следующей схемой.
1. Вычисление с учетом текущего расписания минимально возможного времени размещения сообщения на канале и минимально возможных времен размещения работ на вычислительных модулях, вычисленные значения составляют список : одно значение для каждого модуля и одно значение для среды передачи данных. 
2. Выбор из списка  минимальных значений, составление из них списка .
3. Построение множества C незапланированных работ и сообщений, которые могут начать выполняться (передаваться) в какой-либо точке из списка  (во время равное значению элемента списка и на модуле, которому соответствует это значение). Работа (сообщение) может начать выполняться (передаваться) во время t, если уже начался её директивный интервал () и завершились все предшественники (для работ: , для сообщений: ).
4. Выбор очередной работы или сообщения из множества C по жадному критерию. Значение жадного критерия вычисляется для всех возможных пар <работа из множества C, вычислительный модуль> и для всех сообщений из множества C. Множество вычислительных модулей в паре для работы i является пересечением множества  и множества модулей, соответствующих элементам . Обозначим выбранную работу или сообщение как j, вычислительный модуль (для работы) – как q.
5. Размещение очередной работы или сообщения в расписание и добавление её в конец упорядоченного списка PL размещенных работ и сообщений.
6. Если была размещена работа j, то для всех сообщений из множества  проверяем выполнение условий:
6.1) запланированы все работы из множества , : если да, то переход к п. 6.2, иначе к – п. 6.5,
6.2) изменилась ли максимально возможная длительность передачи сообщения k: если да, то переход к п. 6.3, иначе – к п. 6.5,
6.3) привязка работ из множества  к вычислительным модулям, на которых они выполняются, т.е. множество допустимых модулей сокращается для работ из множества  до одного вычислительного модуля. Удаление из расписания передачи сообщений и выполнения работ тех сообщений и работ, которые в списке PL находятся после k,
6.4) перепланирование сообщения k с учетом известной длительности передачи; переход к п. 1,
6.5) если все сообщения из множества  были обработаны, то переход к п. 1, иначе переход к п. 6.1 для следующего сообщения из множества .
В п. 6.3 происходит переход от текущего расписания к расписанию, которое было перед планированием сообщения k. Ранее предполагалось, что сообщение имеет максимально возможную длительность передачи, теперь же работы из множества , которые влияют на длительность передачи, привязаны к конкретным вычислительным модулям, и длительность сообщения k фиксирована. Если далее в процессе работы алгоритма будет выполнен п. 6.3 для сообщения, которое было запланировано раньше k, то множества допустимых вычислительных модулей для работ из  будут восстановлены в исходное состояние.
Жадные критерии. Свойства алгоритма сильно зависят от применяемого жадного критерия. Для добавления в расписание на каждой итерации выбирается работа или сообщение, имеющее максимальное (или минимальное) значение определенного критерия. Таких критериев можно предложить несколько:
минимальный директивный срок завершения (известен в литературе как EDF): ;
минимальное раннее время завершения (рассмотрен в [1]):  и ;
минимальное количество работ и сообщений, которые не смогут быть запланированы после размещения данной работы или сообщения в расписание;
максимальное количество непосредственных потомков:  и ;
максимальное общее количество потомков;
минимальный директивный срок завершения среди всех потомков;
максимальная длина пути (в количестве вершин) до потомка, у которого нет своих потомков.
Критерий может быть многоуровневым. Если по одному из критериев работы и/или сообщения не различаются, то можно сравнить их по-другому. Среди этих критериев нет универсального или такого, который для общей задачи дает лучший результат, чем любой другой. Для каждого критерия есть своя область эффективного применения. Например, широкую область применения имеет критерий «минимальный директивный срок завершения». Но он неприменим для задач с единым директивным сроком для всех работ и сообщений. Следующий пример иллюстрирует случай, когда критерий «минимальное раннее время завершения» показывает лучше результат, чем критерий «минимальный директивный срок завершения». Характеристики пяти работ приведены в табл. 1, в системе два процессора.
При использовании критерия «минимальный директивный срок завершения» запланированы будут только первые две работы (на разные процессоры), три другие не смогут быть выполнены в рамках своих директивных сроков. При использовании же критерия «минимальное раннее время завершения» запланированы будут третья, четвертая и пятая работы. Полное расписание все равно не будет построено, но с точки зрения критерия оптимальности расписания такое решение будет лучше.
4. Экспериментальное исследование. Для исследования алгоритма было случайным образом составлено три комплекта наборов исходных данных, для которых возможно построение полного расписания. В состав всех наборов входит 300 работ, 100 сообщений и четыре процессора одинаковой производительности. Длительность выполнения каждой работы лежит на отрезке от 500 до 1500 мс. Количество слов данных в каждом сообщении лежит на отрезке от 1 до 32 (длительность передачи – от 104 до 724 мс). Длительность интервала планирования равна 500000 мс. Характеристики среды обмена следующие: мс,  и мс. В первом комплекте исходных данных отношение длительности работы или сообщения к длительности директивного интервала равно 0.1, во втором – 0.5, в третьем – 0.8. Для каждого набора исходных данных осуществлялось два запуска алгоритма с разными жадными эвристиками – минимальный директивный срок завершения (колонка EDF) и минимальное раннее время завершения (колонка ETF). Результаты представлены в табл. 2, в которой w – количество запланированных работ; m – количество запланированных сообщений; t – время работы алгоритма (процессор – Core2Duo 3ГГц); r – количество выполнений пункта 6.3 схемы итерации алгоритма (количество «возвратов»); n – количество добавлений работ и сообщений в расписание, из-за наличия возвратов составления расписания это число может превосходить суммарное количество работ и сообщений.
Величина n может являться мерой вычислительной сложности алгоритма на том или ином наборе исходных данных. Индексы min, max и avg указывают соответственно на минимальное, максимальное и среднее значение для комплекта наборов исходных данных.
Проведенные исследования показывают, что из двух выбранных жадных критериев лучшие результаты показывает критерий «минимальный директивный срок завершения». При этом при уменьшении длительности директивных интервалов результаты применения каждого из критериев ухудшаются. Это связано с тем, что при применении этих эвристик не делается обоснованный выбор процессора, на который размещается очередная работа. Полученные данные позволяют утверждать, что критерий «минимальный директивный срок завершения» пригоден для частных задач со  средним отношением времен выполнения к длительности директивных интервалов меньшим 0.1 и не пригоден для частных задач с большим значением отношения.
Заключение. В данной статье была сформулирована задача совместного планирования вычислений и обменов, возникающая при проектировании информационно–управляющих распределенных систем реального времени. Описаны основные её особенности, отличающие её от других задач построения расписаний. Были рассмотрены две известные из литературы близкие постановки задач и методы их решения. Для первой алгоритм решения основывается на методе ветвей и границ, для второй – на методе имитации отжига. Показаны отличия от рассматриваемой задачи совместного планирования, препятствующие непосредственному применению алгоритмов из этих работ. Среди таких отличий для обеих работ можно назвать наличие у сообщений только одного получателя и отсутствие поддержки ограничений корректности на все расписание сообщений (технологических ограничений). Таким образом, показано, что требуется разработка новых алгоритмов для решения рассматриваемой задачи совместного планирования вычислений и обменов. Далее были рассмотрены возможные подходы к построению алгоритмов и проанализированы сложности, возникающие при их применении. Выделены два подхода, допускающие построение алгоритмов, которые принципиально не исключают возможность нахождения алгоритмом оптимального решения для любой индивидуальной задачи: 1)подход, основанный на рассмотрении сообщений как своеобразных работ, а среды передачи данных – как процессора с технологическими ограничениями, 2)подход, основанный на идеях метода критического пути. В последних двух разделах был описан разработанный в рамках первого подхода жадный алгоритм решения поставленной задачи и проведено его экспериментальное исследование.
СПИСОК ЛИТЕРАТУРЫ
1. Peng D.-T., Shin K. G., Abdelzaher T. F. Assignment and scheduling of communicating periodic tasks in distributed real-time systems // IEEE Trans. Software Engineering. 1997. V.23(12). P. 745–758.
2. Cheng S., Agrawala A. Allocation and scheduling of real-time periodic tasks with relative timing constraints // Proc. Second Intern. Workshop on Real-Time Computing Systems and Applications. Tokyo, Japan. 1995.
3. Теория расписаний и вычислительные машины / Под ред. Э.Г. Коффмана. М.: Наука, 1984. 334 с.
4. Liu C. L., Layland J. W. Scheduling algorithms for multiprogramming in a hard-real-time environment // J. ACM. 1973. V.20(1). P. 46–61.
5. Костенко В.А., Гурьянов Е.С. Алгоритм построения расписаний обменов по шине с централизованным управлением и исследование его эффективности // Программирование. 2005. №6. С. 340-346.
6. Костенко В.А. Алгоритмы построения расписаний для одноприборных систем, входящих в состав систем реального времени // Методы и средства обработки информации: Тр. Третьей Всероссийск. научн. конф. М.: Издательский отдел факультета ВМиК МГУ; МАКС Пресс, 2009. С. 245-258.
7. Balashov V.V., Balakhanov V.A., Kostenko V.A. et al. A technology for scheduling of data exchange over bus with centralized control in onboard avionics systems // J. Aerospace Engineering. 2010. V. 224. №9. P. 993–1004.
8. Кормен Т., Лейзерсон Ч., Ривест Р. Алгоритмы: построение и анализ. М.: МЦНМО, 2000.
9. Land A. H., Doig A. G. An Automatic Method for Solving Discrete Programming Problems. // Econometrica. 1960. V. 28. P. 497-520.
10. Kirkpatrick S., Gelatt C., Vecchi M. Optimization by Simulated Annealing // Science. 1983. V. 220. P. 671-680.
11. Holland J.N. Adaptation in Natural and Artificial Systems. Ann Arbor, Michigan: Univ. of Michigan Press, 1975.
12. Kelley J., Walker M. Critical-path planning and scheduling // Proc. Easter Joint Comput. Conf. Boston, USA 1959. P. 160–173.
ПРИЛОЖЕНИЕ
Детальное описание алгоритма. Введем следующие структуры, которые будут заполняться в процессе работы алгоритма:
order – упорядоченный список работ и сообщений показывает, в каком порядке они добавлялись в расписание;
banned – множество работ и сообщений, которые алгоритм не сможет запланировать в текущее неполное расписание, каждому элементу множества сопоставлен атрибут – последнее сообщение, которое было запланировано перед добавлением элемента в это множество;
unsched – множество сообщений, которые алгоритм не сможет запланировать в принципе, сообщения из этого множества больше не рассматриваются как кандидаты на добавление в расписание;
workModule – множество работ, каждой из которой сопоставлено два атрибута – единственный вычислительный модуль, на который возможно планирование этой работы, и последнее сообщение, которое было запланировано перед добавлением элемента в множество;
unfinished – множество сообщений, запланированных с расчетной длительностью, каждому элементу множества сопоставлен атрибут – расчетная длительность, с которой было запланировано сообщение;
finished – множество сообщений, каждому из которых сопоставлен атрибут – известная длительность сообщения;
H – строящееся алгоритмом расписание, везде, где подразумевается какое-либо расписание, подразумевается расписание H.
Отметим, что всегда . Если в процессе работы алгоритма требуется узнать длительность передачи сообщения, то в первую очередь проверяется принадлежность сообщения одному из этих двух множеств. В случае если сообщение принадлежит одному из множеств, то его длительность считается равной приписанному в данном множестве атрибуту.
Процедура earliestTimeWork.
Входные данные: i – работа.
Выходные данные: t – самое раннее время, на которое возможно планирование работы i в расписание H; p – вычислительный модуль, допускающий планирование работы w на время t.
Схема выполнения процедуры.
Шаг 1. Если хотя бы один элемент из множеств  или  не запланирован в расписании H, то , p – произвольный модуль, конец.
Шаг 2. Если работа i содержится в множестве workModule (), то p – приписанный ей атрибут, t – время, когда завершаются все запланированные на модуль p работы, , перейти на шаг 4, иначе – на шаг 3.
Шаг 3. Рассмотреть множество допустимых для i модулей (множество ), t – время, когда завершаются все работы, запланированные хотя бы на один модуль из , , p – произвольный модуль из , на котором достигается значение t.
Шаг 4. Пусть  - время, когда завершаются все предшественники w.
Шаг 5. , конец.
Процедура earliestTimeMessage.
Входные данные: j – сообщение.
Выходные данные: t – самое раннее время, на которое возможно планирование сообщения j в расписание H.
Схема выполнения процедуры. Аналогично процедуре earliestTimeWork с проверкой ограничений на корректность расписания сообщений: добавление сообщения в конец цепочки сообщений не должно приводить к нарушению требований к максимальной длительности цепочки и максимальному количеству сообщений в цепочке; если сообщение будет первым в цепочке, то промежуток времени после конца последней цепочки должен быть не меньше минимального интервала.
Процедуры banWork и banMessage. Данные процедуры добавляют заданную работу или заданное сообщение соответственно и всех её или его потомков во множество «непланируемых» (множество banned).
Процедура getCandidatesAndBan. Данная процедура вычисляет наименьшее время, на которое возможно планирование работ и/или сообщений в расписании H, а также находит работы и сообщения, которые могут быть запланированы на это время. Для работ дополнительно указывается модуль, который позволяет планировать на полученное время. Если работу или сообщение заведомо не удастся запланировать, то для неё выполняется banWork или banMessage.
Выходные данные: time – самое раннее время, на которое возможно планирование работ и/или сообщений в расписание H; candsW – множество работ, которые можно запланировать на время time, каждой работе из набора сопоставлен атрибут – модуль, который позволяет такое планирование; candsM – множество сообщений, которые можно запланировать на время time.
Схема выполнения процедуры.
Шаг 1. Инициализация:
1) ;
2) ;
3) .
Шаг 2. Для каждой незапланированной работы , такой, что  и запланированы все предшественники (работы из  и сообщения из ):
1) пусть ;
2) если , то и перейти на шаг 2.д;
3) если , то:
i) ;
ii) ;
iii) ;
iv) добавить в candsW работу i с атрибутом p;
4) если , то добавить в candsW работу i с атрибутом p;
5) перейти к началу шага 2 для следующей незапланированной работы .
Шаг 3. Для каждого незапланированного сообщения , такого, что  и запланирована работа-предшественник :
1) пусть ;
2) если , то и перейти на шаг 3.д;
3) если , то:
i) ;
ii) ;
iii) ;
iv) добавить в candsM сообщение j;
4) если , то добавить в candsM сообщение j;
5) перейти к началу шага 3 для следующего незапланированного сообщения .
Шаг 4. Конец.
Процедура rollback. Данная процедура осуществляет возврат процесса планирования на тот момент, когда было запланировано заданное сообщение, с возможной привязкой работ-потомков к конкретным вычислительным модулям.
Входные данные: j – запланированное сообщение; bind – признак, определяющий будет ли осуществляться привязка работ-потомков к вычислительным модулям.
Схема выполнения процедуры.
Шаг 1. Если установлен признак bind, то для каждой запланированной работы i – потомка j (): добавить i в множество workModule с атрибутом – модулем, на который запланирована работа i.
Шаг 2. Если последний элемент списка order является сообщением k, то
1) удалить из множества banned все элементы с атрибутом k;
2) если не установлен признак bind или , то удалить из множества workModule все элементы с атрибутом k.
Шаг 3. Если последний элемент списка order работа, то удалить её из множества workModule;
Шаг 4. Если последний элемент списка order совпадает с сообщением j, то конец, иначе удалить из списка order последний элемент и перейти на шаг 2.

Основная схема работы алгоритма:
Шаг 1. Инициализация:
1) ;
2) ;
3) ;
4) ;
5) ;
6) 
7) .
Шаг 2. Для каждого k – элемента множества unsched выполнить banMessage(k).
Шаг 3. Выполнить процедуру getCandidatesAndBan, пусть t, candsW и candsM – результаты её работы.
Шаг 4. Если candsW=Ø и candsM=Ø, то:
1) рассмотреть список order, пусть j – первое нерассмотренное сообщение;
2) если среди потомков j нет работ-подсистем и ни один из потомков не запланирован, то:
i) выполнить rollback(j, false);
ii) удалить j из списка order;
iii) удалить j из расписания H;
iv) добавить j в множество unsched;
v) перейти на шаг 2; 
3) если  и t – её расчетная длительность больше фактической (), то:
i) выполнить rollback(j, true);
ii) перепланировать сообщение j с учетом изменившейся расчетной длительности на время earliestTimeMessage(j);
iii) установить  в качестве атрибута j в множестве unfinished;
iv) перейти на шаг 2;
4) конец.
Шаг 5. Выбрать из множеств candsW и candsM по жадному критерию работу или сообщение, которое будет запланировано следующим.
Шаг 6. Если была выбрана работа i, то:
1) запланировать в расписание H работу i на тот модуль, что сопоставлен ей в множестве candsW на время t;
2) добавить работу i в конец списка order;
3) рассмотреть список order, пусть j – первое нерассмотренное сообщение;
4) если длительность передачи сообщения j определилась, :
i) если сообщение j не укладывается в свой директивный срок, , то:
1) выполнить rollback(j, false);
2) удалить j из списка order;
3) удалить j из расписания H;
4) выполнить banMessage(j);
5) перейти на шаг 2;
ii) добавить сообщение j в множество finished с атрибутом ;
iii) удалить сообщение j из множества unfinished, пусть t – атрибут j в этом множестве;
iv) если фактическая длительность передачи сообщения меньше расчетной, , то:
1) выполнить rollback(j, true);
2) перепланировать сообщение j с учетом изменившейся расчетной длительности на время earliestTimeMessage(j);
3) перейти на шаг 2.
Шаг 7. Если было выбрано сообщение j, то:
1) запланировать в расписание H сообщение j на время t;
2) добавить сообщение j в конец списка order;
3) если длительность передачи сообщения точно известна, , то добавить сообщение j в множество finished с атрибутом ;
4) иначе добавить сообщение j в множество unfinished с атрибутом .
Шаг 8. Если остались незапланированные работы или сообщения, то перейти на шаг 3, иначе конец.
Таблица 1. Пример для критерия «минимальное раннее время завершения»
Работа



1
0
3
3
2
0
3
3
3
0
4
2
4
0
4
2
5
0
4
2

Таблица 2. Результаты экспериментального исследования
№
1
2
3

EDF
ETF
EDF
ETF
EDF
ETF

289
280
249
247
233
232

300
300
269
268
261
259

297.96
295.26
259.64
257.34
248.08
247.28

90
84
56
56
45
47

100
100
80
81
75
73

98.06
96.68
69.32
67.98
62.9
62.38

6
3
40
17
39
32

644
414
2192
3698
2540
1963

61.54
54.86
463.96
433.36
471.76
365.02

3
1
63
37
61
57

756
817
5596
6086
7937
5233

86.88
91.56
968.86
878.18
1096.86
758.64

637
441
3290
1589
3037
2375

36189
34917
131572
182555
184233
131932

4924.52
5154.84
30952.74
29111.02
32314.28
24001.2

Подрисуночные подписи к статье «Жадный алгоритм совместного планирования вычислений и обменов в системах реального времени» В. А. Костенко и П. Е. Шестова.

Рисунок. Граф зависимости работ и сообщений
ТиСУ №3-12
Рисунок к статье «Жадный алгоритм совместного планирования вычислений и обменов в системах реального времени» П. Е. Шестова и В. А. Костенко
