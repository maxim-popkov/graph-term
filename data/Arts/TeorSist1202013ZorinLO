ИЗВЕСТИЯ РАН. ТЕОРИЯ И СИСТЕМЫ УПРАВЛЕНИЯ, 2012, № 2, с. 124–131

 	 КОМПЬЮТЕРНЫЕ   	 МЕТОДЫ
УДК


АЛГОРИТМ СИНТЕЗА АРХИТЕКТУРЫ ВЫЧИСЛИТЕЛЬНОЙ СИСТЕМЫ РЕАЛЬНОГО ВРЕМЕНИ
С  УЧЕТОМ  ТРЕБОВАНИЙ  К  НАДЕЖНОСТИ
© 2012 г.  Д. А. Зорин, В. А. Костенко
Москва, МГУ
Принята в редакцию 22.09.11 г., после доработки 01.11.11 г.


Рассматривается задача построения вычислительной системы реального времени с мини- мальным числом процессоров. При этом требуется соблюдение директивных сроков на время выполнения программы, а также должны быть выполнены требования к надежности систе- мы, которые подразумевают, что система должна выдерживать как аппаратные, так и про- граммные отказы. Приведена формальная постановка данной задачи, предложен метод ее ре- шения с использованием итерационного алгоритма построения расписания, основанного на методе имитации отжига, и проведено экспериментальное исследование предложенного ал- горитма.
Compaq_615
2013-01-26 07:57:46
--------------------------------------------
№ 3, С.76–83. 


Введение. В [1, 2] предложен подход к построению алгоритмов на основе схемы имитации от- жига для решения задачи построения расписания с минимальным временем выполнения на за- данном числе процессоров. Алгоритмы на основе схемы имитации отжига последовательно из- меняют расписание с целью уменьшения времени его выполнения. Основными проблемами, ко- торые необходимо решить для построения алгоритма, является введение системы операций преобразования расписания и разработка стратегии применения этих операций на каждой ите- рации алгоритма. Система преобразования операций должна допускать существование цепочки операций конечной длины, позволяющей преобразовать произвольный корректный вариант расписания в оптимальный вариант расписания, и при этом все промежуточные расписания должны быть корректными. Стратегия применения операций на каждой итерации алгоритма определяет его сложность и точность.
В данной работе подход к построению системы операций преобразования расписаний и стра- тегии их применения расширен для решения задачи синтеза архитектуры вычислительной си- стемы реального времени, а именно определения минимального необходимого числа процессо- ров и построения статического расписания выполнения прикладных программ. При этом долж- ны соблюдаться заданные ограничения на время выполнения расписания и надежность вычислительной системы. Повышать надежность системы можно с помощью введения резерв- ных элементов – как процессоров, так и копий программных модулей. В данной работе для по- вышения надежности вычислительной системы используется горячее резервирование процессо- ров и многоверсионное программирование. Задачи такого типа возникают при проектировании систем жесткого реального времени.
1. Задача построения расписания с минимизацией числа используемых процессоров. 1.1. М о - д е л ь с и с т е м ы. Аппаратная часть системы состоит из множества процессоров, соединенных друг с другом посредством коммутатора. Все процессоры одинаковы, т.е. время выполнения од- ной и той же программы будет одинаково на любом процессоре, и надежность процессоров оди- накова. Известно время передачи единицы данных от одного процессора к другому. Коммутатор устроен таким образом, что если к нему подключено N процессоров, то гарантируется наличие N/2 свободных каналов в любой момент времени, таким образом, для любой передачи всегда найдется канал. Существуют реальные коммутаторы, удовлетворяющие данным требованиям, в частности, это коммутатор FibreChannel.
Программа, для которой строится расписание, состоит из конечного множества взаимодей- ствующих заданий. Для каждого из заданий известно, какие вычисления оно производит и каков объем результата, получаемого на выходе. Программу можно представить в виде графа потока данных. Формально модель системы состоит из следующих объектов:
M – счетное множество процессоров,
G = {V, E} – граф потока данных программы, ориентированный граф без циклов,

124

V – множество вершин, соответствующих заданиям,
E – множество ребер; в графе есть ребро (v , v ), если задание v

принимает на вход результа-
1
ты работы задания v ,
1	2	2
F : E → – функция, задающая объем передаваемых данных для каждой взаимодействую- щей пары заданий,
A : M × M → – функция, задающая время передачи единицы данных между двумя процес- сорами; если первый аргумент равен второму, то значение этой функции равно нулю: передача данных в пределах одного процессора не занимает времени,
C : V × M → – функция, задающая время работы задания на определенном процессоре; для каждого задания определена мера вычислительной сложности, по которой можно рассчитать время выполнения на конкретном процессоре.
В работе введены следующие ограничения:
∀mi, mj ∈ M, v ∈ V: C(v, mi) = C(v, mj) (функция C не зависит от m, поэтому в дальнейшем будем для простоты писать C(V));
∀mi, mj ∈ M, mi ≠ mj: A(mi, mj) = 1. Время передачи единицы данных между любыми двумя про- цессорами одинаково. Далее для простоты время передачи данных от одного задания к другому
вместо F(v , v ) · A(m , m ) будем обозначать F(v , v ).
1	2	1	2	1	2
1.2. Модель надежности. Рассмотрены два метода повышения отказоустойчивости: ре- зервирование для процессоров и многоверсионное программирование. Резервирование процес- соров заключается в том, что в систему добавляется новый процессор, на котором выполняются те же задания, что и на другом. В этом случае система отказывает, только если отказывают оба процессора. Дублирующий процессор работает в режиме горячего резерва, т.е. принимает все те же данные и выполняет те же вычисления, что и основной, но передает данные только в случае отказа основного. Устройство коммутатора таково, что введение резервного процессора не вы- зывает никаких задержек в работе системы.
У т в е р ж д е н и е 1. Пусть на процессоре mi выполняются задания v …v . Тогда добавление
1	n
резервного процессора mr и дублирование на нем всех заданий v …v
обеспечивает  надежность
1	n
не меньшую, чем добавление резервных процессоров mr…mr+k и дублирование на каждом из них
некоторых из заданий v …v .
1	n
При многоверсионном программировании создается несколько версий реализации какого- либо задания и считается, что если больше половины из них выдали идентичный результат, то за- дание завершается успешно.
i
i
i
Для задания модели надежности системы необходимо, чтобы были известны величины P(mi) – надежность отдельного процессора, Vers(v ) – множество доступных версий каждого из заданий, P(v ) – надежность отдельного задания с учетом количества версий. Формулы для вы- числения P(v ) при различных конфигурациях версий приведены в [3–6]. Надежность всей си- стемы определяется как произведение надежностей всех ее компонентов.
1.3. М о д е л ь р а с п и с а н и я. Будем считать, что для программы задано расписание, если для каждого из заданий определены привязка – однозначно известно, на каком процессоре оно выполняется, и порядок – для каждого процессора известно, в какой очередности выполняются задания. Если используется многоверсионное программирование, то помимо указания задания необходимо указывать номер его версии, т.е. привязка и порядок определяются не для задания, а для пары “задание–версия”.
Формально расписание (для системы с резервированием и многоверсионным программиро- ванием) определяется как пара (S, D). Здесь S – множество четверок (v, k, m, n), где v ∈ V, k ∈
∈ Vers(v), m ∈ M, n ∈ N, такое, что
∀v ∈V ∀k ∈Vers (v) : ∃! s = (vi, ki, mi, ni ) ∈ S : vi  = v,
ki  = k;
∀si = (v i, ki, mi, ni ) ∈ S,
∀s j  = (v j, k j, m j, n j ) ∈ S : (si  ≠ s j  ∧ mi  = m j ) ⇒ ni  ≠ n j.
Второй элемент, D – мультимножество, состоящее из элементов множества процессоров M. Содержательно m и n задают соответственно привязку к процессору и порядок выполнения для каждой версии каждого задания. Мультимножество D обозначает резервируемые процессоры.
Расписание можно представить в виде графа. Вершинами этого графа являются элементы множества S. Если между соответствующими заданиями есть дуга в графе G, то она добавляется в граф расписания, также в граф расписания добавляются дуги между вершинами, назначенны-

ми на один процессор и имеющими соседние номера. Элемент расписания s2 будем называть за-
висимым от s1, если либо (v , v ) ∈ E, либо m = m
∧ n  < n . Иначе говоря, s
зависит от s , если s
1	2	1
2	1	2
2	1	2
не может начать выполняться раньше s1 из-за зависимости по данным или порядка выполнения на процессоре.
Из определения следует, что каждая версия каждого задания может присутствовать в расписа- нии в единственном экземпляре, а также на каждом процессоре у всех заданий различные номе- ра и как минимум одна версия каждого задания должна быть включена в расписание. Помимо этих ограничений необходимо ввести еще одно, чтобы гарантировать завершимость программы. Будем говорить, что расписание S корректно, если его граф является ациклическим. Множество
всех корректных расписаний обозначим S . Для каждого корректного расписания определены функции t(S) – время выполнения расписания, R(S) – надежность системы при заданном распи- сании и M(S) – количество процессоров, требуемых для работы по данному расписанию.
1.4. П о с т а н о в к а з а д а ч и. Пусть заданы программа G, tdir – срок, к которому программа должна быть выполнена, и Rdir – надежность, которой должна обладать система. Требуется по- строить расписание  S, для которого требуется минимальное  количество  процессоров,  но  при этом удовлетворяются ограничения на время выполнения и надежность:
min M(S);
S ∈ S
t(S) < t dir ,
R(S) > Rdir .
(1.1)
У т в е р ж д е н и е 2. Задача (1.1) является NP-трудной.
Данное утверждение может быть доказано путем сведения к задаче о разбиении множества чисел на два подмножества с равной суммой [7]. Каждому числу ai в задаче о разбиении ставится
в соответствие задание vi со временем выполнения C(v ) = a , связей между заданиями нет, Rdir = 0,
i	i
директивный срок tdir равен полусумме всех чисел {ai}.
i
1.5. Операции преобразования расписани я. Введем следующие обозначения: Dup(mi) – кратность процессора mi в мультимножестве D; Dep(s) – множество таких элементов si, что в графе G есть ребро (v , v), т.е. множество вершин – непосредственных предшественников s; Succ(s) – множество заданий, косвенно зависящих от s. По определению, si ∈ Succ(sj), если либо
в графе G есть путь из v в v , либо в графе расписания есть путь из s в s , не содержащий ребро от
j	i	j	i
sj к следующему за ним заданию на процессоре. Для преобразования расписаний введены следу- ющие операции.
Операция добавления резервного процессора. В исходном расписании (S, D) к мультимножеству D добавляется новый элемент. При этом создается дополнительная нагрузка на среду передачи данных, так как на резервный процессор передаются все необходимые данные, однако время пе- редачи данных между основными процессорами не меняется, так как в силу описанного ранее устройства среды обменов для передачи данных на резервные процессоры гарантированно най- дутся свободные каналы.
Операция удаления резервного процессора. В исходном расписании (S, D) из мультимножества
D удаляется элемент m, для которого Dup(m) > 1.
Операция переноса задания. В исходном расписании (S, D) выбирается элемент s1 = (v , k , m ,
n1), процессор m2 и номер n2, такой, что
∀si  = mi  = m2 : (ni  < n2 ⇒ si ∉ Succ(s1)) ∧ (ni  ≥ n2 ⇒ s1 ∉ Succ(si )),
и происходит следующая замена:
1	1	1
s1' = (v1, k1, m1, n1),
∀si  : mi  = m2 : ni  ≥ n2 ⇒ si' = (v i, ki, mi, ni  + 1).
Эта операция позволяет или изменить порядковый номер выполнения задания на процессо- ре, или перенести задание на другой процессор.
Операция добавления версии. Версии можно добавлять только парами в силу принципа работы NVP. Добавление одной версии (v, k) эквивалентно следующей последовательности операций: 1) добавить новый процессор m0; 2) назначить версию первым заданием на этот процессор s = (v, k, m0, 1); 3) перенести s на другой процессор в соответствии с определением операции переноса за- дания; 4) удалить m0.
Операция удаления версии. Версии удаляются также парами. Из расписания удаляются два эле- мента, соответствующих удаляемым версиям.

У т в е р ж д е н и е 3. Замкнутость системы операций. Если (S, D) – корректное расписание, то после применения любой из операций также получается корректное расписание.
У т в е р ж д е н и е 4. Полнота системы операций. Если (S1, D1), (S2, D2) – корректные распи- сания, то существует последовательность операций, приводящая (S1, D1) к (S2, D2), такая, что все промежуточные расписания корректны.
Доказательство этих утверждений может быть проведено аналогично доказательству утвер- ждения о замкнутости и полноте системе операций преобразования расписаний для решения за- дачи построения расписания с минимальным временем выполнения на заданном числе процес- соров, которое приведено в [8].
2. Алгоритм построения расписания. 2.1. Общая схема алгоритм а. Для решения сфор- мулированной задачи предлагается алгоритм, основанный на схеме имитации отжига. Общая схема работы одной итерации алгоритма следующая.
Ш а г 1. Анализируется текущее приближение расписания и выбирается операция для выпол- нения.
Ш а г 2. Выбираются параметры операции, и она выполняется.
Ш а г 3. Если после выполнения операции новое расписание оказывается лучше предыдуще- го, делается переход к новому расписанию: оно берется в качестве следующего приближения. Ес- ли новое расписание хуже, то переход делается с некоторой вероятностью.
Ш а г 4. Если достигнут критерий останова, алгоритм завершает работу.
В качестве возможных операций используются операции, введенные в разд. 1. Наиболее важ- ным элементом алгоритма является используемая в нем стратегия применения операций над расписанием. Стратегия для заданного текущего приближения определяет, какую операцию сле- дует применить и какие для этой операции следует выбрать параметры, т.е. задает поведение ал- горитма на шагах 1 и 2 в вышеописанной схеме. Далее рассмотрим каждый из шагов подробно.
2.2. В ы б о р о п е р а ц и и. Выбирать операцию случайным образом нецелесообразно (как это обычно делается в алгоритмах имитации отжига), поскольку не все операции одинаково не- обходимы в конкретной ситуации. Так, если надежность в некотором расписании не ниже требуе- мой, нет смысла добавлять новые версии и процессоры, так как это только ухудшит время выпол- нения и увеличит количество процессоров. Поэтому предлагается перед выбором операции анали- зировать текущие характеристики расписания и на основе этого анализа выбирать операцию.
Поскольку соблюдение имеющихся в задаче двух ограничений на время и надежность являет- ся обязательным (в то время как число процессоров есть оптимизируемый параметр), рассмат- риваются четыре ситуации: t > tdir, R > Rdir; t > tdir, R < Rdir; t < tdir, R > Rdir; t < tdir, R < Rdir. Если на- дежность меньше, чем требуется, то следует добавлять процессоры и версии, иначе их можно удалять. Если время выполнения превышает директивный срок, то имеет смысл либо удалять версии, либо переносить задания на другие позиции в расписании. Чтобы избежать потенциаль- ных зацикливаний алгоритма, выбор операции сделан недетерминированным. Для каждой из четырех возможных ситуаций заданы вероятности выбора той или иной операций (в том числе возможны нулевые значения). Эти вероятности являются параметрами настройки алгоритма и задаются до начала работы алгоритма. В разд. 3 будут приведены значения этих параметров, с ко- торыми проходило исследование алгоритма.
Применение некоторых операций на определенной итерации алгоритма может быть невозмож- но. Например, если ни у одного процессора нет резервных копий, то удалять процессоры нельзя, а если все имеющиеся версии использованы, то нельзя добавлять версии. Такую ситуацию всегда можно определить, поэтому на этом шаге невозможные операции не рассматриваются.
2.3. В ы б о р п а р а м е т р о в о п е р а ц и й. После выбора операции необходимо выбрать со- ответствующий набор параметров.
Добавление версии. Случайно выбирается задание, версии которого добавляются (среди зада- ний, для которых имеется нужное количество доступных версий). Вероятность выбора задания обратно пропорциональна количеству уже использующихся его версий.
Удаление версии. Случайно выбирается задание, версии которого удаляются. Вероятность вы- бора задания пропорциональна количеству уже использующихся его версий.
Добавление резервного процессора. Аналогично добавлению версии задания, процессоры с меньшим числом резервов имеют большую вероятность добавления.
Удаление резервного процессора. Удаляется резерв для случайно выбранного процессора. Чем больше резервов процессоров, тем больше вероятность его удаления.



Выбор параметров
t < tdir	t >tdir


Уменьшение числа процессоров
Уменьшение времени выполнения
p < pcut
p > pcut	p < p
p > pnew


new
Перенос заданий с некоторого процессора




Перенос плохо расположенного задания
Перенос задания на новый процессор



Стратегия уменьшения задержек
Стратегия заполнения простоев

Смешанная стратегия


Рисунок. Выбор параметров для операции


Вероятности удаления и добавления процессоров и версий заданы таким образом, чтобы стремиться соблюдать баланс между надежностью различных компонентов.
Перенос задания. На рисунке приведена схема выполнения данной операции (в ней p – слу- чайное число от 0 до 1). Рассмотрим ее подробнее.
Если t < tdir, т.е. директивный срок не нарушается, то следует пытаться уменьшить число про- цессоров. С вероятностью pcut происходит следующая операция: выбирается процессор, на кото- ром меньше всего заданий, и все задания с него переносят на другие процессоры. С вероятно- стью 1 – pcut выполняется процедура переноса задания в соответствии с одной из трех стратегий, описанная далее.
Если t > tdir, то необходимо улучшить время выполнения расписания. Это можно сделать, если перенести часть заданий на пустой процессор либо поменять порядок или привязку на существу- ющих. С вероятностью pnew выбирается случайное задание (вероятность зависит от задержки, по- дробно описанной далее) и переносится на отдельный процессор. С вероятностью 1 – pnew вы- полняется одна из стратегий выбора параметров операции переноса задания: уменьшение задер- жек, заполнение простоев и смешанная стратегия.
Стратегия уменьшения задержек основана на следующем утверждении. Если время начала выполнения каждого задания равно длине критического пути в графе G от истоков до задания, то расписание будет оптимальным. Длина критического пути является минимально возможным временем начала выполнения задания и равна сумме времен выполнения заданий, соответству- ющих вершинам критического пути. Для каждого элемента расписания s можно определить мо- мент времени, когда s может начать выполняться, т.е. все задания из Dep(s) завершены. Разница между этим моментом и моментом, когда задание s начало выполняться, является задержкой за- дания s. В качестве параметра алгоритма задается натуральная константа Cver, и первым парамет- ром операции переноса становится одно из Cver заданий с наибольшей задержкой: чем больше за- держка, тем больше вероятность выбора задания. Далее определяется позиция (пара (m, n) из четверки, определяющей элемент расписания), куда можно перенести выбранное задание. Это задание переносится на случайно выбранную позицию (в которую перенос возможен без нару-

Таблица 1. Вероятность перехода к новому приближению

M(S) > M(Snew)
M(S) = M(Snew)
M(S) < M(Snew)

t < tdir
t > tdir

t < tdir
t > tdir

t < tdir
t > tdir
R > Rdir R < Rdir
1
f1(d)
f1(d)
f2(d)
R > Rdir R < Rdir
f1(d)
f2(d)
f2(d)
f3(d)
R > Rdir R < Rdir
f2(d)
f3(d)
f3(d) 0

шения условий корректности), причем чем раньше по времени стоит задание, занимающее эту позицию в текущий момент, тем вероятнее перенос.
Стратегия заполнения простоев основана на эмпирической гипотезе: чем меньше времени в сумме простаивают процессоры, тем лучше расписание. Для каждой позиции (m, n) можно опре- делить время простоя. Если n = 1, то простой – время от начала работы до начала выполнения задания на позиции (m, 1). Если позиция (m, n) обозначает место после завершения последнего задания на процессоре m, то простой – время от конца работы последнего задания на m до конца выполнения всего расписания. Иначе простой позиции (m, n) – это время между концом работы задания в (m, n – 1) и началом работы задания в (m, n). Из всех позиций выбираются Cpos позиций с максимальным простоем, на которые допустимо переместить выбранное задание, после чего из них выбирается случайно одна позиция, причем наибольший приоритет имеют позиции, зада- ния на которых начинаются раньше по времени. Задание для переноса выбирается случайно (при соблюдении условий корректности), при этом чем позже оно стоит, тем больше вероятность его выбора.
Смешанная стратегия объединяет две предыдущих. В качестве первого параметра операции переноса выбирается одно из Cver заданий с наибольшей задержкой, чем больше задержка, тем больше вероятность выбора задания. Из всех позиций выбираются Cpos позиций с максимальным простоем, на которые допустимо переместить выбранное задание, после чего из них выбирается случайно одна позиция, причем наибольшую вероятность имеют позиции, задания на которых начинаются раньше по времени. Таким образом, в этой стратегии ищутся области в расписании, когда один из процессоров бездействует в ожидании завершения работ на других процессорах, при этом делается попытка поставить задание с большой задержкой как можно раньше, чтобы уменьшить время задержки.
2.4. У с л о в и е п е р е х о д а. После применения выбранной операции получается новое рас- писание, для которого можно рассчитать время выполнения, надежность и число процессоров. В зависимости от соотношений характеристик нового и предыдущего расписаний, новое распи- сание может стать текущим приближением на следующей итерации алгоритма. Как и в стандарт- ном алгоритме имитации отжига, присутствует параметр d, моделирующий температуру. Его на- чальное значение высокое, но с каждой итерацией оно уменьшается.
Вероятность перехода к новому приближению задается тремя функциями f1(d), f2(d), f3(d), ко- торые должны принимать значения от 0 до 1 и убывать с ростом d. Предполагается, что ∀d: f1(d) ≥
≥ f2(d) ≥ f3(d). Вероятности выбора нового расписания в качестве приближения на следующей
итерации для разных соотношений времени, надежности и числа процессоров приведены в табл. 1. Конкретный вид функций, которые были использованы при экспериментальном исследовании алгоритма, представлен в разд. 3.
2.5. Вычислительная сложность и корректность алгоритм а. Вычисли- тельная сложность одной итерации алгоритма составляет O((N + E)2), где N – число вершин гра- фа программы G, а E – число его ребер.
Корректность алгоритма следует из того, что к расписаниям применяются только операции, описанные в разд. 1, а согласно утверждению 3, в результате применения любой из этих опера- ций получается корректное расписание.
3. Экспериментальное исследование алгоритма. 3.1. Классификация исходных дан- н ы х . Все возможные частные задачи рассматриваемой задачи построения расписания можно классифицировать по следующим параметрам: N – число заданий (от 1 до бесконечности), E – число связей между заданиями (от 0 и не более N2), Q – соотношение между суммарным временем выпол- нения заданий и временем передачи данных при отсутствии конфликтов в среде передачи данных. Рассмотрим еще два параметра классификации частных задач, которые определяются отноше- нием директивного срока и оценками нижней границы времени выполнения программы и отно- шением требуемой надежности и оценками верхней границы надежности.

9   ИЗВЕСТИЯ РАН. ТЕОРИЯ И СИСТЕМЫ УПРАВЛЕНИЯ	№ 2	2012

Нижнюю границу времени выполнения программы можно оценить, найдя в графе програм- мы критический путь (путь, имеющий максимальное суммарное время выполнения входящих в него заданий). Эта граница не гарантирует существование решения, так как возможны задержки при выполнении заданий из этого пути из-за передачи данных. Если прибавить к суммарному времени выполнения критического пути суммарное время передачи данных для всех его зада- ний, то получится более реалистичная оценка нижней границы времени выполнения програм- мы. Из-за возможных конфликтов на портах существование решения не гарантируется и в этом случае. Выделим следующие отношения нижних оценок времени выполнения программы к за- данному директивному интервалу.
Невозможное: 0 < tdir < L, где L – длина критического пути. Данный вариант интересен только для исследования поведения алгоритма на заведомо неразрешимых задачах.
Очень жесткое: tdir ≈ L.
Жесткое: tdir ≈ L + K, где K – время передачи данных для всех заданий критического пути. Нормальное: tdir ? L + K.
Заведомо выполнимое: tdir = +∞.
Верхнюю границу надежности системы можно оценить как произведение надежностей всех заданий при использовании максимального доступного числа версий в NVP. Будем считать огра- ничение на требуемую надежность жестким, если оно равно этой верхней границе. Нормальным ограничением будем считать ограничение, достижимое при наличии у каждого из процессоров не больше одного резерва и использования не более трех версий каждого задания.
3.2. Формулировка гипотез и способ  их  проверк и. Гипотеза о субоптималь- ности алгоритма. Пусть E ≈ N, отношения нижних оценок времени выполнения программы к за- данному директивному интервалу и отношения оценок надежности к заданному значению на- дежности нормальные, Q > 1. Пусть
= N
tS	∑C(vi ),
=

Mmin


=
[tS

/t dir ].
i    1
Тогда при любом значении N с уровнем значимости α выполняется гипотеза: алгоритм выдает в качестве результата расписание S, такое, что M(S) ≤ Mmin + 1 с вероятностью не ниже θ0. Число Mmin  – нижняя оценка для минимального числа процессоров, так как если взять меньшее число
процессоров, то с учетом ограничения на время выполнения все задания на них распределить не- возможно. Данная гипотеза утверждает, что алгоритм находит решение, не более чем на единицу превосходящее оптимальное.
Гипотеза о локальной оптимальности алгоритма. Пусть отношения нижних оценок времени выполнения программы к заданному директивному интервалу и отношения оценок надежности к заданному значению надежности нормальные. Тогда при любых значениях N, E, Q с уровнем значимости α выполняется гипотеза: алгоритм с вероятностью не ниже θ0 выдает в качестве ре- зультата расписание S, такое, что для любого расписания S', которое можно получить из S при- менением одной операции, выполняется выражение M(S) ≤ M(S') ∨ t(S') > tdir ∨ R(S') < Rdir.
Данная гипотеза утверждает, что результат, выдаваемый алгоритмом, является локально опти-
м⎯альным, т.е. применение любой операции к этому расписанию не улучшает его характеристики. Гипотезы проверялись с помощью Z-тестов [9] со следующими параметрами: число экспери-
ментов: 100, значимость α = 0.05, вероятность успеха 0 = 0.9. Использовались следующие на- стройки алгоритма: Cver = N/3, Cpos = N/3, pnew = 0.5, pcut = 0.5, число итераций равно 10N, f1(d) = 1 – d/(30N), f2(d) = 1 – d/(20N), f3(d) = 1 – d/(10N). Вероятности выбора операций приведены в табл. 2. В качестве начального приближения алгоритма использовалось расписание, в котором у каждого из заданий была только одна версия, и каждое задание было расположено на отдельном
процессоре.
3.3. Р е з у л ь т а т ы э к с п е р и м е н т о в. Результаты тестов показывают, что гипотеза о суб- оптимальности алгоритма является верной. Наблюдаются небольшие изменения в точности раз- ных стратегий выбора параметров операции переноса заданий и при разном объеме входных данных, но они не являются статистически значимыми. Гипотеза о локальной оптимальности алгоритма также была доказана. Следует заметить, что, несмотря на это, во многих выданных ал- горитмом решениях можно было уменьшить время выполнения (без изменений надежности и числа процессоров) с помощью одной итерации, что не противоречит данной ранее формули- ровке гипотезы. Кроме того, экспериментально была подтверждена ранее полученная теорети-

Ситуация
Добавление процессора
Удаление процессора
Добавление версии
Удаление версии
Перенос задания
t > tdir, R > Rdir
0
1/6
0
1/3
1/2
t < tdir, R > Rdir
0
1/3
0
1/6
1/2
t > tdir, R < Rdir
1/2
0
1/3
0
1/6
t < tdir, R < Rdir
1/3
0
1/2
0
1/6

ческая оценка вычислительной сложности одной итерации алгоритма. Проведенное исследова- ние показало общую эффективность предложенного алгоритма при применении к частным за- дачам, которые возникают при проектировании вычислительных систем реального времени.
Заключение. В рамках данной работы была сформулирована задача синтеза архитектуры вы- числительной системы реального времени с учетом требований к надежности как задача комби- наторной оптимизации. Был разработан итерационный алгоритм решения сформулированной задачи и теоретически обоснована его корректность. Выделен практически значимый класс ис- ходных данных, для которого сформулированы и доказаны статистические гипотезы об основ- ных свойствах алгоритма: субоптимальность алгоритма и его локальная оптимальность.


СПИСОК ЛИТЕРАТУРЫ
1. Калашников А.В., Костенко В.А. Параллельный алгоритм имитации отжига для построения многопро- цессорных расписаний// Изв. РАН. ТиСУ. 2008. № 3. С. 133–142.
2. Калашников А.В., Костенко В.А. Итерационные алгоритмы построения расписаний,
3. основанные на разбиении пространства решений на области // Вестн. МГУ. Сер. 15. Вычислительная математика и кибернетика. 2008. № 3. С. 56–60.
4. Avizienis A., Laprie J.C., Randell B. Dependability and its threats: a taxonomy // Building the Information So- ciety Proc IFIP 18th World Computer Congress. Toulouse, 2004. Р. 91–120.
5. Wattanapongsakorn N., Levitan S.P. Reliability optimization models for embedded systems with multiple appli- cations// IEEE Transactions on Reliability. 2004. V. 53. P. 406–416.
6. Eckhardt D. E., Lee L.D. A theoretical basis for the analysis of multiversion software subject to coincident er- rors// IEEE Transactions on Software Engineering. 1985. V. 11. P. 1511–1517.
7. Laprie J.-C., Arlat J., Beounes C. et al. Definition and analysis of hardware- and software-fault-tolerant archi- tectures// Computer. 1990. V. 23. P. 39–51.
8. Ахо А., Хопкрофт Дж., Ульман Дж. Построение и анализ вычислительных алгоритмов. М.: Мир, 1979. 535 c.
9. Костенко В.А. Задача построения расписания при совместном проектировании аппаратных и про- граммных средств// Программирование. 2002. №3. С.64–80.
10. Ивченко Г.И., Медведев Ю.И. Математическая статистика. М.: Высш. шк., 1984. 248 с.






















ИЗВЕСТИЯ РАН. ТЕОРИЯ И СИСТЕМЫ УПРАВЛЕНИЯ	№ 2	2012	9*