Введение

В этой книге содержатся фундаментальные материалы, связанные с организацией, сортировкой и поиском данных в основной и внешней памяти. Соответствующие знания необходимы программистам всех уровней (от разработчиков простых прикладных программ до создателей сложнейших систем), квалифицированным пользователям программных продуктов, которые хотят хорошо понимать суть происходящего и, конечно, преподавателям разнообразных компьютерных дисциплин и их студентам.

Если обратиться к классической литературе, то можно обнаружить два крайних подхода к представлению материала. Некоторые авторы любят излагать материал на высоком теоретическом уровне. Например, для того, чтобы ввести понятие типа данных и предложить классификацию возможных типов, используются развитые механизмы абстрактной алгебры; при описании алгоритмов в обязательном порядке приводятся асимптотические оценки их сложности. Другой подход состоит в максимальном приближении к практике. Обычно выбирается некоторый конкретный язык программирования, и все описываемые структуры данных и алгоритмы представляются на этом языке.

Автору книги ближе некоторый компромисс. С одной стороны мы стремимся максимально использовать интуицию читателей, не перегружая их массой возможных теоретических сведений. С другой стороны, не хочется привязываться к конкретным языковым средам, оставляя изложение на умеренно абстрактном уровне с возможностью адаптации предлагаемого материала к разным возникающим на практике ситуациям. Кроме того, стремясь сделать книгу достаточно структурированной, мы разделяем аспекты структур данных, поиска и сортировки в основной (оперативной) памяти и соответствующие аспекты данных во внешней памяти. По мнению автора, такое четкое разделение материалов более полезно для их возможного использования.

Книга состоит из пяти основных частей. В первой части обсуждаются типы данных в том смысле, в каком они используются в языках программирования, а также базовые структуры данных в основной памяти - массивы, записи и множества. Затем рассматриваются методы организации динамических структур основной памяти, которые, как правило, основываются на динамическом распределении памяти и использовании указателей. Важным аспектом современных сред программирования является возможность пользователей определять свои собственные типы данных с произвольно сложной внутренней структурой и соответствующим набором операций. Анализируются такие важные вопросы, как инкапсуляция типа, наследование типов и полиморфизм. В заключение первой части рассматриваются типы и структуры данных, применяемые в наиболее распространенных в настоящее время реляционных базах данных и в перспективных объектно-реляционных базах данных. Для последней категории баз данных приводится классификация используемых типов и структур данных и анализируются основные свойства, характерные для каждой группы.

Вторая часть книги посвящена рассмотрению основных методов и алгоритмов, применяемых для сортировки массивов данных в основной памяти. Мы начинаем с наиболее простых и легко реализуемых методов, которые включают сортировку включением, обменную сортировку, сортировку выбором и сортировку слиянием. После этого обсуждаются более быстрые и более сложные алгоритмы: сортировка разделением и сортировка деревом. В заключение части приводится сравнение описанных методов.

В третьей части обсуждаются методы и алгоритмы сортировки последовательностей данных (последовательных файлов), располагаемых во внешней памяти (внешняя сортировка). Опять сначала описываются простые и не очень эффективные алгоритмы внешней сортировки простым слиянием и естественным слиянием, а в конце части рассматриваются более быстрые и сложные алгоритмы сбалансированного многопутевого слияния и многофазной сортировки.

Четвертая часть книги посвящена методам поиска данных в основной памяти и применяемым для этого вспомогательным структурам данных. Все известные (и более или менее эффективные) методы поиска можно разделить на два класса: методы, основанные на использовании деревьев, и методы, базирующиеся на хэшировании. В соответствии с этим разделением часть состоит из двух разделов. В первом разделе рассматриваются наиболее известные методы поиска в основной памяти на основе двоичных деревьев общего вида, сбалансированных (АВЛ) деревьев, деревьев оптимального поиска и деревьях цифрового поиска. Второй раздел посвящен методам хэширования для поиска данных в таблицах основной памяти. В начале раздела обсуждаются алгоритмы совершенного хэширования для поиска в статических таблицах. Далее ставится задача поиска в динамически изменяемых таблицах и возникающая в связи с этим проблема коллизий. В заключение раздела обсуждаются известные методы хэширования с разрешением коллизий: линейное зондирование, двойное хэширование и хэширование с использованием цепочек переполнения.

В завершающей, пятой части, обсуждаются методы поиска данных во внешней памяти и связанные с этим служебные структуры данных. И в этой области наиболее распространены подходы на основе деревьев и на основе хэширования. Кроме того, в последние годы появились некоторые относительно новые методы поиска, обеспечивающие большую скорость поиска в редко изменяемых наборах данных. Поэтому часть включает три раздела: методы поиска во внешней памяти на основе деревьев, методы, основанные на хэшировании и "новые" методы. Первый раздел начинается с введения в классические B-деревья. На практике гораздо чаще используется усовершенствованный механизм B-деревьев, который получил название B+-деревьев. После описания общей структуры B+-дерева достаточно подробно обсуждаются алгоритмы поиска, вставки и удаления. Далее анализируются разновидности B+-деревьев, используемые для организации индексов в базах данных, в частности, методы компрессии. Наконец, в заключение первого раздела рассматривается еще одно развитие технологии B-деревьев - R-деревья, предназначенные для организации поиска в пространственных базах данных. Вторая часть содержит описание методов и алгоритмов поиска данных во внешней памяти на основе хэширования. Обсуждаются два классических метода - расширяемое хэширование и линейное хэширование. Анализируются перспективы применения этих методов для организации индексов в нетрадиционных базах данных. Наконец, в третьем разделе рассматриваются все чаще используемые методы, оптимизирующие и убыстряющие поиск в сверхбольших и не слишком часто изменяемых базах данных: индексы хэширования и индексы на основе битовых шкал.
1. Типы и структуры данных

Типы и структуры данных представляют собой фундамент, на котором строится вся современная технология программирования. Программирования в широком смысле, включая не только непосредственно написание и отладку программ, но и проектирование программных систем разной сложности; проектирование, реализацию и использование баз данных и информационных систем и т.д. Сегодня только большие любители обходятся без использования безтиповых языков программирования (например, языков ассемблера) или неструктурированных и/или нетипизированных хранилищ данных во внешней памяти. В этой части книги, не прибегая к излишним формализмам и теоретическим изыскам, мы приводим систематическое обсуждение основных типов и структур данных, применяемых в современных языках программирования, а также соответствующих концепций, используемых в распространенных реляционных и перспективных объектно-реляционных системах.
1.1. Понятие типа данных

Существует много подходов к определению понятия типа данных от полностью математических, основанных на аппаратах абстрактной алгебры или математической логики, до полностью житейских, ориентированных исключительно на интуицию. Автору книги ближе всего подход, применяемый классиком компьютерной литературы и создателем ряда исключительно стройных и красивых языков программирования Никласом Виртом.

Основным принципом типизации, принятым в языках программирования и базах данных является то, что любая константа, переменная, выражение и функция относится к некоторому типу, характеризующему прежде всего множество значений, к которым относятся константы, которые могут принимать переменные и выражения и которые могут формировать функции. При описании любых используемых констант, переменных и функций явно или неявно указывается их тип. В первую очередь это дает возможность компилятору и/или системе управления базами данных выделить для хранения объекта данных ровно тот объем памяти, который определяется допустимым диапазоном значений типа. Однако концепция типа этим не исчерпывается.

Следующим исключительно важным свойством типа данных является инкапсуляция внутреннего представления его значений. К значению типа данных (значения констант, переменных, выражений и функций) можно обращаться только с помощью операций, предопределенных в описании этого типа. Эти операции могут быть явными (например, арифметические операции "+", "-", "?" и "/" для числовых типов) или неявными (например, операция преобразования значения целого типа к значению плавающего типа; заметим, что в некоторых языках, в частности, в Си и Си++, допускаются и явные преобразования типов).

Наличие типовых описаний констант, переменных и функций и предписанные правила определения типов выражений вместе с поддержкой свойства инкапсуляции типов дают возможность компиляторам языков программирования и языков баз данных производить существенный контроль допустимости языковых конструкций на этапе компиляции, что позволяет сократить число проверок на стадии выполнения программ и облегчить их отладку.

Один из характерных примеров преимущества использования типизированных языков программирования представляет история операционной системы UNIX. Как известно, система первоначально была написана на языке ассемблера PDP-7. При переходе к использованию PDP-11 ОС UNIX была переписана на языке более высокого уровня B, который являлся прямым наследником безтипового языка программирования BCPL. В очень скором времени по мере роста размеров системы ее разработчикам стало понятно, что бесчисленные проверки времени выполнения очень усложняют отладку и замедляют работу системы. Это явилось исходным толчком к внедрению в язык B системы типов и созданию типизированного языка Си, опора на который обеспечила более чем 25-летнюю плодотворную жизнь системы.

Можно приводить различные классификации типов данных, например, простые и составные типы, предопределенные и определяемые типы и т.д. Существенно то, что несмотря на многолетнее использование типов данных в отечественном программировании, так и не сложилась устойчивая и общепринятая русскоязычная терминология. Поэтому в этой книге будем использовать некоторый набор терминов, выбранных из соображений максимальной распространенности и интуитивной ясности.

Выделим следующие категории типов:

    Встроенные типы данных, т.е. типы, предопределенные в языке программирования или языке баз данных. Обычно в языке фиксируются внешнее представление значений этих типов (вид литеральных констант) и набор операций с описанием их семантики. Внутреннее представление и реализация операций выбираются в конкретных компиляторах и подсистемах поддержки выполнения программ.
    Под термином "уточняемый тип данных" мы понимаем возможность определения типа на основе встроенного типа данных, значения которого упорядочены. В частности, к категории уточняемых типов относится тип поддиапазона целых чисел в языках линии Паскаль.
    Категорию перечисляемых типов данных составляют явно определяемые целые типы с конечным числом именованных значений. Это очень простой и легко реализуемый механизм, часто являющийся очень полезным.
    Замечание: использование уточняемых и перечисляемых типов порождает потребность в динамической проверке корректности значений - выхода значения за пределы явно (в случае уточняемых типов) или неявно (в случае перечисляемых типов) диапазона.
    Конструируемые типы (иногда их называют составными) обладают той особенностью, что в языке предопределены средства спецификации таких типов и некоторый набор операций, дающих возможность доступа к компонентам составных значений. Мы обсудим наиболее распространенные разновидности конструируемых типов: типы массивов, записей и множеств, а также различия в понимании этих типов в разных языках.
    Замечание: будучи согласны с переводчиком книги Никласа Вирта Д.Б.Подшиваловым в том, что русские термины "тип массива", "тип записи", "тип множества" и т.д. не совсем соответствуют английским оригиналам "array type", "record type", "set type" и т.д. мы все же не будем использовать рекомендуемые им термины "записной тип", "массивный тип" и "множественный тип", поскольку (a) они тоже не вполне соответствуют оригинальным терминам и (b) ужасно выглядят и произносятся.
    Указательные типы дают возможность работы с типизированными множествами абстрактных адресов переменных, содержащих значения некоторого типа. В сильно типизированных языках (Паскаль, Модула, Ада и т.д.) работа с указателями сильно ограничена. В частности, невозможно получить значение указателя явно определенной переменной и/или применять к известным значениям указателей адресную арифметику. В языках с более слабой типизацией (например, Си/Си++) допускаются практически неограниченные манипуляции указателями.
    Вообще говоря, упоминавшиеся выше уточняемые, перечисляемые и конструируемые типы данных являются типами, определяемыми пользователями. Но эти определения не могут включать спецификацию операций над значениями типов. Допустимые операции либо предопределены, либо наследуются от некоторого определенного ранее или встроенного типа. Под термином "определяемый пользователем тип данных" (ранее был больше распространен термин "абстрактный тип данных", однако мы не будем здесь его использовать, поскольку, на наш взгляд, он не точно отражает смысл понятия) мы будем понимать возможность полного определения нового типа, включая явную или неявную спецификацию множества значений, спецификацию внутреннего представления значений типа и спецификацию набора операций над значениями определяемого типа.

Наконец, под термином "полнотиповая система" мы понимаем систему типов, в которых типы, определяемые пользователем, равноправны с предопределенными типами, т.е. можно, например, определить тип массива с элементами любого определенного типа, можно использовать определяемый пользователем тип на основе любого определенного типа и т.д.
1.2. Встроенные типы данных

Обычно в состав встроенных типов данных включаются такие типы, операции над значениями которых напрямую или, по крайней мере, достаточно эффективно поддерживаются командами компьютеров. В современных компьютерах к таким "машинным" типам относятся целые числа разного размера (от одного до восьми байт), булевские значения (поддерживаемые обычно за счет наличия признаков условной передачи управления) и числа с плавающей точкой одинарной и двойной точности (обычно четыре и восемь байт соответственно). В более ранних компьютерах часто поддерживалась десятичная арифметика с фиксированной точкой (например, в мейнфреймах компании IBM и супер-миникомпьютерах компании Digital), но в настоящее время прямая аппаратная поддержка такой арифметики отсутствует практически во всех распространенных процессорах.

В соответствии с этим, в традиционный набор встроенных типов обычно входят следующие (мы будем говорить про размеры внутреннего представления значений этих типов, хотя в спецификациях языков такая информация, как правило, отсутствует):

Тип CHARACTER (или CHAR) в разных языках - это

    либо набор печатных символов из алфавита, зафиксированного в описании языка (для большинства языков англоязычного происхождения этот алфавит соответствует кодовому набору ASCII);
    либо произвольная комбинация нулей и единиц, размещаемых в одном байте.

В первой интерпретации (свойственной языкам линии Паскаль) для значений типа CHAR определены только операции сравнения в соответствии с принятым алфавитом. Например, при использовании ASCII выполняются соотношения 0 < 1 < ...< 9 < A < B < ...< Z < a < b < ...< z; известно, что если значение переменной x удовлетворяет условию 0 <= x <= 9, то это значение - цифра; если A <= x <= Z, то значение x - прописная буква; если a <= x <= z, то значение x - строчная буква и т.д. При использовании этой интерпретации арифметические операции над символьными значениями не допускаются.

Во второй интерпретации (свойственной языкам линии Си) литеральными константами типа CHAR по-прежнему могут быть печатные символы из принятого в языке алфавита, но возможно использование и числовых констант, задающих желаемое содержимое байта. В этом случае, как правило, над значениями типа CHAR возможно выполнение не только операций сравнения, но и операций целочисленной арифметики.

Наконец, в некоторых языках явно различают тип CHAR как чисто символьный тип и тип сверхмалых целых (TINY INTEGER) как тип целых чисел со значениями, умещающимися в один байт.

В современных компьютерах, как правило, поддерживается целочисленная байтовая арифметика, обеспечивающая как первую, так и вторую интерпретацию типа CHAR.

Тип BOOLEAN в тех языках, где он явно поддерживается, содержит два значения - TRUE (истина) и FALSE (ложь). Несмотря на то, что для хранения значений этого типа теоретически достаточно одного бита, обычно в реализациях переменные этого типа занимают один байт памяти. Для всех типов данных, для которых определены операции сравнения, определены также и правила, по которым эти операции сравнения вырабатывают булевские значения. Над булевскими значениями возможны операции конъюнкции (& или AND), дизъюнкции (| или OR) и отрицания (~ или NOT), определяемые следующими таблицами истинности:

TRUE AND TRUE = TRUE
TRUE AND FALSE = FALSE
FALSE AND TRUE = FALSE
FALSE AND FALSE = FALSE

TRUE OR TRUE = TRUE
TRUE OR FALSE = TRUE
FALSE OR TRUE = TRUE
FALSE OR FALSE = FALSE

NOT FALSE = TRUE
NOT TRUE = FALSE

При работе с булевскими значениями в языках баз данных некоторую проблему вызывает то, что по причине возможности хранения в базе данных неопределенных значений операции сравнения могут вырабатывать не два, а три логических значения: TRUE, FALSE и UNKNOWN. Поэтому в языке SQL-92, например, используется не двухзначная, а трехзначная логика, в результате чего логические операции при их обработке в серверах баз данных определяются расширенными таблицами (мы приводим их с учетом коммутативности двуместных операций):


TRUE AND TRUE = TRUE
TRUE AND FALSE = FALSE
TRUE AND UNKNOWN = UNKNOWN
FALSE AND UNKNOWN = FALSE

TRUE OR TRUE = TRUE
TRUE OR FALSE = TRUE
TRUE OR UNKNOWN = TRUE
FALSE OR UNKNOWN = UNKNOWN

NOT FALSE = TRUE
NOT TRUE = FALSE
NOT UNKNOWN = UNKNOWN

Помимо общего возрастания сложности и недостаточной удовлетворительности трехзначной логики для целей работы с базами данных, неприятность состоит в отсутствии поддержки этой логики в языках программирования (как, впрочем, и в отсутствии явной поддержки неопределенных значений).

В языках линии Си прямая поддержка булевского типа данных отсутствует, но имеется логическая интерпретация значений целых типов. Значением операции сравнения может быть "0" (FALSE) или "1" (TRUE). Значение целого типа "0" интерпретируется как FALSE, а значения, отличные от нуля, - как TRUE. В остальном все работает как в случае наличия явной поддержки булевского типа.

Тип целых чисел в общем случае включает подмножество целых чисел, определяемое числом разрядов, которое используется для внутреннего представления значений. При определении типа целых чисел обычно стремятся к тому, чтобы множество его значений было симметрично относительно нуля (собственно, это стимулируется и стандартными свойствами машинной целочисленной арифметики). Поэтому приходится тратить один бит на значение знака числа и при использовании n бит для внутреннего представления целого соответствующий тип содержит значения в диапазоне от -2(n-1) до 2(n-1). В подавляющем большинстве современных процессоров отрицательные целые числа обычно представляют в дополнительном коде.

В языках, ориентированных на 32-разрядные компьютеры, в частности, в стандартных Си и Си++ для рационального использования памяти допускаются модификации целого типа short integer (обычно 16-разрядные), integer (обычно то же самое, что и long integer) и long integer (обычно 32-разрядные), а также байтовые целые (char). При этом поддерживаются автоматические преобразования значений типов меньшего размера к значениям типов большего размера. Пока не очень понятно, какие встроенные целые типы будут зафиксированы в будущем "64-разрядном" стандарте языка Си, но многие компании считают разумным использовать модель под названием LP64, в которой предполагается размер char - 8 бит, размер short integer - 16 бит, размер integer - 32 бита и размер long integer и long long integer - 64 бита.

Наряду со знаковыми целыми типами в языках часто поддерживаются беззнаковые целые. Такие типы в линии языков Паскаль называются CARDINAL, а в линии языков Си именуются путем добавления модификатора unsigned к названию соответствующего целого типа. Таким образом, в последнем случае существуют типы unsigned char, unsigned short integer, unsigned integer и unsigned long integer. Поскольку множество значений типа unsigned в два раза мощнее множества значений соответствующего целого типа, то поддерживается их автоматическое преобразование только к целым типам большего размера.

Наконец, для поддержки численных вычислений в языках обычно специфицируется встроенный тип чисел с плавающей точкой с базовым названием REAL или FLOAT. Обычно в описании языков не фиксируется диапазон и точность значений такого типа. Они уточняются в реализации и обычно существенно зависят от особенностей целевого процессора. В языках семейства Си (32-разрядных) специфицированы три разновидности типа чисел с плавающей точкой - float (обычно с размером 16 бит), double float (размером в 32 бит) и long double float (размером 64 бит).
1.3. Уточняемые типы данных

Никлас Вирт называет такие типы ограниченными (restricted). На самом деле, ни этот термин, ни тот, который употребляем мы в этой книге, не являются абсолютно правильно отражающими суть соответствующего механизма. Все же, по нашему мнению, термин "уточняемый тип" немного ближе по смыслу.

Суть состоит в том, что для любого значения любого встроенного (и перечисляемого) типа существует его внешнее литеральное представление. Более того, по литеральному представлению константы можно однозначно определить тип, к которому она относится. Если к тому же на множестве значений типа задано отношение порядка (определены операции сравнения), то иногда возникает потребность сказать, что в данном приложении нас интересует подмножество значений такого типа, ограниченное некоторым специфицированным диапазоном. По причине наличия упорядоченности значений такой диапазон может быть задан парой литеральных констант базового типа c1 и c2, удовлетворяющих условию c1 <= c2. Тем самым, определение нового уточненного типа может иметь вид (пример из языка Модула-2): TYPE T = [c1..c2].

Почему мы предпочитаем использовать термин "уточняемый тип"? Основная причина состоит в том, что "ограниченные типы" в том смысле, в котором они используются в языках линии Паскаль, являются частным случаем более общего понятия, используемого в языках баз данных и именуемого "доменом". При определении домена тоже накладывается некоторое ограничение на значения базового типа, но это ограничение может выражаться в виде произвольного логического выражения, а не только с помощью указания диапазона. То есть мы действительно уточняем характеристики базового типа.

Основной проблемой уточняемых типов является потребность в динамическом контроле значений, формируемых при вычислении выражений и возвращаемых функциями. Если для значений базовых типов (по крайней мере, числовых) такой контроль, как правило, поддерживается аппаратурой компьютера, то для уточняемых типов, вообще говоря, требуется программный контроль, вызывающий серьезные накладные расходы. В развитых компиляторах обычно поддерживаются два режима компиляции - отладочный со всеми возможными контролирующими действиями во время выполнения программы и "боевой", в котором контроль отключается. Однако, если учесть, что в любой серьезной программе ошибки сохраняются на протяжении всей ее жизни, бесконтрольное выполнение программ очень затрудняет нахождение таких ошибок.
1.4. Перечисляемые типы данных

Перечисляемый тип состоит из конечного числа упорядоченных именованных значений. В классическом варианте, свойственном, например, языкам линии Паскаль, определение типа состоит из перечисления имен значений (поэтому справедливо называть такой тип перечисляемым), эти имена в дальнейшем играют роль имен литеральных констант этого типа и должны отличаться от литерального изображения констант любого другого типа. Поскольку значения типа задаются путем перечисления, каждому значению можно однозначно сопоставить натуральное число от 1 до n, где n - число значений перечисляемого типа.

Обычно для любого перечисляемого типа предопределяются операции получения значения по его номеру и получения номера по значению. Кроме того, для перечисляемого типа предопределяются операции сравнения и получения следующего и предыдущего значения. По причине однозначного сопоставления значению перечисляемого типа натурального числа, возможно неявное преобразование этих значений к значению любого числового типа данных.

В языках линии Си под тем же термином "перечисляемый тип" понимается нечто другое, поскольку при определении такого типа можно явно сопоставить имени значения некоторое целое (не обязательно положительное) число; при отсутствии явного задания целого первому элементу перечисляемого типа неявно соответствует 0, а каждому следующему - целое значение, на единицу большее целого значения предыдущего элемента. При этом (a) использование имени перечисляемого типа для объявления переменной эквивалентно использованию типа integer, и такая переменная может содержать любое целое значение; (b) имена значений перечисляемого типа на самом деле понимаются как имена целых констант, и к этим значениям применимы все операции над целыми числами, даже если они выводят за пределы множества целых значений элементов перечисляемого типа. Так что перечисляемый тип в смысле языка Си - это не совсем тип в строгом смысле этого слова, а скорее удобное задание группы именованных констант целого типа.
1.5. Конструируемые типы данных

Мы переходим к рассмотрению группы разновидностей типов данных, которые в литературе часто называют "составными", поскольку любое значение любого из этих типов состоит из значений одного или нескольких других типов. Мы предпочитаем использовать термин "конструируемый тип", поскольку для каждой разновидности типов этой группы в языке программирования специфицируются средства построения (конструирования) нового типа на основе встроенных и/или ранее определенных типов, и для каждой разновидности предопределяются операции, позволяющие извлечь компонент составного значения. К наиболее распространенным конструируемым типам относятся тип массива, тип записи и тип множества.
1.5.1. Массивы

Как и в ряде предыдущих разделов, понятия массива и типа массива сильно различаются в сильно и слабо типизированных языках. Начнем с классического понятия в сильно типизированных языках (например, в языке Паскаль). Тип массива в таких языках определяется на основе двух вспомогательных типов: типа элементов массива (базового типа) и типа индекса массива. В языке Паскаль определение типа массива выглядит следующим образом: type T = array [I] of T0, где T0 - базовый тип, а I - тип индекса. T0 может быть любым встроенным или ранее определенным типом. Тип индекса I должен состоять из конечного числа перечисляемых значений, т.е. быть уточненным, перечисляемым, символьным или булевским типом. В языках линии Паскаль допускается и неявное определение уточненного типа массива. Например, допустимы следующие определения типа массива: type T = array [1..6] of integer или type T = array ['a'..'e'] of real.

Если мощность множества значений типа индекса есть n, то значение типа массива - это регулярная структура, включающая n элементов базового типа. Соответствующим образом устроены и переменные типа массива. Для любого сконструированного типа массива предопределены две операции - операция конструирования значения типа массива и операция выборки элемента массива. Если x - переменная типа массива T, а i - значение соответствующего типа индекса, то для конструирования значения используется языковое средство x:= T (c1, c2, ..., cn), где c1, c2, ..., cn - значения базового типа. Для выборки элемента массива используется конструкция x[i], значением которой является значение i-того элемента массива (вместо i в квадратных скобках может содержаться любое допустимое выражение, значение которого принадлежит множеству значений типа индекса). Эта же конструкция может использоваться в левой части оператора присваивания, т.е. элементы массива могут изменяться индивидуально. Кроме того, при подобной строгой типизации массивов допустимы присваивания значений переменных типа массива, функции, возвращающие значение типа массива и т.п.

Базовым типом типа массива может быть любой встроенный или определенный тип, в том числе и тип массива. В последнем случае говорят о многомерных массивах или матрицах. Для работы с многомерными массивами в языках используют сокращенную запись. Например, вместо определения type T = array [1..10] of array [1..5] of real можно написать type T = array [1..10],[1..5] of real, а если x - переменная такого типа T, то для выборки скалярного элемента вместо x[i][j] можно написать x[i,j].

В сильно типизированных языках для любого значения типа массива известно число элементов базового типа. Поэтому в принципе всегда возможен контроль значения индекса, хотя на практике такой контроль обычно отменяется при использовании программы в производственном режиме.

Для иллюстрации приемов работы с массивами в слабо типизированных языках используем язык Си. В этом языке нет средств определения типов массива, хотя имеется возможность определения "массивных переменных". Число элементов в массивной переменной определяется либо явно, либо с помощью задания списка инициализирующих значений базового типа. Например, массивную переменную с четырьмя элементами целого типа можно определить как int x[4] (неинициализированный вариант) или как int x[] = { 0, 2, 8, 22} (инициализированная массивная переменная). Доступ к элементам массивной переменной производится с помощью конструкции выбора, по виду аналогичной соответствующей конструкции в сильно типизированных языках x[i], где i - выражение, принимающее целое значение (мы специально отметили внешний характер аналогии, поскольку в отличие от языка Паскаль в языке Си зафиксирована интерпретация операции выбора на основе более примитивных операций адресной арифметики). Однако, по причинам, которые мы обсудим в разделе, посвященном указателям, в реализациях языка Си в принципе невозможен контроль выхода значения индекса за пределы массива. Кроме того, по аналогичным причинам невозможно присваивание значений массивных переменных и не допускаются функции, вырабатывающие "массивные значения".
1.5.2. Записи

Типы массивов позволяют работать с регулярными структурами данных, каждый элемент которых относится к одному и тому же базовому типу. Существует другая разновидность составных конструируемых типов данных, которые позволяют определять и использовать нерегулярные структуры данных, элементы которых могут относиться к разным встроенным или явно определенным типам данных. Собирательно типы этой разновидности называются типами записи или структурными типами.

К счастью, общее понятие типа записи практически одинаково в сильно и слабо типизированных языках (с некоторыми оговорками, которые мы отложим до раздела, посвященного указателям). Идея состоит в том, что в определении структурного типа перечисляются имена полей записи, и для каждого поля указывается его тип данных. После этого можно определять переменные вновь сконструированного типа и производить доступ к полям переменных. На языке Модула-2 определение структурного типа "комплексные числа" могло бы выглядеть следующим образом:

type complex = record re: real;
                      im: real
               end

Вот аналог этого определения на языке Си:

struct complex { float re;
                 float im;
               }

После этого можно объявить переменную x комплексного типа (var x: complex; или struct complex x;) и обращаться к действительной и мнимой частям x с помощью конструкции x.re (или x.im соответственно). Поскольку размер составного значения структурного типа точно специфицирован, допускается присваивание таких значений, а также функции, вырабатывающие структурные значения и т.п.

Замечание: мы все же вынуждены отметить одну (не связанную с указателями) особенность использования структурных типов в языках линии Си, отражающую, на наш взгляд, слабость типизации. Кроме корректного с точки зрения типизации отдельного определения именованного структурного типа с использованием затем этого имени при объявлении переменных, можно определять безымянный структурный тип с одновременным объявлением переменных. Например, в языке Си допустимы следующие объявления переменных x, y и z:

struct { float re;
         float im;
       } x, y;

struct { float r;
         float i;
       } z;

После этих объявлений понятно, что переменные x и y имеют один и тот же тип и что, в частности, допустимо присваивание x = y. Но чтобы понять, что на самом деле таким же типом обладает и переменная z, приходится решать громоздкую задачу определения структурной эквивалентности типов, возникновения которой обычно стремятся избежать в сильно типизированных языках программирования.
1.5.3. Записи с вариантами

Можно очень коротко охарактеризовать основные возможности, которые обеспечивает механизм записей. Главное - это то, что в одной именованной области памяти можно хранить совокупность разнотипных именованных полей, причем имена этих полей специфицируются один раз при определении структурного типа данных. Понятно, что без записей можно обойтись, но с их использованием удобнее и экономичнее программировать.

Идея, которую мы обсудим в этом разделе, тоже в основном относится к повышению уровня удобств программирования. При реальном программировании достаточно часто возникает желание по-разному интерпретировать содержимое одной и той же области памяти в зависимости от конкретных обстоятельств. Хорошим стилем является использование каждой структурной переменной с некоторым объектом предметной области, к которой относится программа. Поля структуры в этом случае содержат требуемые характеристики объекта. Но любой объект может менять свое состояние и соответственно набор характеристик. Поэтому удобно, продолжая использовать ту же область памяти, иметь возможность понимать ее структуру и содержание таким образом, который согласуется с текущим состоянием объекта.

Понятно, что для того, чтобы получить такую возможность, нужно несколько расширить средства определения структурного типа, введя вариантность соответствующей структуры. Нужно уметь специфицировать все возможные варианты структурной и типовой интерпретации переменных и значений типа записи. Естественно, что любая такая переменная, вне зависимости от ее конкретной интерпретации, будет занимать один и тот же объем памяти, определяемый "максимальным" по размеру вариантом.

Наиболее строгое решение содержится в языках линии Паскаль. В определении всего структурного типа или его завершающей части можно явно указать специальное поле перечисляемого типа (дискриминант), значения которого являются метками соответствующих вариантов типа записи. Для корректного использования переменных такого типа требуется заносить в поле дискриминанта актуальное значение при изменении интерпретации переменной и руководствоваться значением дискриминанта при доступе к содержимому переменной. Вот пример определения типа записи с вариантами в языке Паскаль:

type person = record lname, fname: alfa;
                     birthday: date;
                     marstatus: (single, married);
                case sex: (male, female) of
                male: (weight: real;
                       bearded: boolean);
                female: (size: array[1..3] of integer)
               end

(Считается, что типы данных alfa и date уже определены.) После определения переменной типа person в любой момент можно обращаться и к полям weight и bearded, и к элементам массива size, но корректно это следует делать, руководствуясь значением дискриминанта sex.

Более слабый, но эквивалентный по возможностям механизм поддерживается в языках семейства Си. В этих языках существует специальная разновидность типов данных, называемая смесью (union). Фактически, смесь - это запись с вариантами, но без явно поддерживаемого дискриминанта. По нашему мнению, решение о применении такого "облегченного" механизма было принято потому, что использование явно задаваемого дискриминанта в языках линии Паскаль все равно является необязательным, а раз так, то при желании можно просто включить дополнительное поле, значение которого будет характеризовать применимый вариант. Приведенный выше пример можно было бы переписать на языке Си следующим образом:

struct person { char lname[10], fname[10];
                     integer birthday;
                     enum { single, married } marstatus;
                     enum { male, female } sex;
                union {
                       struct { float weight;
                                integer bearded } male;
                       integer female[3];
                       } pers;
                }

1.5.4. Множества

Еще одной разновидностью конструируемых типов являются типы множеств. Такие типы поддерживаются только в развитых сильно типизированных языках. В языке Паскаль тип множества определяется конструкцией type T = set of T0, где T0 - встроенный или ранее определенный тип данных (базовый тип). Значениями переменных типа T являются множества элементов типа T0 (в частности, пустые множества).

Для любого типа множества определены следующие операции: "?" - пересечение множеств, "+" - объединение множеств, "-" - вычитание множеств и "in" - проверка принадлежности к множеству элемента базового типа.

С использованием механизма множеств можно писать лаконичные и красивые программы, но нужно отдавать себе отчет в том, что для эффективной реализации множеств требуются серьезные ограничения их мощности. Обычно в реализациях языков допускаются множества, мощность базового типа которых не превосходит длину машинного слова. Это связано с тем, что перечисленные выше операции допускают эффективную реализацию только в том случае, когда значение множества представляется битовой шкалой, длина которой равна мощности базового типа. "1" означает, что соответствующий элемент базового типа входит в множество, "0" - не входит. Чтобы для выполнения операций над множествами можно было прямо использовать машинные команды, нужно ограничить длину шкалы машинным словом.
1.6. Указатели

Понятие указателя в языках программирования является абстракцией понятия машинного адреса. Подобно тому, как зная машинный адрес можно обратиться к нужному элементу памяти, имея значение указателя, можно обратиться к соответствующей переменной. Различие между механизмами указателей в разных языках состоит главным образом в том, откуда берется значение указателя. Чем больше возможностей по работе с указателями, тем более эффективную программу можно написать и тем "опаснее" становится программирование. Обычно возможности оперирования указателями ограничиваются по мере повышения уровня языка и усиления его типизации.

В любом случае для объявления указательных переменных служат так называемые указательные, или ссылочные типы. Для определения указательного типа, значениями которого являются указатели на переменные встроенного или ранее определенного типа T0, в языке Паскаль используется конструкция type T = ­T0. В языке Си отсутствуют отдельные возможности определения указательного типа, и, чтобы объявить переменную var, которая будет содержать указатели на переменные типа T0, используется конструкция T0 *var. Но конечно, это чисто поверхностное отличие, а суть гораздо глубже.

В языках линии Паскаль переменной указательного типа можно присваивать только значения, вырабатываемые встроенной процедурой динамического выделения памяти new, значения переменных того же самого указательного типа и специальное "пустое" ссылочное значение nil, которое входит в любой указательный тип. Не допускаются преобразования типов указателей и какие-либо арифметические действия над их значениями. С переменной-указателем var можно выполнять только операцию var­, обеспечивающую доступ к значению переменной типа T0, на которую указывает значение переменной var.

Напротив, в языках Си и Си++ имеется полная свобода работы с указателями. С помощью операции "&" можно получить значение указателя для любой переменной, над указателями определены арифметические действия, возможно явное преобразование указательных типов и даже преобразование целых типов к указательным типам. В этих языках не фиксируется значение "пустых" (ни на что не ссылающихся) указательных переменных. Имеется лишь рекомендация использовать в качестве такого значения константу с символическим именем NULL, определяемую в библиотечном файле включения. По сути дела, понятие указателя в этих языках очень близко к понятию машинного адреса.

Отмеченные свойства механизма указателей существенно повлияли на особенности реализации в языках Си и Си++ работы с массивами. Имя массива в этих языках интерпретируется как имя константного указателя на первый элемент массива. Операция доступа к i-тому элементу массива arr хотя и обозначается как и в языках линии Паскаль arr[i], имеет низкоуровневую интерпретацию *(arr+i). Поэтому было логично допустить подобную запись для любой переменной var с указательным типом: var[i] интерпретируется как *(var+i). По этой причине понятие массива в Си/Си++ существенно отличается от соответствующего понятия в Паскале. Размер массива существенен только при его определении и используется для выделения соответствующего объема памяти. При работе программы используется только имя массива как константный указатель соответствующего типа. Нет операций над "массивными переменными" целиком; в частности, невозможно присваивание. Фактически отсутствует поддержка массивов как параметров вызова функций - передаются именно значения указателей (в связи с этим, при описании формального параметра-массива его размер не указывается). Функции не могут вырабатывать "массивные" значения.

Как отмечалось выше, особенности работы с указателями в некоторой степени повлияли и на организацию структур. Хотя в описаниях языков Си и Си++ и рекомендациях по программированию присутствует настоятельный совет обращаться к полям структурных переменныхтолько по их именам, известно, что каждое имя на самом деле интерпретируется как смещение от начала структуры. Поэтому, имея значение указателя на начало структурной переменной и манипулируя известными длинами полей структуры, технически можно добраться до любого поля, не используя его имя.

Подводя итоги этого краткого обсуждения механизма указателей в Си/Си++, заметим, что позволяя программировать с очень большой эффективностью, этот механизм делает языки очень опасными для использования и требует от программистов большой аккуратности и сдержанности. При разработке получающего все большее распространение языка Java (одним из основных предков которого был Си++) для повышения уровня безопасности были резко ограничены именно средства работы с указателями в языке Си++.
1.7. Динамическое распределение памяти и списки

При решении ряда задач становится неудобно, неэффективно, а иногда и просто невозможно обойтись использованием памяти, выделяемой компилятором и системой поддержки времени выполнения в соответствии с явными описаниями переменных в программе. Во всех языках, более или менее приспособленных к практическому применению, имеется возможность явно запрашивать и использовать области так называемой динамической памяти. Такие области принято называть "динамическими переменными". Возможности создания и использования динамических переменных тесно связаны с механизмами указателей, поскольку динамическая переменная не имеет статически заданного имени, и доступ к такой переменной возможен только через указатель.

Как и во многих обсуждавшихся ранее случаях, механизмы работы с динамической памятью в языках с сильной типизацией существенно отличаются от соответствующих механизмов языков со слабой типизацией. В языках линии Паскаль для запроса динамических переменных используется встроенная процедура new(var), где var - переменная некоторого ссылочного типа T. Если тип T определялся конструкцией type T = ­T0, то при выполнении этой процедуры подсистема поддержки времени выполнения выделяет динамическую область памяти с размером, достаточным для размещения переменных типа T0, и переменной var присваивается ссылочное значение, обеспечивающее доступ к выделенной динамической переменной.

Понятно, что размеры области памяти, используемой для динамического выделения переменных, в любой реализации языка ограничены. Кроме того, обычно время полезного существования динамической переменной меньше времени выполнения программы, в которой эта переменная была создана. Поэтому наряду со средствами образования динамических переменных должны существовать средства освобождения памяти, занятой ставшими бесполезными динамическими переменными. В сильно типизированных языках для этого применяются два разных механизма.

Первый - это явное использование встроенной процедуры dispose(var), где var - переменная ссылочного типа, значение которой указывает на ранее выделенную и еще не освобожденную динамическую переменную. Строго говоря, при выполнении процедуры dispose должно быть не только произведено действие по освобождению памяти, но также переменной var и всем переменным того же ссылочного типа с тем же значением должно быть присвоено значение nil. Это гарантировало бы, что после вызова dispose в программе были бы невозможны некорректные обращения к освобожденной области памяти. К сожалению, обычно из соображений эффективности такая глобальная очистка не производится, и программирование с использованием динамической памяти становится достаточно опасным.

Второй механизм, обеспечивающий более безопасное программирование, состоит в том, что подсистема поддержки времени выполнения хранит ссылки на все выделенные динамические переменные и время от времени (обычно, когда объем свободной динамической памяти достигает некоторого нижнего предела) автоматически запускает процедуру "сборки мусора". Процедура просматривает содержимое всех существующих к этому моменту ссылочных переменных, и если оказывается что некоторые ссылки не являются значением ни одной ссылочной переменной, освобождает соответствующие области динамической памяти. Заметим, что это является возможным в силу наличия строгой типизации ссылочных переменных и отсутствия явных или неявных преобразований их типов.

Работа с динамической памятью в языках Си/Си++ гораздо проще и опаснее. Правильнее сказать, что в самих языках средства динамического выделения и освобождения памяти вообще отсутствуют. При программировании на языке Си для этих целей используются несколько функций из стандартной библиотеки stdlib, специфицированной в стандарте ANSI C. При реализации языка Си в среде ОС UNIX используются соответствующие функции из системной библиотеки stdlib.

Базовой функцией для выделения памяти является malloc(), входным параметром которой является размер требуемой области динамической памяти в байтах, а выходным - значение типа *void, указывающее на первый байт выделенной области. Гарантируется, что размер выделенной области будет не меньше запрашиваемого и что область будет выравнена так, чтобы в ней можно было корректно разместить значение любого типа данных. Тем самым, чтобы использовать значение, возвращаемое функцией malloc(), необходимо явно преобразовать его тип к нужному указательному типу.

Для освобождения ранее выделенной области динамической памяти используется функция free(). Ее входным параметром является значение типа *void, которое должно указывать на начало ранее выделенной динамической области. Поведение программы непредсказуемо при использовании указателей на ранее освобожденную память и при задании в качестве параметра функции free() некорректного значения.

Заметим, что по причине наличия возможности получить значение указателя на любую статически объявленную переменную, работа с указателями на статические и динамические переменные производится полностью единообразно. Единообразная работа с массивами и указателями естественным образом позволяет создавать и использовать динамические массивы.

Как видно, с динамической памятью в языках Си/Си++ работать можно очень эффективно, но программирование является опасным.

Используя структурные типы, указатели и динамические переменные, можно создавать разнообразные динамические структуры памяти - списки, деревья, графы и т.д. (Особенности указателей в языках Си/Си++ позволяют, вообще говоря, строить динамические структуры памяти на основе статически объявленных переменных или на смеси статических и динамических переменных.) Идея организации всех динамических структур одна и та же. Определяется некоторый структурный тип T, одно или несколько полей которого объявлены указателями на тот же или некоторый другой структурный тип. В программе объявляется переменная var типа T (или переменная типа указателя на T в случае полностью динамического создания структуры). Имя этой переменной при выполнении программы используется как имя "корня" динамической структуры. При выполнении программы по мере построения динамической структуры запрашиваются динамические переменные соответствующих типов и связываются ссылками, начиная с переменной var (или первой динамической переменной, указатель на которую содержится в переменной var). Понятно, что этот подход позволяет создать динамическую структуру с любой топологией.

Наиболее простой динамической структурой является однонаправленный список (рисунок 1.1). Для создания списка определяется структурный тип T, у которого имеется одно поле next, объявленное как указатель на T. Другие поля структуры содержат информацию, характеризующую элемент списка. При образовании первого элемента ("корня") списка в поле next заносится пустой указатель (nil или NULL). При дальнейшем построении списка это значение будет присутствовать в последнем элементе списка

Рис. 1.1.

Над списком, построенном в такой манере, можно выполнять операции поиска элемента, удаления элемента и занесение нового элемента в начало, конец или середину списка. Понятно, что все эти операции будут выполняться путем манипуляций над содержимым поля next существующих элементов списка. Для оптимизации операций над списком иногда создают вспомогательную переменную-структуру (заголовок списка), состоящую из двух полей - указателей на первый и последний элементы списка (рисунок 1.2). Для этих же целей создают двунаправленные списки, элементы которых, помимо поля next, включают поле previous, содержащее указатель на предыдущий элемент списка (рисунок 1.3) и, возможно, ссылки на заголовок списка (рисунок 1.4).

Рис. 1.2.

Рис. 1.3.

Рис. 1.4.
1.8. Абстрактные (определяемые пользователями) типы данных

На самом деле, оба термина, употребленные в названии раздела, плохо отражают суть соответствующего понятия. Термин "абстрактные типы" плох тем, что реально ничего абстрактного в этой категории типов нет. Термин "определяемые пользователями типы" не точно отражает специфику, поскольку все типы, обсуждавшиеся выше, кроме встроенных в языки программирования, так или иначе определяются пользователями. Тем не менее, в силу привычки, мы будем использовать в этом разделе словосочетание "абстрактные типы данных" (АТД).

Не обращая больше внимания на ущербность терминологии, займемся содержанием понятия АТД. Как мы видели, наличие перечисляемых, уточняемых и конструируемых типов данных в сочетании со средствами выделения динамической памяти позволяет конструировать и использовать структуры данных, достаточные для создания произвольно сложных программ. Ограниченность этих средств состоит в том, что при определении типов и создании структур невозможно зафиксировать правила их использования. Например, если определен структурный тип с полями salary, commissions и total в предположении, что для любой переменной этого типа поле total всегда будет содержать общую сумму выплат, то ничто не мешает по ошибке нарушить это условие (с точки зрения компилятора никакой ошибки нет) и получить неверные результаты работы программы.

Основной идеей АТД является то, что при его определении специфицируется не только структура значений типа, но и набор допустимых операций над переменными и значениями этого типа. В наиболее сильном случае доступ к внутренней структуре типа доступен только через его операции. В число операций обязаны входить один или несколько конструкторов значений типа.

Имеется много разновидностей языков с АТД, языковые средства которых весьма различаются. Кроме того, к этому семейству языков примыкают языки объектно-ориентированного программирования. По поводу них одни авторы (к числу которых относится и автор этой книги) полагают, что для них термин "язык объектно-ориентированного программирования" является модной заменой старого термина "язык с АТД". Другие находят между этими языковыми семействами много тонких отличий, часть которых считают серьезными. Мы не будем глубоко анализировать эти дискуссии, а обсудим некоторые базовые концепции, общие для обоих семейств.
1.8.1. Представление типа

При программировании с использованием АТД возможны три подхода (они могут быть смешаны): (1) перед началом написания основной программы полностью определить все требуемые типы данных; (2) определить только те характеристики АТД, которые требуются для написания программы и проверки ее синтаксической корректности; (3) воспользоваться готовыми библиотечными определениями. В каждом из этих подходов имеются свои достоинства и недостатки, но их объединяет то, что при написании программы известны по меньшей мере внешние характеристики всех типов данных. В некотором смысле это означает, что расширен язык программирования.

Подобная внешняя характеристика АТД называется его представлением или спецификацией. Представление включает имя АТД и набор спецификаций доступных пользователю операций со значениями этого типа. Со своей стороны, спецификация операции состоит из имени и типов параметров (в последнее время такие спецификации принято называть сигнатурами операций). Для однозначного определения компилятором того, какая реально функция или процедура должна быть вызвана при обращении к операции, обычно требуют, чтобы сигнатуры всех операций всех АТД, используемых в программе, были различны (мы еще вернемся к этой теме ниже при обсуждении возможностей полиморфизма).

Переменные, используемые для внутреннего представления значений типа называются переменными состояния, а их совокупность состоянием значений.

Иногда исходя из соображений эффективности допускается прямой доступ к некоторым переменным состояния значений типа (путем использования обычных предопределенных операций чтения и записи). В этом случае переменные состояния, доступные в таком режиме, также специфицируются во внешнем представлении типа.
1.8.2. Реализация типа

Реализация типа представляет собой многовходовой программный модуль, точки входа которого соответствуют набору операций реализуемого типа. Естественно, должно иметься полное соответствие реализации типа его спецификации. Набор статических переменных (в смысле языков Си/Си++) этого модуля образует структуру данных, используемую для представления значений типа. Такой же структурой обладает любая переменная данного абстрактного типа.

Иногда для целей реализации типа бывает полезно иметь в составе его операций такие, которые недоступны для внешнего использования и носят служебный характер. Такие функции и/или процедуры специальным образом помечаются в реализации типа (например, как приватные), и их сигнатуры не включаются во внешнюю спецификацию типа. Переменные состояния, которые должны быть прямо доступны для внешнего использования, также помечаются специальным образом.
1.8.3. Инкапсуляция

Существуют разные точки зрения относительно того, для чего наиболее полезно применять абстрактные типы данных. Многие считают, например, что основной смысл этого подхода состоит в развитии методов модульного структурного программирования. Это, конечно, верно, но с точки зрения автора наибольшее преимущество подхода абстрактных типов данных состоит в принципиальном разделении спецификации и реализации типа. Для правильного написания (а иногда и отладки) программы достаточно иметь набор спецификаций требуемых типов. Для каждой спецификации, вообще говоря, может существовать несколько реализаций, и при их корректном создании эти реализации могут быть взаимозаменяемыми.

В строго типизированных языках с абстрактными типами данных спецификация типа скрывает его реализацию. Внешнее представление типа инкапсулирует особенности его структурной и операционной реализации. До сих пор продолжаются споры о том, что является идеальной инкапсуляцией типа. В частности, многие полагают, что разрешение прямого доступа к переменным состояния нарушает принципы инкапсуляции. По всей видимости, это неверно. Если все возможные операции со значениями типа строго специфицированы в его внешнем представлении, то в любом случае могут допускаться различные реализации типа. Но, естественно, чем более высоким уровнем обладает спецификация, тем больше свобода при выборе реализации.