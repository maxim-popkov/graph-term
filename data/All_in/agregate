Коваленко Д.С., Костенко В.А., Щербинин В.В. Параметрическое семейство алгоритмов распознавания нелинейно искаженных фазовых траекторий динамических систем // XIV Всероссийская научно-техническая конференция "Нейроинформатика-2012". Сборник научных трудов. - М.: НИЯУ МИФИ, 2012. - Ч.1 – С.266-276.

Д.С. КОВАЛЕНКО, В.А. КОСТЕНКО, В.В. ЩЕРБИНИН
МГУ им. М.В. Ломоносова
victorshch@gmail.com

ПАРАМЕТРИЧЕСКОЕ СЕМЕЙСТВО АЛГОРИТМОВ РАСПОЗНАВАНИЯ НЕЛИНЕЙНО ИСКАЖЕННЫХ ФАЗОВЫХ ТРАЕКТОРИЙ ДИНАМИЧЕСКИХ СИСТЕМ

Рассматривается задача построения по обучающей выборке алгоритмов распознавания участков нештатного поведения динамических систем в фазовых траекториях системы. Участки нештатного поведения системы могут быть нелинейно искажены по амплитуде и по времени друг относительно друга в различных условиях работы системы. Предложены параметрическое семейство алгоритмов распознавания и метод построения алгоритмов распознавания, обладающих большей устойчивостью к искажениям фазовых траекторий по сравнению с известными методами.

Ключевые слова: задача обучения по прецедентам, алгоритм распо­знавания, обучающая выборка, алгоритм обучения, динамическая си­стема, алгебраический подход к задаче выделения трендов.

Введение
Рассматриваются системы, информация о поведении которых доступна в виде фазовых траекторий, в пространстве показаний датчиков системы. Время рассматривается дискретное, датчики опрашиваются с некоторой фиксированной частотой . Фазовая траектория  в пространстве показаний датчиков представляет собой набор последовательных измерений показаний датчиков системы: , где:  – это точка в многомерном фазовом пространстве показаний датчиков.
Состояние системы характеризуется точкой фазовой траектории. Со временем система изменяет свое состояние, последовательные изменения состояния системы будем называть ее поведением. Существует три типа  состояний системы: 
штатное состояние, при котором система стабильно выполняет заложенные в нее функции;
нештатное состояние, при котором система в скором времени гарантированно перестанет выполнять заложенные в нее функции;
аварийное состояние, при котором система не выполняет заложенных в нее функций.
Нормальным поведением системы будем называть такое поведение, при котором все состояния, которые принимает система, являются штатными. Нештатным поведением системы будем называть такое, при котором все состояния, которые принимает система, являются нештатными. Считаем, что каждому аварийному состоянию системы предшествует нештатное поведение. Может существовать несколько классов нештатного поведения, которые соответствуют различными неисправностями, приводящих к аварийному состоянию системы. 
Будем считать, что для каждого класса нештатного поведения существует некоторая характерная фазовая траектория , такие траектории будем называть эталонными. Пусть число классов нештатного поведения системы равно . Пусть  – множество ответов, где  соответствует штатному поведению системы,  соответствует нештатному поведению класса номер  из  возможных.
Участки нештатного поведения могут входить в анализируемую фазовую траекторию  в искаженном относительно эталонных траекторий виде. Можно выделить следующие типы искажений: искажения по амплитуде и искажения по времени. Под искажением траектории по амплитуде будем понимать изменение значений точек траектории без изменения числа отсчетов. Под искажением траектории по времени будем понимать изменение числа отсчетов, на которых определена траектория, то есть добавление в траекторию новых отсчетов или удаление из нее уже существующих. На рис. 1 показаны траектории, которые искажены по амплитуде и времени друг относительно друга. Подклассом искажений по амплитуде можно считать стационарный шум, возникающий в датчиках, окружающих систему.
Задача распознавания нештатного поведения состоит в следующем. Дано:  
наблюдаемая многомерная траектория ;
набор из  классов нештатного поведения системы, для каждого из которых задана эталонная траектория ;
ограничения на полноту и точность распознавания: ,, где  – число ошибок распознавания первого рода,  – число ошибок распознавания второго рода, ,  – заданные числовые ограничения. 
 Требуется с учетом ограничений на полноту и точность провести распознавание нештатного поведения в работе системы, т. е. указать в наблюдаемой траектории  участки нештатного поведения и номер класса нештатного поведения для каждого указанного участка.

Параметрическое семейство алгоритмов распознавания
Разработанное семейство алгоритмов распознавания основано на идеях алгебраического подхода к разметке плоских конфигураций. Идея использования алгебраического подхода для выделения трендов на временных рядах была предложена в работе [1], в работе [2] было предложено использование этого подхода для обнаружения нештатных режимов работы динамических систем. Основой аксиоматического подхода является разметка анализируемой траектории аксиомами и анализ траектории по полученному ряду разметки.
Определение 1. Элементарное условие  – это функция, определенная на отчете  и некоторой его окрестности  на траектории , зависящая от набора параметров , которая принимает значения из множества .
Пример элементарного условия: 
       (1)
 где , .
Определение 2. Аксиома  – это функция, заданная в виде булевой формулы от элементарных условий, определенных на отсчете  и некоторой его окрестности  на траектории :  
		(2)
  где  
Определение 3. Конечное множество аксиом  будем называть системой аксиом, если оно удовлетворяет условию:  
		(3)
т.е. для любой точки  произвольной фазовой траектории  найдется и притом только одна аксиома  из множества , условия которой выполняются в данной точке.
Любое множество аксиом возможно представить в виде системы аксиом выполнив: 
1. Введение порядка на множестве аксиом. Пронумеруем аксиомы в системе аксиом последовательными натуральными числами:
	(4)
Будем считать что, если аксиома с индексом  выполняется в некоторой точке произвольной фазовой траектории, то никакая аксиома с индексом  не выполняется в данной точке траектории.
2. Добавление тождественной аксиомы с наименьшим приоритетом в систему аксиом :  
		(5)
Тождественная аксиома  – это аксиома, которая выполняется в любой точке любой фазовой траектории.
Определение 4. Разметкой траектории  системой аксиом  будем называть конечную последовательность , где  – индекс аксиомы в системе аксиом , условия которой выполняются на отсчете  траектории . 
 Алгоритм, сопоставляющий траектории ее разметку заданной системой аксиом, будем называть алгоритмом разметки и обозначать .
В рамках разработанного подхода распознавание нештатного поведения в работе наблюдаемой системы происходит следующим образом:  
1. Размечаются эталонные траектории , соответствующие различным классам нештатного поведения. 
2. Размечается наблюдаемая траектория  и формируется ряд разметки . 
3. В ряду разметки  ищутся подпоследовательности номеров аксиом, соответствующие разметкам эталонных траекторий. 
Таким образом, определение нештатного поведения в работе наблюдаемой системы ведется не путем поиска эталонных траекторий  в наблюдаемой траектории , а путем поиска разметок эталонных траекторий в ряду разметки .
Решение рассматриваемой задачи распознавания будем искать среди множества алгоритмов , каждый из которых включает в себя:  
алгоритм предобработки исходных данных, 
алгоритм разметки и систему аксиом, 
алгоритм поиска разметок эталонных траекторий в разметке наблюдаемой траектории. 
Алгоритм предобработки включен в состав алгоритма распознавания с целью уменьшения влияния шумовых составляющих наблюдаемой траектории на качество распознавания. Использование алгоритмов нечеткого поиска разметок позволяет бороться с искажениями по времени. Для предобработки использовались следующие алгоритмы: сглаживания, сжатия и интерполяции траектории на произвольный коэффициент, быстрое преобразование Фурье. Для поиска разметок использовались: алгоритмы на основе метрики Минковского и DTW (Dynamic Time Warping) [3], алгоритмы на основе нейросетей, кроме этого был предложен алгоритм на основе расширенных разметок [4].

Задача построения алгоритма распознавания нештатного поведения
Пусть задан набор прецедентов  в виде экземпляров траекторий , полученных в различных условиях работы системы. Траектории  из набора  содержат как участки нештатного поведения, так и участки нормального поведения. Будем рассматривать два случая:
1. Для траекторий из набора  указаны границы участков нештатного поведения и для каждого из указанных участков указан номер класса нештатного поведения из множества . В этом случае набор прецедентов  называется набором прецедентов с указанием участков нештатного поведения.
2. Для траекторий из  указаны точки наступления аварийных ситуаций (при этом отсчеты начала и окончания предшествующего участка нештатного поведения неизвестны, т.е. неизвестна точка возникновения неисправности в системе). Для каждой точки аварии указан номер класса нештатного поведения из множества . В этом случае набор прецедентов  называется набором прецедентов с указанием точек аварий. 
Будем считать, что набор прецедентов  разделен на 2 равные непересекающиеся части: обучающую выборка  и контрольную выборка . Такое разделение обусловлено необходимостью использования обучающей выборки  для построения алгоритма распознавания и использования контрольной выборки  для оценки качества работы построенного алгоритма. Будем считать, что заданные наборы прецедентов ,  являются представительными, т. е. содержат как участки нормального поведения, так и участки нештатного поведения с различными искажениями, полученные в различных условиях работы системы.
 Пусть задана целевая функция , где  и  – число ошибок распознавания первого и второго рода, которая отвечает следующим требованиям:  
функция  определена для любых неотрицательных целых значений аргументов  и ;
функция  монотонно неубывает по каждому из аргументов. 
Число ошибок распознавания первого рода  (второго рода ) определяется для некоторого алгоритма распознавания  на некоторой траектории . Под числом ошибок распознавания на выборке  будем понимать сумму числа ошибок распознавания на всех траекториях данной выборки.
Задача построения алгоритма распознавания нештатных ситуаций в работе динамической системы состоит в следующем. Дано:  
выборка , 
целевая функция . 
 Требуется построить алгоритм распознавания , который будет удовлетворять следующему набору ограничений:  
1. Алгоритм  должен выдавать ограниченное число ошибок на обучающей выборке : 
, 	(6)
где:  – заданные  числовые ограничения.
2. Алгоритм  должен минимизировать значение целевой функции  на контрольной выборке : 
	(7)
3. Вычислительная сложность работы алгоритма распознавания  на произвольной траектории, длины не больше , должна быть ограничена наперед заданной функцией , которая определяется характеристиками используемого вычислителя и скоростью развития процессов в анализируемой системе: 
	(8)
Данная задача построения алгоритма распознавания соответствует классической постановке задачи обучения по прецедентам [5]. 

Методы обучения параметрического семейства алгоритмов распознавания
Для того, чтобы найти требуемый алгоритм распознавания в семействе , необходимо выбрать алгоритм предобработки и значение его параметров, построить систему аксиом, выбрать алгоритм нечеткого поиска и значение его параметров, а также определить эталоны участков нештатного поведения, которые необходимо обнаруживать в наблюдаемой фазовой траектории системы. Поиск алгоритма распознавания ведется в два этапа:  
1. Для каждой пары (алгоритм предобработки, алгоритм поиска разметок) ведется поиск алгоритма распознавания, при котором настраиваются значения параметров заданных алгоритмов предобработки и поиска разметок, стоится система аксиом и формируются разметки участков нештатного поведения. Область поиска с заданным типом алгоритма предобработки и типом алгоритма поиска разметок будем называть шаблоном и обозначать .
2. Среди всех полученных решений выбирается то, которое показывает наименьшее значение целевой функции  на контрольной выборке . 
 Для настройки параметров алгоритмов предобработки и поиска разметок используются алгоритмы локальной оптимизации, например, алгоритм градиентного спуска. Наибольшую сложность представляет задача построения системы аксиом.
В случае набора прецедентов с указанием участков нештатного поведения построение системы аксиом ведется при помощи генетического алгоритма [6]. Основные этапы алгоритма:
1. Создание начальной популяции.
2. Мутация особей популяции.
3. Скрещивание особей и образование расширенной популяции.
4. Селекция особей и сужение популяции.
5. Проверка критерия останова: останов или переход к п. 2.
Особью популяции является система аксиом. Операции мутации и скрещивания определены на трех уровнях: уровне систем аксиом, уровне аксиом и уровне элементарных условий. Селекция ведется на основе результатов вычисления целевой функции  для каждой системы аксиом в популяции на контрольной выборке . При этом разметки эталонных траекторий строятся как разметки участков нештатного поведения из обучающей выборки ; если для некоторого класса нештатного поведения в обучающей выборке задано несколько участков нештатного поведения, то из их разметок выбирается та, которая показывает наименьшее значение целевой функции на контрольной выборке .
В случае набора прецедентов с указанием точек аварий набор прецедентов  преобразуется следующим образом: для каждой траектории :
если не содержит точек аварий, то она оставляется без изменений;
если содержит точки аварии, то участки длины с правым концом в точках аварии и оставшиеся участки добавляются в  как отдельные траектории, а траектория удаляется из .
Здесь  – параметр, определяемый тем, как скоро в системе после проявления нештатного поведения наступает авария, и зависящий от конкретной динамической системы.
В результате такого преобразования в наборе прецедентов остаются траектории, каждая из которых содержит не более одного участка нештатного поведения, для которого известен номер класса нештатного поведения, но неизвестно конкретное положение в траектории.
Построение системы аксиом и разметок эталонных траекторий проводится при помощи алгоритма, использующего направленный перебор [7]. Основные этапы алгоритма:
1. Подбор элементарных условий. На этом этапе ведется перебор типов и параметров элементарных условий и отбор заданного числа элементарных условий, которые чаще встречаются на траекториях, содержащих участки нештатного поведения и реже – на траекториях нормального поведения обучающей выборки.
2. Подбор аксиом. На этом этапе происходит итеративное объединение элементарных условий, полученных на предыдущем этапе, в аксиомы при помощи операторов конъюнкции и дизъюнкции. Затем отбирается заданное число аксиом, которые чаще встречаются на траекториях обучающей выборки, содержащих участки нештатного поведения и реже – на траекториях нормального поведения.
3. Подбор систем аксиом. На этом этапе системы аксиом итеративно строятся из аксиом, полученных на предыдущем этапе. Затем выбираются лучшие системы аксиом, имеющие наименьшее значение целевой функции  на контрольной выборке. 
Первые два этапа проводятся независимо для каждого класса нештатного поведения. На третьем этапе для каждой системы аксиом разметки эталонных траекторий каждого класса нештатного поведения формируются как наибольшие общие подпоследовательности разметок траекторий, содержащих участки нештатного поведения этого класса.

Заключение
При численном исследовании предложенного метода построения распознавателя для случая набора прецедентов с указанием участков нештатного поведения на модельных данных при искажениях эталонных траекторий по времени до 40% и амплитуде налагаемого шума до 25% число ложных срабатываний не превысило 76 на траекториях длиной 30000 отсчетов, а процент нераспознанных участков нештатного поведения был равен 2%. При применении подхода к прогнозирования микрона водителя в среднем процент ошибок II рода составил 5%, а число ложных срабатываний в среднем составило около 15 на отсчетов (что соответствует 6–7 часам наблюдения).
При численном исследовании предложенного метода построения распознавателя для случая набора прецедентов с указанием точек аварий на модельных данных при искажениях по времени до 50% и по амплитуде до 20% число ложных срабатываний не превысило 18 на траекториях длиной 10000 отсчетов, а процент нераспознанных участков нештатного поведения не превышал 5%. Для задачи распознавания рукописного ввода букв число корректно распознанных букв составило 95%, число ложных срабатываний – 58 при общем числе траекторий 2858.
Результаты численного исследования свидетельствуют о том, что разработанные методы построения алгоритмов распознавания позволяют получать алгоритмы, обладающие высокой устойчивостью к нелинейным искажениям фазовых траекторий нештатного поведения. Кроме этого, разработанные методы, в отличие от известных методов, основанных на машинном обучении, позволяют строить алгоритмы распознавания нештатного поведения систем для случая, когда время возникновения неисправности в системе неизвестно, т. е. в траекториях обучающей выборки не указаны участки нештатного поведения, а указана лишь точка наступления аварии.

Список литературы

1. Рудаков К.В., Чехович Ю.В. О проблеме синтеза обучающих алгоритмов выделения трендов (алгебраический подход). // Прикладная математика и информатика N 8, М. Издательство факультета ВМиК МГУ, 2001. С. 97-114. 
2. Коваленко Д.С., Костенко В.А., Васин Е.А. Исследование применимости алгебраического подхода к анализу временных рядов. // Труды Второй Всероссийской Научной Конференции «Методы и средства обработки информации». Изд.: ВМиК МГУ, 2005. С. 553-559. 
3. Keogh E. J., Michael J. Pazzani. Derivative Dynamic Time Warping. // Proceedings of the First SIAM International Conference on Data Mining (SDM'2001), Chicago, USA. 2001. http://www.ics.uci.edu/pazzani/Publications/sdm01.pdf. 
4. Коваленко Д.С. Методы нечеткого сравнения и голосования для построения распознавателей нештатного поведения динамических систем.  // Труды V Московской международной конференции по исследованию операций «ORM-2007». Изд: МАКС Пресс, 2007. С.123-125. 
5. Воронцов К.В. Комбинаторный подход к оценке качества обучаемых алгоритмов. // Математические вопросы кибернетики. №13, 2004. С.5-36.
6. Коваленко Д.С., Костенко В.А., Васин Е.А. Генетический алгоритм построения системы аксиом для разметки временных рядов. // Труды VII Международной Конференции: Дискретные модели в теории управляющих систем. М.: Макс Пресс, 2006. С. 46-54.
7. Коваленко Д.С. Метод автоматического построения алгоритмов распознавания участков фазовых траекторий. // Моделирование и анализ информационных систем, Т. 16, №4, 2009. Изд.: ЯрГУ. С. 6–21.Научная сессия МИФИ - 2007. IX Всероссийская научно-техническая конференция "Нейроинформатика-2007": Сборник научных трудов. В 3-х частях. Ч.3. М.: МИФИ, 2007. - С.251-257.

В. А. КОСТЕНКО, А. Е. СМОЛИК
Московский Государственный Университет им. М.В. Ломоносова, 
факультет Вычислительной математики и Кибернетики
kost@cs.msu.su, smolex@list.ru 
 
АЛГОРИТМ МУЛЬТИСТАРТА С ОТСЕЧЕНИЕМ ДЛЯ ОБУЧЕНИЯ НЕЙРОННЫХ СЕТЕЙ ПРЯМОГО РАСПРОСТРАНЕНИЯ

В данной статье рассматривается алгоритм мультистарта с отсечением для решения задачи обучения нейронной сети прямого распространения. Основная идея данного алгоритма состоит в том, чтобы уменьшить вычислительную сложность алгоритма мультистарта путем отсечения неперспективных инициализаций на ранних этапах обучения. В статье приведены результаты численного исследования алгоритма и выявлена зависимость эффективности работы алгоритма от его основных параметров.

1 Введение
В настоящее время существует множество алгоритмов обучения нейронных сетей прямого распространения (НС). Наиболее распространены различные вариации алгоритмов «наибыстрейшего спуска» — такие, как алгоритм обратного распространения ошибки [1]. В  их основе лежит итеративная процедура изменения параметров НС в направлении, противоположном вектору градиента ошибки аппроксимации. Эти алгоритмы являются локально-оптимальными и результат обучения зависит от выбранного начального приближения. Альтернативным подходом является применение для обучения НС алгоритмов глобального поиска. В противоположность локально-оптимальным алгоритмам, алгоритмы глобального поиска, такие, как алгоритм имитации отжига [5] или генетический алгоритм Холланда [6], обладают способностью исследовать все пространство возможных решений. Недостатком таких алгоритмов является их высокая вычислительная сложность и проблема настройки параметров алгоритма. 
Основная идея алгоритма мультистарта с отсечением заключается в проведении нескольких параллельных запусков (стартов) некоторого локально-оптимального алгоритма. При этом на ранних этапах обучения выделяются неперспективные старты, которые исключаются из рассмотрения, и процесс обучения продолжается на более узком наборе стартов. Таким образом удается сократить количество циклов обучения, проводимых на неудачных стартах, и уменьшить время работы алгоритма.

2 Задача обучения нейронной сети
Нейронной сетью (НС)  [2] будем называть тройку , в которой:
G — ориентированный ациклический граф, задающий  топологию сети: его вершины соответствуют нейронам, дуги — межнейронным связям;
Т — множество функций перехода сети;
W — множество векторов весовых коэффициентов сети.
Первые два компонента  тройки   задают архитектуру НС.
Инициализацией  архитектуры НС будем называть НС данной архитектуры после присвоения ей некоторого начального набора весовых коэффициентов. 
Выборкой будем называть конечный набор  пар «аргумент — значение аппроксимируемой функции», где ,, N — число входных нейронов (число аргументов функции), M — число выходных нейронов. Выборку будем называть корректной, если  выполняется .
Задача обучения НС с заданной архитектурой состоит в том, чтобы подобрать значения ее весовых коэффициентов таким образом, чтобы максимально повысить эффективность решения поставленной прикладной задачи. В рамках исследуемого в данной работе частного случая задачи обучения НС (когда НС применяется для аппроксимации таблично заданной непрерывной функции) рассматриваются следующие критерии эффективности решения задачи аппроксимации:
1) точность аппроксимации, которая обеспечивается сетью;
2) время обучения сети.
 Точность аппроксимации, обеспечиваемая НС , измеряется величиной среднеквадратической ошибки аппроксимации , вычисляемой на заданной корректной выборке S из аппроксимируемой функции.
Время обучения НС измеряется количеством элементарных математических операций, необходимых для подстройки весов НС, обеспечивающей заданную точность аппроксимации. В случае алгоритма мультистарта с отсечением, исследуемого в данной статье, процесс обучения может быть разделен на некоторое множество последовательных циклов подстройки весов, называемых циклами обучения. Поскольку общее число математических операций, требуемых для осуществления  каждого из циклов обучения можно считать неизменным, а длительность прочих составляющих процесса обучения пренебрежимо мало, в качестве второго критерия  рассматривается общее число циклов обучения . 
	
3 Алгоритм мультистарта с отсечением
Методом отсечения будем называть , где
A —  число начальных инициализаций, A  N,  A > 1.
C — максимальное число циклов обучения для обучения по одному варианту инициализации, C  N.
D — схема отсечения, задаваемая как конечный набор пар натуральных чисел , удовлетворяющий условиям , где n — число шагов алгоритма,  — число циклов обучения на i-ом шаге— число отсечений на i-ом шаге.
K — критерий отсечения — отображение, по которому для  каждого шага  задается функция R1, где NET — архитектура НС, а S — обучающая выборка.
	Критерием отсечения по значению MSE (KMSE) будем называть критерий, в соответствии с которым для любого   .
	В качестве исходных данных для алгоритма мультистарта с отсечением должны быть заданы:
архитектура НС ;
корректная выборка S аппроксимируемой функции;
локально-оптимальный алгоритм обучения L;
функция распределения начальных инициализаций F.
Набор параметров алгоритма задается методом отсечения , который определяет, как будут отсекаться неперспективные инициализации в процессе обучения. 
Алгоритм мультистарта с отсечением, реализующий метод отсечения M на данном приложении, будем обозначать . Ниже приведено описание работы этого алгоритма.
1. Производится A инициализаций архитектуры НС . Каждый весовой коэффициент выбирается случайным образом в соответствии с функцией распределения F. При этом создается A НС, различающихся только своими наборами весов и имеющих архитектуру . Каждой НС присваивается порядковый номер, соответствующий ее начальной инициализации. Порядковые номера НС не меняются в процессе их дальнейшего обучения.   
2. Делается n шагов алгоритма, на каждом i-ом шаге производится ci циклов обучения всех оставшихся НС на выборке S в соответствии с локально-оптимальным алгоритмом L, после чего удаляются ai НС с наименьшими значениями функции  . При этом обучение производится таким образом, чтобы для любых натуральных чисел p и q последовательное применение p, затем q циклов  обучения было эквивалентно однократному применению  p + q циклов обучения.
3. НС, оставшаяся после n-го шага отсечения, проходит   циклов обучения.
4. Получившуюся НС будем называть результирующей, а ее  весовые коэффициенты и значение среднеквадратичной ошибки аппроксимации на заданной выборке будут выданы как результат работы алгоритма.
Общее количество циклов локально-оптимального алгоритма обучения при этом равно
  (3.1)
где 
 будем называть вычислительной сложностью алгоритма мультистарта с отсечением.
Алгоритмом мультистарта будем называть частный случай алгоритма мультистарта с отсечением с числом отсечений n = 1 и схемой отсечения , в котором в качестве критерия отсечения используется KMSE. Очевидно, что общее количество циклов обучения алгоритма мультистарта равно C·A.
4 Результаты численного исследования алгоритма
Для проведения численного исследования описанного алгоритма использовались непрерывные вещественные функции от двух вещественных переменных, рассматриваемые на множестве [0, 1] x [0, 1]. Для исследования были подобраны функции различного вида, а именно с различным количеством экстремумов, различной «сложностью» и «однородностью» рельефа. Для приведения к общей области определения ко всем функциям было применено линейное преобразование координат: , где , — коэффициент масштабирования, подбираемый отдельно для каждой функции. Ниже приведен перечень выбранных функций:
1. , коэффициент масштабирования 1,5;
2. , коэффициент масштабирования 5;
3. , коэффициент масштабирования 1;
4. , коэффициент масштабирования 3;
5. , коэффициент масштабирования 3;
6. , коэффициент масштабирования 10;
7. , коэффициент масштабирования 6;
8. , коэффициент масштабирования 7;
9. , коэффициент масштабирования 15;
10. , коэффициент масштабирования 10.
Из вышеприведенных функций можно выделить три группы по возрастанию «сложности» их рельефа:
f1, f2 — первый тип (простой рельеф);
f3, f4, f5, f6 — второй тип (более сложный рельеф, присутствуют экстремумы);
f7, f8, f9, f10 — третий тип (многоэкстремальный и неоднородный рельеф).
Параметры алгоритма мультистарта с отсечением были заданы следующие:
архитектура нейронной сети — двуслойный персептрон [3] с 10 нейронами в каждом из внутренних слоев;
количество начальных инициализаций (стартов) А = 30;
циклы обучения проводились локально-оптимальным алгоритмом Левенберга-Марквардта [4].
Эксперименты ставились так, чтобы суммарное число циклов обучения в алгоритме мультистарта с отсечением и в алгоритме мультистарта без отсечения было одинаковым — 1500. Количество стартов также было одинаковым — 30. Схемы отсечения  выбирались с суммарным числом циклов обучения, равным 1500, при этом максимальное число циклов обучения на один старт было равным 65. В алгоритме мультистарта без отсечения число циклов обучения на старт было равным 50. Схемы отсечения сравнивались между собой и со схемой без отсечения по величине получаемой ошибки аппроксимации. 
В таблице 1 представлено уменьшение (в процентах) ошибки аппроксимации схем с различным числом шагов отсечения по сравнению с алгоритмом мультистарта без отсечения. Ошибка алгоритма мультистарта без отсечения принята за 100%.

Таблица 1. Результаты сравнения алгоритмов
Типы функций
Мультистарт
без отсечения
Число шагов отсечения


2
4
Первый тип
100 %
65,17 %
51,09 %
Второй тип
100 %
74,24 %
64,31 %
Третий тип
100 %
57,79 %
51,60 %
Все функции
100 %
65,73 %
55,67 %

Были выявлены некоторые общие свойства схем, показавших высокую точность аппроксимации, а именно:
число циклов обучения, которые проводятся над всеми стартами до первого отсечения, в среднем не менее 25 циклов (на старт), что составляет около 38% от общего числа циклов обучения на один старт;
число циклов обучения, которое тратится на обучение (доводку) результирующей сети после последнего шага отсечения, не превышает 10 циклов, что составляет около 15% общего числа циклов;
на первом шаге отсечения отсекается не менее 5 стартов, что составляет около 17% от общего числа стартов.

Список литературы

  1.
Rumelhart D., Hinton G., Williams R. Learning internal representations by error propagation // In Parallel distributed processing, vol. 1, pp. 318-62. Cambridge, MA: MIT Press, 1986.
  2.
Маркин М.И. Синтез нейронной сети под заданное приложение // Диссертация на соискание ученой степени кандидата физико-математических наук. - М.: МГУ, 2001.
  3.
Терехов А.С. Лекции по теории и приложениям искусственных нейронных сетей, Лаборатория Искусственных Нейронных Сетей НТО-2, ВНИИТФ, Снежинск, 1998.
  4.
Hagan M, Menhaj M. Training feedforward networks with the Marquardt algorithm       // IEEE Transactions on Neural Networks, vol. 5, no. 6, 1994, pp. 989-993.
  5.
M. Locatelli. Simulated Annealing Algorithms for Continious Global Optimization. Journal of Optimization Theory and Applications, pp. 104, 121-133 (2000).
  6.
Kitano H. Empirical studies on the speed of convergence of neural network training using genetic algorithms // Proceedings of the Eighth Nat'l Conf. on AI (AAAI90), pp. 789-805. MIT Press, Cambridge, MA, 1990.
Костенко В.А., Шестов П.Е. Жадный алгоритм совместного планирования вычислений и обменов в системах реального времени // Известия РАН. Теория и системы управления. - 2012. - № 5 - С.35-49.

УДК 004.031.43

ЖАДНЫЙ АЛГОРИТМ СОВМЕСТНОГО ПЛАНИРОВАНИЯ ВЫЧИСЛЕНИЙ И ОБМЕНОВ В СИСТЕМАХ РЕАЛЬНОГО ВРЕМЕНИ
© 2012 г., В. А. Костенко, П. Е. Шестов
Москва, МГУ
Поступила в редакцию 20.12.11 г.
Приведена математическая постановка задачи построения согласованных расписаний выполнения прикладных задач и передачи сообщений для исходно заданных наборов прикладных задач и сообщений. Данная задача возникает при проектировании информационно-управляющих систем реального времени. Проведен анализ возможных подходов к построению алгоритмов для решения сформулированной задачи, описан разработанный жадный алгоритм и приведены результаты его экспериментального исследования.

Введение. Одним из важнейших требований к функционированию информационно–управляющих систем реального времени (ИУС РВ) является соблюдение директивных сроков выполнения прикладных программ. При нарушении директивных сроков, ИУС РВ теряет свою работоспособность. При разработке и отладке прикладного программного обеспечения для каждой версии программного обеспечения ИУС РВ необходимо строить расписание выполнения прикладных программ и расписание обмена данными для проверки возможности выполнения ограничений реального времени. При построении расписаний необходимо учитывать технологические ограничения ИУС РВ, обусловленные особенностями используемых аппаратных и системных программных средств. Приведенная в работе задача совместного планирования вычислений и обменов возникает при модификации ИУС РВ (например, при добавлении новых подсистем), а также при разработке новых ИУС РВ на базе существующих.
В данной статье задача совместного планирования вычислений и обменов рассматривается для ИУС РВ, в которой в качестве среды обмена используется канал с централизованным управлением. К основным особенностям задачи можно отнести:
в качестве исходных данных задаются набор прикладных программ, подлежащих планированию, и набор сообщений, посредством которых прикладные программы взаимодействуют друг с другом и подсистемами, изменение которых недопустимо;
время передачи сообщения зависит от расписания выполнения прикладных программ;
присутствуют технологические ограничения на корректность расписания обменов, а не только ограничения на передачу каждого сообщения в рамках его директивного интервала.
В работе приведена математическая постановка задачи, рассмотрены основные особенности задачи, отличающие её от других задач построения расписаний, проведен анализ возможных подходов к построению алгоритмов решения сформулированной задачи, предложен алгоритм, основанный на жадных стратегиях, и приведены результаты его численного исследования.
1. Задача совместного планирования вычислений и обменов. В данной главе введем понятия расписания выполнения работ и расписания передачи сообщений, сформулируем условия корректности расписаний и условия их совместимости, приведем математическую постановку задачи совместного планирования вычислений и обменов. Исходными данными для задачи совместного планирования вычислений и обменов являются набор прикладных программ (работ) и набор сообщений, посредством передачи и приема которых работы взаимодействуют друг с другом и подсистемами. Для каждой работы задан директивный интервал, в рамках которого она должна быть выполнена, и набор вычислительных модулей, на которые работа может быть размещена. Для каждого сообщения задан директивный интервал, в рамках которого оно должно быть передано. Прерывание выполнения работ и передачи сообщений недопустимо. ИУС РВ рассматривается как система, состоящая из набора вычислительных модулей и подсистем, подключенных к единой среде передачи данных. Каждая подсистема может быть представлена как набор работ (в дальнейшем работы-подсистемы), исполняющихся на отдельном вычислительном модуле, на который недопустимо назначение работ из исходного набора. Для множества работ-подсистем известно расписание. Задача совместного планирования вычислений и обменов заключается в построении согласованных статических расписаний выполнения исходно заданных работ и обменов.
Модель набора работ и сообщений, подлежащих планированию. Исходный набор работ и сообщений будем представлять ориентированным ациклическим графом (возможно, несвязным) с двумя типами вершин . Первый тип вершин соответствует работам (в том числе работам-подсистемам), второй – сообщениям. Дугами графа задаётся частичный порядок на множествах работ и сообщений. Пример графа приведен на рисунке. Квадратами отмечены вершины-работы, кругами – вершины-сообщения. Дополнительно вершины, соответствующие работам-подсистемам, отмечены пунктиром. Работы-подсистемы не подлежат планированию, но участвуют в передаче сообщений наряду с другими работами. Каждая вершина-сообщение передаёт данные от вершины-работы, являющейся её предшественником, вершинам-работам, являющимся её преемниками. Если у вершины-работы среди предшественников есть вершины-работы (как, например, вершины-работы 4 – 6), то все они вместе с исходной вершиной-работой должны быть запланированы на один и тот же вычислительный модуль, а обмен данными происходит через внутреннюю память этого модуля. При этом каждой вершине-сообщению инцидентны ровно одна входящая дуга и не менее одной исходящей дуги. Другими словами мы предполагаем, что данные, передаваемые в сообщении, формируются специальной работой, которая может брать слова данных от других работ, выполняющихся на этом же вычислительном модуле. Такой способ используется во многих ИУС РВ, в которых есть каналы с централизованным управлением. 
Обозначим через  множество вычислительных модулей,  – множество работ из исходно заданного набора, которые подлежат планированию,  – множество всех сообщений.
Для каждой вершины-работы из множества  известны:
– директивный срок начала выполнения работы (должно начаться не раньше этого срока);
 – директивный срок завершения выполнения работы (должно завершиться до наступления этого срока);
 – набор вычислительных модулей, на которые допустимо назначение этой работы для выполнения.
Также известна функция , определяющая длительность выполнения заданной работы на заданном вычислительном модуле. Здесь и далее  обозначает множество натуральных чисел. Аналогично для каждой вершины-сообщения из множества M известны: 
 – директивный срок начала передачи сообщения;
 – директивный срок завершения передачи сообщения;
Если среди предшественников или преемников вершины-сообщения есть работы из множества , то длительность передачи сообщения зависит от того, на какие вычислительные модули эти работы будут назначены. Более того, если все предшественники и преемники вершины-сообщения будут запланированы на один вычислительный модуль, то сообщение вообще не требуется передавать по среде передачи данных. В состав исходных данных входит функция, позволяющая определить длительность передачи сообщения, однако формальное её представление будет введено ниже, так как требует введения понятия привязки работ к вычислительным модулям.
Расписание выполнения работ. Расписание представляет собой множество троек вида <работа, номер вычислительного модуля на котором выполняется работа , планируемое время старта работы >: . Промежуток времени  будем называть интервалом выполнения работы . Для простоты, когда известно (или не важно), о каком расписании работ идёт речь, будем обозначать длительность выполнения работы  в нём как .
Привязкой работ к вычислительным модулям назовём множество пар <работа, вычислительный модуль>: . Будем говорить, что расписанию  соответствует привязка , если для каждой тройки в расписании есть соответствующая пара в привязке и наоборот: . Расписание  называется корректным, если выполнены следующие ограничения корректности (ограничения для многоприборных систем без прерывания работ):
1) каждая работа из набора включена не более чем в одну тройку: , где

2) требование реального времени (каждая работа выполняется в рамках своего директивного интервала): , где

3) на одном и том же вычислительном модуле в каждый момент времени может выполняться только одна работа: , где

4) каждая работа должна быть запланирована только на допустимый для неё вычислительный модуль: , где

Расписание  называется полным, если каждая работа из набора W включена в расписание. Множество всех расписаний работ (в том числе некорректных и неполных) обозначим через .
Расписание передачи сообщений. Расписание представляет собой множество пар вида <сообщение, время старта>: . Множество всех расписаний передачи сообщений из набора M обозначим через . Функция, позволяющая определить длительность передачи сообщений, выглядит следующим образом: . Поскольку длительность передачи сообщений зависит от привязки работ к вычислительным модулям, то рассматривать корректность расписания сообщений возможно только в контексте расписания выполнения работ и соответствующей ему привязке работ. Промежуток времени  будем называть интервалом передачи сообщения i. Для простоты, когда известно (или не важно), в контексте какого расписания работ идёт речь, будем обозначать длительность передачи сообщения  в нём как .
Введём две функции:
 и 
– минимальная и максимальная длительности передачи сообщения по всем возможным привязкам работ к вычислительным модулям (которые могут быть построены для данного неполного расписания). 
Расписание  называется корректным, если выполнены следующие ограничения корректности:
1) общие ограничения для одноприборных систем без прерывания работ:
1) каждое сообщение из набора включено не более чем в одну пару: , где

2) требование реального времени (каждое сообщение должно быть передано в рамках своего директивного срока) , где

3) в каждый момент времени может передаваться только одно сообщение: , где

2) ограничения корректности, обусловленные технологическими требованиями к обмену данными: , где  - функция, принимающая значение 0, если расписание обменов удовлетворяет этим ограничениям, и 1 – в противном случае.
Формализация ограничений из последнего пункта для канала с централизованным управлением приведена ниже. Расписание  называется полным, если каждое сообщение из набора M включено в расписание.
Каждое передающееся сообщение однозначно относится к некоторому множеству сообщений, называемому цепочкой, которая является последовательностью сообщений, передающихся непрерывно друг за другом, т.е.  причем :
;
;
.
Используя определение цепочки сообщений, можно ввести формальное определение ограничений корректности, обусловленных технологическими требованиями к обмену данными:
суммарная длительность передачи сообщений в цепочке не должна превышать заданного значения  (максимальная длительность цепочки сообщений):
;
число сообщений в цепочке не должно превышать заданного значения  (максимальное количество сообщений в цепочке):
;
между цепочками сообщений должен быть свободный промежуток времени, длительность которого должна быть не меньше заданного значения  (минимальный интервал между цепочками):

Совместное расписание выполнения работ и передачи сообщений. Расписание представляет собой пару расписаний вычислений и обменов . Для определения условий совместимости расписания выполнения работ и расписания передачи сообщения введём дополнительные обозначения. Для каждой вершины-работы  в графе исходных данных примем:
 – множество вершин-сообщений – непосредственных предшественников;
 – множество вершин-сообщений – непосредственных потомков;
 – множество вершин-работ – непосредственных предшественников;
 – множество вершин-работ – непосредственных потомков.
Для каждой вершины-сообщения j в графе исходных данных запишем:
 – вершина-работа – непосредственных предшественников;
 – множество вершин-работ – непосредственных потомков.
Совместное расписание H называется корректным, если выполнены следующие ограничения корректности:
1) ограничения корректности для расписания выполнения работ;
2) ограничения корректности для расписания передачи сообщений;
3) в расписании передачи сообщений запланированы все сообщения, передающие данные, необходимые для выполнения запланированных работ: , где

4) в расписании выполнения работ запланированы все работы, формирующие данные, передающиеся в запланированных в расписании обменов сообщениях: , где

5) в расписании выполнения работ все работы, передающие данные запланированным работам через внутреннюю память вычислительных модулей, запланированы  на тот же вычислительный модуль, что и получатели данных:
 Совместное расписание называется полным, если являются полными оба расписания вычислений и обменов.
Формальная постановка задачи построения согласованных расписаний выполнения работ и передачи сообщений. Число элементов в расписании выполнения работ, т.е. число запланированных работ, равно . Аналогично число элементов в расписании обменов, т.е. число запланированных сообщений, равно . Общее число запланированных элементов в совместном расписании . Пусть заданы: набор вычислительных модулей , на которые возможно планирование работ; граф исходных данных с атрибутами работ и сообщений; функция , вычисляющая время выполнения работ; функция , определяющая время передачи сообщений; конкретные значения характеристик канала с централизованным управлением: ,  и .
Задача построения совместного расписания выполнения работ и передачи сообщений заключается в построении расписания, которое содержит максимально возможное число вершин графа G и удовлетворяет условиям корректности:

К основным особенностям данной задачи, отличающим ее от других задач построения расписаний, можно отнести:
в графе исходных данных содержатся вершины двух типов: вершины-сообщения и вершины-работы, которые соответствуют прикладным задачам;
вершины-работы могут быть двух типов: работы, выполнение которых должно быть запланировано на заданном наборе вычислительных модулей, и работы, которые не подлежат планированию и выполняются на отдельном вычислительном модуле, на который недопустимо назначение других работ;
время передачи сообщения зависит от расписания выполнения работ;
присутствуют ограничения корректности сразу на все расписание сообщений, а не только временные ограничения на каждое сообщение в отдельности.
2. Известные алгоритмы, проблемы их применения и возможные подходы к решению задачи. В данном разделе обсуждаются две известные из литературы близкие задачи и алгоритмы их решения, а также четыре возможных подхода к построению алгоритмов решения рассматриваемой задачи. Под близкими задачами мы понимаем задачи, для которых набор работ, подлежащий планированию, содержит работы двух типов: работы-задачи и работы-сообщения. 
В [1] рассматривается следующая задача1. Заданы набор периодических заданий и набор вычислительных узлов системы. На размещение заданий на вычислительные узлы могут быть наложены такие ограничения, как:
два задания должны быть размещены на один и тот же узел;
два задания должны быть размещены на разные узлы;
задание может быть размещено только на узлы из некоторого подмножества всех узлов системы.
Каждое задание состоит из модулей, минимальных единиц планирования. На множестве модулей одного задания может быть определено отношение предшествования. Модули бывают двух типов: вычислительные и коммуникационные. Время выполнения вычислительного модуля зависит от узла, на который он назначен. Каждому коммуникационному модулю соответствует партнёр по коммуникации – коммуникационный модуль другого задания. Время выполнения коммуникационного модуля Mj зависит от того, на какой узел назначен партнёр, и равно , если партнёр выполняется на том же узле (локальная коммуникация), и , если на другом (удаленная коммуникация), причем . Временные задержки (например, на передачу служебных слов) при передаче сообщения между коммуникационными модулями Mi и Mj, выполняющимися на разных узлах системы, фиксированы и заданы.
Отношение времени, которое прошло от директивного срока начала задания до завершения выполнения задания, к длительности директивного срока называется нормализованным временем отклика. В [1] ставится задача нахождения расписания, в котором минимизируется максимум нормализованного времени отклика, взятый по всем заданиям и зависящий от конкретного размещения модулей заданий по узлам системы. Напомним, что в понятие расписания также включается размещение заданий по вычислительным узлам.
Алгоритм решения основан на методе ветвей и границ. Дерево поиска состоит из частичных или полных расписаний. У каждой вершины ровно столько потомков, сколько вычислительных узлов в системе. Если считать, что задано для планирования m заданий, то на уровне k дерева поиска запланировано ровно k заданий (корень считается вершиной уровня 0). Вершины уровня m представляет собой полные расписания – кандидаты в решения задачи. Вершины, в которых нарушены ограничения на размещение заданий по узлам, отбрасываются сразу же без вычисления значения критерия. В [1] предложен алгоритм оценки нижней границы значения критерия оптимальности расписания в вершине, имеющий сложность O(nM2), где n – количество вычислительных узлов, M – общее количество модулей.
При использовании описанных выше результатов применительно к решению рассматриваемой в данной статье задачи логично отождествить вычислительные модули заданий из [1] с работами, а пары коммуникационных модулей – с сообщениями. Основные отличия задачи из [1], которые препятствуют её использованию, следующие:
1) у каждого сообщения может быть только один получатель;
2) нет ограничений на расписание сообщений в целом (технологических ограничений);
3) в среде передачи данных отсутствуют конфликты, два и более сообщения могут передаваться одновременно;
4) другой критерий оптимальности расписания.
Учет этих различий будет означать построение нового алгоритма, основанного на методе ветвей и границ без использования результатов [1].
В [2] рассматривается набор периодических работ, который должен быть запланирован на набор вычислительных модулей. Работы взаимодействуют путем отправки сообщений. Каждое сообщение отправляется с минимальной частотой двух взаимодействующих работ. Для сообщений не вводится директивных сроков, но есть ограничение сверху на время между началом выполнения передающей работы и концом выполнения принимающей работы. В этот интервал должно передаться сообщение. Время на передачу каждого сообщения фиксировано. В каждый момент времени по среде может передаваться только одно сообщение. Допускаются циклические зависимости между работами. Например, экземпляр работы A шлет сообщение экземпляру работы B, который шлет сообщение следующему экземпляру работы A, и т.д. В [2] решается задача нахождения расписания, минимизирующего суммарные нарушения временных ограничений (в том числе нарушения директивных сроков).
Алгоритм, предложенный в [2], основан на схеме имитации отжига, которая используется для нахождения размещения работ по вычислительным модулям. Расписание для каждого размещения строится при помощи жадного алгоритма. Целевая функция алгоритма совпадает с целевой функцией поставленной задачи. Для нахождения очередного размещения в алгоритме имитации отжига используются четыре операции:
случайный перенос работы с более загруженного модуля на менее загруженный;
случайный выбор двух работ на разных модулях и их обмен местами;
перенос двух случайных работ с разных процессоров на один;
обмен местами двух работ, нарушающих временные ограничения.
Основные отличия задачи из [2], которые препятствуют использованию алгоритма ее решения, следующие:
1) у каждого сообщения может быть только один получатель;
2) нет ограничений на расписание сообщений в целом (технологических ограничений);
3) директивные сроки работ могут нарушаться (минимизируются суммарные нарушения временных ограничений).
Перейдем к рассмотрению возможных подходов для решения поставленной задачи. Первые два подхода основаны на декомпозиции рассматриваемой задачи на две подзадачи: построение расписания выполнения работ и построение расписания передачи сообщений.
Первый подход:
1) построить расписание передачи сообщений;
2) сузить директивные интервалы работ в соответствии с расписанием передачи сообщений;
3) построить расписание выполнение работ.
Второй подход:
1) построить расписание выполнения работ;
2) сузить директивные интервалы сообщений в соответствии с расписанием выполнения работ;
3) построить расписание передачи сообщений.
Рассмотрим возможность применения в рамках этих подходов известных алгоритмов. Задача построения расписания передачи сообщений является задачей построения одноприборных расписаний без прерываний для набора работ с индивидуально заданными директивными интервалами и известными временами выполнения. Использование алгоритмов из [3, 4] невозможно или требует значительной модификации алгоритма (практически построение нового алгоритма) из-за наличия технологических ограничений  на корректность расписания передачи сообщений. Построение расписаний передачи сообщений, удовлетворяющих ограничениям , возможно алгоритмами [5 – 7]. Однако для первого подхода не известны набор сообщений, подлежащих планированию, и времена передачи сообщений, так как набор сообщений и время передачи сообщения зависят от расписания выполнения работ, а именно от привязки работ к вычислительным модулям. Другими словами, применение первого подхода возможно, когда в качестве исходных данных для алгоритмов [5 – 7] задается множество сообщений, которые подлежат планированию, содержащее все сообщения из графа G, и время передачи каждого сообщения известно для наихудшего случая размещения работ, взаимодействующих через это сообщение (т.е. максимально возможное время передачи сообщения). Такое определение исходных данных для алгоритма построения расписания сообщений может привести к тому, что для ряда индивидуальных задач существует полное совместимое расписание , но алгоритм, разработанный на основе первого подхода, такое расписание построить не может в принципе. Это утверждение может быть доказано путем приведения примера такой индивидуальной задачи.
Для решения задачи построения расписания работ в рамках первых двух подходов граф G должен быть преобразован в граф работ G', который содержит только вершины–работы, ребра определяют отношение частичного порядка на множестве работ. Если в графе G есть ребро (работа i, сообщение j) и ребро (сообщение j, работа k), то в графе G' есть ребро (работа i, работа k). Для каждой работы графа заданы: время выполнения работы, директивный интервал, множество вычислительных модулей, на которых может выполняться работа. Существуют алгоритмы, решающие данную задачу, но основная проблема их использования следующая: алгоритм должен строить расписание работ так, чтобы по минимуму сужались директивные интервалы сообщений. Для ряда индивидуальных задач при существовании полного совместного расписания сужение директивных интервалов сообщений может привести к тому, что используемый алгоритм не будет находить полного решения.
Третий подход заключается в рассмотрении сообщений как своеобразных работ, а среды передачи данных – как процессора с технологическими ограничениями. В таком случае для построения алгоритма решения задачи можно использовать известные алгоритмы, в том числе основанные на:
жадной схеме [8], когда каждой работе (и сообщению) сопоставляется приоритет, согласно которому на каждой итерации алгоритма выбирается очередная работа для размещения в расписание; такой подход обеспечивает минимальную временную сложность, однако не всегда гарантирует нахождение точного решения;
методе ветвей и границ [9], который гарантирует нахождение точного решения задачи, а также позволяет учесть любые дополнительные ограничения на расписание, но, с другой стороны, метод обладает большой вычислительной сложностью; отдельной задачей является разработка процедуры оценки верхних и нижних границ для оптимального значения решения на подобласти дерева поиска;
методе имитации отжига [10] или генетических алгоритмов [11], которые не гарантируют нахождения точного решения, их применение требует тонкой настройки параметров (размер популяции, схема понижения температуры и т.п.) и разработки специализированных операций преобразования текущего приближения расписания (создание таких операций становится проблематичным для случая, когда заданы индивидуальные директивные интервалы работ и их нарушение недопустимо).
Все они требуют значительной модификации, но такой подход лишен основного недостатка первых двух подходов – сужения директивных сроков работ и сообщений.
Четвертый подход предполагает модификацию известного метода критического пути [12], который заключается в следующем:
1) найти в графе G самый длинный путь (критический путь); под длиной пути понимается суммарный вес вершин его составляющих или их количество,
2) запланировать одновременно все вершины из найденного пути на один и тот же процессор,
3) исключить из графа все вершины из найденного пути и дуги, которым эти вершины инцидентны,
4) повторять с п.1, пока не будет построено полное расписание.
Сложность адаптации обусловлена наличием вершин двух типов: вершин-работ и вершин-сообщений, а также заданием для вершин-работ набора вычислительных модулей, на которое допустимо назначение работы для выполнения. В составе критического пути могут присутствовать вершины разных типов и вершины работы, которые не могут быть запланированы на один вычислительный модуль.
3. Алгоритм совместного построения совместимых расписания выполнения работ и передачи сообщений. Предлагаемый алгоритм является жадным и относится к классу конструктивных алгоритмов, которые на каждом шаге достраивают частичное расписание, добавляя в него работы и сообщения. Главная проблема построения конструктивных алгоритмов – следующая особенность задачи: точная длительность передачи сообщения становится известной только после планирования (а точнее, привязки к вычислительным модулям) работ, получающих данное сообщение. Вместе с тем для любого неполного (и полного тоже) расписания можно вычислить минимальное и максимальное возможные значения времени передачи сообщения. Предлагаемый подход состоит в том, что длительность передачи сообщения считается равной максимально возможной (для данного сообщения при возможно неполной привязке работ на момент планирования). После размещения в расписание каждой работы просматриваются ранее запланированные сообщения на предмет изменения расчетной длительности передачи. На каждой итерации выбор очередной работы или сообщения для планирования происходит только среди тех, для которых уже запланированы все предшественники.
В процессе работы алгоритма ведётся список работ и сообщений, которые алгоритм не может запланировать, а также упорядоченный список PL, хранящий порядок, в котором работы или сообщения добавлялись в расписание. Ниже приведена укрупненная схема одной итерации алгоритма, в которой отражены принцип построения и основные особенности алгоритма. Детальная схема алгоритма с выделением основных операций и описанием алгоритмов их выполнения приведена в Приложении. Перед началом каждой итерации известно текущее неполное расписание. В результате выполнения итерации получается  расписание, содержащее дополнительную работу или сообщение, или становится известна точная длительность передачи ранее запланированного сообщения. Одна итерация алгоритма может быть представлена следующей схемой.
1. Вычисление с учетом текущего расписания минимально возможного времени размещения сообщения на канале и минимально возможных времен размещения работ на вычислительных модулях, вычисленные значения составляют список : одно значение для каждого модуля и одно значение для среды передачи данных. 
2. Выбор из списка  минимальных значений, составление из них списка .
3. Построение множества C незапланированных работ и сообщений, которые могут начать выполняться (передаваться) в какой-либо точке из списка  (во время равное значению элемента списка и на модуле, которому соответствует это значение). Работа (сообщение) может начать выполняться (передаваться) во время t, если уже начался её директивный интервал () и завершились все предшественники (для работ: , для сообщений: ).
4. Выбор очередной работы или сообщения из множества C по жадному критерию. Значение жадного критерия вычисляется для всех возможных пар <работа из множества C, вычислительный модуль> и для всех сообщений из множества C. Множество вычислительных модулей в паре для работы i является пересечением множества  и множества модулей, соответствующих элементам . Обозначим выбранную работу или сообщение как j, вычислительный модуль (для работы) – как q.
5. Размещение очередной работы или сообщения в расписание и добавление её в конец упорядоченного списка PL размещенных работ и сообщений.
6. Если была размещена работа j, то для всех сообщений из множества  проверяем выполнение условий:
6.1) запланированы все работы из множества , : если да, то переход к п. 6.2, иначе к – п. 6.5,
6.2) изменилась ли максимально возможная длительность передачи сообщения k: если да, то переход к п. 6.3, иначе – к п. 6.5,
6.3) привязка работ из множества  к вычислительным модулям, на которых они выполняются, т.е. множество допустимых модулей сокращается для работ из множества  до одного вычислительного модуля. Удаление из расписания передачи сообщений и выполнения работ тех сообщений и работ, которые в списке PL находятся после k,
6.4) перепланирование сообщения k с учетом известной длительности передачи; переход к п. 1,
6.5) если все сообщения из множества  были обработаны, то переход к п. 1, иначе переход к п. 6.1 для следующего сообщения из множества .
В п. 6.3 происходит переход от текущего расписания к расписанию, которое было перед планированием сообщения k. Ранее предполагалось, что сообщение имеет максимально возможную длительность передачи, теперь же работы из множества , которые влияют на длительность передачи, привязаны к конкретным вычислительным модулям, и длительность сообщения k фиксирована. Если далее в процессе работы алгоритма будет выполнен п. 6.3 для сообщения, которое было запланировано раньше k, то множества допустимых вычислительных модулей для работ из  будут восстановлены в исходное состояние.
Жадные критерии. Свойства алгоритма сильно зависят от применяемого жадного критерия. Для добавления в расписание на каждой итерации выбирается работа или сообщение, имеющее максимальное (или минимальное) значение определенного критерия. Таких критериев можно предложить несколько:
минимальный директивный срок завершения (известен в литературе как EDF): ;
минимальное раннее время завершения (рассмотрен в [1]):  и ;
минимальное количество работ и сообщений, которые не смогут быть запланированы после размещения данной работы или сообщения в расписание;
максимальное количество непосредственных потомков:  и ;
максимальное общее количество потомков;
минимальный директивный срок завершения среди всех потомков;
максимальная длина пути (в количестве вершин) до потомка, у которого нет своих потомков.
Критерий может быть многоуровневым. Если по одному из критериев работы и/или сообщения не различаются, то можно сравнить их по-другому. Среди этих критериев нет универсального или такого, который для общей задачи дает лучший результат, чем любой другой. Для каждого критерия есть своя область эффективного применения. Например, широкую область применения имеет критерий «минимальный директивный срок завершения». Но он неприменим для задач с единым директивным сроком для всех работ и сообщений. Следующий пример иллюстрирует случай, когда критерий «минимальное раннее время завершения» показывает лучше результат, чем критерий «минимальный директивный срок завершения». Характеристики пяти работ приведены в табл. 1, в системе два процессора.
При использовании критерия «минимальный директивный срок завершения» запланированы будут только первые две работы (на разные процессоры), три другие не смогут быть выполнены в рамках своих директивных сроков. При использовании же критерия «минимальное раннее время завершения» запланированы будут третья, четвертая и пятая работы. Полное расписание все равно не будет построено, но с точки зрения критерия оптимальности расписания такое решение будет лучше.
4. Экспериментальное исследование. Для исследования алгоритма было случайным образом составлено три комплекта наборов исходных данных, для которых возможно построение полного расписания. В состав всех наборов входит 300 работ, 100 сообщений и четыре процессора одинаковой производительности. Длительность выполнения каждой работы лежит на отрезке от 500 до 1500 мс. Количество слов данных в каждом сообщении лежит на отрезке от 1 до 32 (длительность передачи – от 104 до 724 мс). Длительность интервала планирования равна 500000 мс. Характеристики среды обмена следующие: мс,  и мс. В первом комплекте исходных данных отношение длительности работы или сообщения к длительности директивного интервала равно 0.1, во втором – 0.5, в третьем – 0.8. Для каждого набора исходных данных осуществлялось два запуска алгоритма с разными жадными эвристиками – минимальный директивный срок завершения (колонка EDF) и минимальное раннее время завершения (колонка ETF). Результаты представлены в табл. 2, в которой w – количество запланированных работ; m – количество запланированных сообщений; t – время работы алгоритма (процессор – Core2Duo 3ГГц); r – количество выполнений пункта 6.3 схемы итерации алгоритма (количество «возвратов»); n – количество добавлений работ и сообщений в расписание, из-за наличия возвратов составления расписания это число может превосходить суммарное количество работ и сообщений.
Величина n может являться мерой вычислительной сложности алгоритма на том или ином наборе исходных данных. Индексы min, max и avg указывают соответственно на минимальное, максимальное и среднее значение для комплекта наборов исходных данных.
Проведенные исследования показывают, что из двух выбранных жадных критериев лучшие результаты показывает критерий «минимальный директивный срок завершения». При этом при уменьшении длительности директивных интервалов результаты применения каждого из критериев ухудшаются. Это связано с тем, что при применении этих эвристик не делается обоснованный выбор процессора, на который размещается очередная работа. Полученные данные позволяют утверждать, что критерий «минимальный директивный срок завершения» пригоден для частных задач со  средним отношением времен выполнения к длительности директивных интервалов меньшим 0.1 и не пригоден для частных задач с большим значением отношения.
Заключение. В данной статье была сформулирована задача совместного планирования вычислений и обменов, возникающая при проектировании информационно–управляющих распределенных систем реального времени. Описаны основные её особенности, отличающие её от других задач построения расписаний. Были рассмотрены две известные из литературы близкие постановки задач и методы их решения. Для первой алгоритм решения основывается на методе ветвей и границ, для второй – на методе имитации отжига. Показаны отличия от рассматриваемой задачи совместного планирования, препятствующие непосредственному применению алгоритмов из этих работ. Среди таких отличий для обеих работ можно назвать наличие у сообщений только одного получателя и отсутствие поддержки ограничений корректности на все расписание сообщений (технологических ограничений). Таким образом, показано, что требуется разработка новых алгоритмов для решения рассматриваемой задачи совместного планирования вычислений и обменов. Далее были рассмотрены возможные подходы к построению алгоритмов и проанализированы сложности, возникающие при их применении. Выделены два подхода, допускающие построение алгоритмов, которые принципиально не исключают возможность нахождения алгоритмом оптимального решения для любой индивидуальной задачи: 1)подход, основанный на рассмотрении сообщений как своеобразных работ, а среды передачи данных – как процессора с технологическими ограничениями, 2)подход, основанный на идеях метода критического пути. В последних двух разделах был описан разработанный в рамках первого подхода жадный алгоритм решения поставленной задачи и проведено его экспериментальное исследование.
СПИСОК ЛИТЕРАТУРЫ
1. Peng D.-T., Shin K. G., Abdelzaher T. F. Assignment and scheduling of communicating periodic tasks in distributed real-time systems // IEEE Trans. Software Engineering. 1997. V.23(12). P. 745–758.
2. Cheng S., Agrawala A. Allocation and scheduling of real-time periodic tasks with relative timing constraints // Proc. Second Intern. Workshop on Real-Time Computing Systems and Applications. Tokyo, Japan. 1995.
3. Теория расписаний и вычислительные машины / Под ред. Э.Г. Коффмана. М.: Наука, 1984. 334 с.
4. Liu C. L., Layland J. W. Scheduling algorithms for multiprogramming in a hard-real-time environment // J. ACM. 1973. V.20(1). P. 46–61.
5. Костенко В.А., Гурьянов Е.С. Алгоритм построения расписаний обменов по шине с централизованным управлением и исследование его эффективности // Программирование. 2005. №6. С. 340-346.
6. Костенко В.А. Алгоритмы построения расписаний для одноприборных систем, входящих в состав систем реального времени // Методы и средства обработки информации: Тр. Третьей Всероссийск. научн. конф. М.: Издательский отдел факультета ВМиК МГУ; МАКС Пресс, 2009. С. 245-258.
7. Balashov V.V., Balakhanov V.A., Kostenko V.A. et al. A technology for scheduling of data exchange over bus with centralized control in onboard avionics systems // J. Aerospace Engineering. 2010. V. 224. №9. P. 993–1004.
8. Кормен Т., Лейзерсон Ч., Ривест Р. Алгоритмы: построение и анализ. М.: МЦНМО, 2000.
9. Land A. H., Doig A. G. An Automatic Method for Solving Discrete Programming Problems. // Econometrica. 1960. V. 28. P. 497-520.
10. Kirkpatrick S., Gelatt C., Vecchi M. Optimization by Simulated Annealing // Science. 1983. V. 220. P. 671-680.
11. Holland J.N. Adaptation in Natural and Artificial Systems. Ann Arbor, Michigan: Univ. of Michigan Press, 1975.
12. Kelley J., Walker M. Critical-path planning and scheduling // Proc. Easter Joint Comput. Conf. Boston, USA 1959. P. 160–173.
ПРИЛОЖЕНИЕ
Детальное описание алгоритма. Введем следующие структуры, которые будут заполняться в процессе работы алгоритма:
order – упорядоченный список работ и сообщений показывает, в каком порядке они добавлялись в расписание;
banned – множество работ и сообщений, которые алгоритм не сможет запланировать в текущее неполное расписание, каждому элементу множества сопоставлен атрибут – последнее сообщение, которое было запланировано перед добавлением элемента в это множество;
unsched – множество сообщений, которые алгоритм не сможет запланировать в принципе, сообщения из этого множества больше не рассматриваются как кандидаты на добавление в расписание;
workModule – множество работ, каждой из которой сопоставлено два атрибута – единственный вычислительный модуль, на который возможно планирование этой работы, и последнее сообщение, которое было запланировано перед добавлением элемента в множество;
unfinished – множество сообщений, запланированных с расчетной длительностью, каждому элементу множества сопоставлен атрибут – расчетная длительность, с которой было запланировано сообщение;
finished – множество сообщений, каждому из которых сопоставлен атрибут – известная длительность сообщения;
H – строящееся алгоритмом расписание, везде, где подразумевается какое-либо расписание, подразумевается расписание H.
Отметим, что всегда . Если в процессе работы алгоритма требуется узнать длительность передачи сообщения, то в первую очередь проверяется принадлежность сообщения одному из этих двух множеств. В случае если сообщение принадлежит одному из множеств, то его длительность считается равной приписанному в данном множестве атрибуту.
Процедура earliestTimeWork.
Входные данные: i – работа.
Выходные данные: t – самое раннее время, на которое возможно планирование работы i в расписание H; p – вычислительный модуль, допускающий планирование работы w на время t.
Схема выполнения процедуры.
Шаг 1. Если хотя бы один элемент из множеств  или  не запланирован в расписании H, то , p – произвольный модуль, конец.
Шаг 2. Если работа i содержится в множестве workModule (), то p – приписанный ей атрибут, t – время, когда завершаются все запланированные на модуль p работы, , перейти на шаг 4, иначе – на шаг 3.
Шаг 3. Рассмотреть множество допустимых для i модулей (множество ), t – время, когда завершаются все работы, запланированные хотя бы на один модуль из , , p – произвольный модуль из , на котором достигается значение t.
Шаг 4. Пусть  - время, когда завершаются все предшественники w.
Шаг 5. , конец.
Процедура earliestTimeMessage.
Входные данные: j – сообщение.
Выходные данные: t – самое раннее время, на которое возможно планирование сообщения j в расписание H.
Схема выполнения процедуры. Аналогично процедуре earliestTimeWork с проверкой ограничений на корректность расписания сообщений: добавление сообщения в конец цепочки сообщений не должно приводить к нарушению требований к максимальной длительности цепочки и максимальному количеству сообщений в цепочке; если сообщение будет первым в цепочке, то промежуток времени после конца последней цепочки должен быть не меньше минимального интервала.
Процедуры banWork и banMessage. Данные процедуры добавляют заданную работу или заданное сообщение соответственно и всех её или его потомков во множество «непланируемых» (множество banned).
Процедура getCandidatesAndBan. Данная процедура вычисляет наименьшее время, на которое возможно планирование работ и/или сообщений в расписании H, а также находит работы и сообщения, которые могут быть запланированы на это время. Для работ дополнительно указывается модуль, который позволяет планировать на полученное время. Если работу или сообщение заведомо не удастся запланировать, то для неё выполняется banWork или banMessage.
Выходные данные: time – самое раннее время, на которое возможно планирование работ и/или сообщений в расписание H; candsW – множество работ, которые можно запланировать на время time, каждой работе из набора сопоставлен атрибут – модуль, который позволяет такое планирование; candsM – множество сообщений, которые можно запланировать на время time.
Схема выполнения процедуры.
Шаг 1. Инициализация:
1) ;
2) ;
3) .
Шаг 2. Для каждой незапланированной работы , такой, что  и запланированы все предшественники (работы из  и сообщения из ):
1) пусть ;
2) если , то и перейти на шаг 2.д;
3) если , то:
i) ;
ii) ;
iii) ;
iv) добавить в candsW работу i с атрибутом p;
4) если , то добавить в candsW работу i с атрибутом p;
5) перейти к началу шага 2 для следующей незапланированной работы .
Шаг 3. Для каждого незапланированного сообщения , такого, что  и запланирована работа-предшественник :
1) пусть ;
2) если , то и перейти на шаг 3.д;
3) если , то:
i) ;
ii) ;
iii) ;
iv) добавить в candsM сообщение j;
4) если , то добавить в candsM сообщение j;
5) перейти к началу шага 3 для следующего незапланированного сообщения .
Шаг 4. Конец.
Процедура rollback. Данная процедура осуществляет возврат процесса планирования на тот момент, когда было запланировано заданное сообщение, с возможной привязкой работ-потомков к конкретным вычислительным модулям.
Входные данные: j – запланированное сообщение; bind – признак, определяющий будет ли осуществляться привязка работ-потомков к вычислительным модулям.
Схема выполнения процедуры.
Шаг 1. Если установлен признак bind, то для каждой запланированной работы i – потомка j (): добавить i в множество workModule с атрибутом – модулем, на который запланирована работа i.
Шаг 2. Если последний элемент списка order является сообщением k, то
1) удалить из множества banned все элементы с атрибутом k;
2) если не установлен признак bind или , то удалить из множества workModule все элементы с атрибутом k.
Шаг 3. Если последний элемент списка order работа, то удалить её из множества workModule;
Шаг 4. Если последний элемент списка order совпадает с сообщением j, то конец, иначе удалить из списка order последний элемент и перейти на шаг 2.

Основная схема работы алгоритма:
Шаг 1. Инициализация:
1) ;
2) ;
3) ;
4) ;
5) ;
6) 
7) .
Шаг 2. Для каждого k – элемента множества unsched выполнить banMessage(k).
Шаг 3. Выполнить процедуру getCandidatesAndBan, пусть t, candsW и candsM – результаты её работы.
Шаг 4. Если candsW=Ø и candsM=Ø, то:
1) рассмотреть список order, пусть j – первое нерассмотренное сообщение;
2) если среди потомков j нет работ-подсистем и ни один из потомков не запланирован, то:
i) выполнить rollback(j, false);
ii) удалить j из списка order;
iii) удалить j из расписания H;
iv) добавить j в множество unsched;
v) перейти на шаг 2; 
3) если  и t – её расчетная длительность больше фактической (), то:
i) выполнить rollback(j, true);
ii) перепланировать сообщение j с учетом изменившейся расчетной длительности на время earliestTimeMessage(j);
iii) установить  в качестве атрибута j в множестве unfinished;
iv) перейти на шаг 2;
4) конец.
Шаг 5. Выбрать из множеств candsW и candsM по жадному критерию работу или сообщение, которое будет запланировано следующим.
Шаг 6. Если была выбрана работа i, то:
1) запланировать в расписание H работу i на тот модуль, что сопоставлен ей в множестве candsW на время t;
2) добавить работу i в конец списка order;
3) рассмотреть список order, пусть j – первое нерассмотренное сообщение;
4) если длительность передачи сообщения j определилась, :
i) если сообщение j не укладывается в свой директивный срок, , то:
1) выполнить rollback(j, false);
2) удалить j из списка order;
3) удалить j из расписания H;
4) выполнить banMessage(j);
5) перейти на шаг 2;
ii) добавить сообщение j в множество finished с атрибутом ;
iii) удалить сообщение j из множества unfinished, пусть t – атрибут j в этом множестве;
iv) если фактическая длительность передачи сообщения меньше расчетной, , то:
1) выполнить rollback(j, true);
2) перепланировать сообщение j с учетом изменившейся расчетной длительности на время earliestTimeMessage(j);
3) перейти на шаг 2.
Шаг 7. Если было выбрано сообщение j, то:
1) запланировать в расписание H сообщение j на время t;
2) добавить сообщение j в конец списка order;
3) если длительность передачи сообщения точно известна, , то добавить сообщение j в множество finished с атрибутом ;
4) иначе добавить сообщение j в множество unfinished с атрибутом .
Шаг 8. Если остались незапланированные работы или сообщения, то перейти на шаг 3, иначе конец.
Таблица 1. Пример для критерия «минимальное раннее время завершения»
Работа



1
0
3
3
2
0
3
3
3
0
4
2
4
0
4
2
5
0
4
2

Таблица 2. Результаты экспериментального исследования
№
1
2
3

EDF
ETF
EDF
ETF
EDF
ETF

289
280
249
247
233
232

300
300
269
268
261
259

297.96
295.26
259.64
257.34
248.08
247.28

90
84
56
56
45
47

100
100
80
81
75
73

98.06
96.68
69.32
67.98
62.9
62.38

6
3
40
17
39
32

644
414
2192
3698
2540
1963

61.54
54.86
463.96
433.36
471.76
365.02

3
1
63
37
61
57

756
817
5596
6086
7937
5233

86.88
91.56
968.86
878.18
1096.86
758.64

637
441
3290
1589
3037
2375

36189
34917
131572
182555
184233
131932

4924.52
5154.84
30952.74
29111.02
32314.28
24001.2

Подрисуночные подписи к статье «Жадный алгоритм совместного планирования вычислений и обменов в системах реального времени» В. А. Костенко и П. Е. Шестова.

Рисунок. Граф зависимости работ и сообщений
ТиСУ №3-12
Рисунок к статье «Жадный алгоритм совместного планирования вычислений и обменов в системах реального времени» П. Е. Шестова и В. А. Костенко
Костенко В.А., Гурьянов Е.С. Алгоритм построения расписаний обменов по шине с централизованным управлением и исследование его эффективности // Программирование. - 2005. - №6 - С.67-76.
АЛГОРИТМ ПОСТРОЕНИЯ РАСПИСАНИЙ ОБМЕНОВ ПО ШИНЕ С ЦЕНТРАЛИЗОВАННЫМ УПРАВЛЕНИЕМ И ИССЛЕДОВАНИЕ ЕГО ЭФФЕКТИВНОСТИ

Костенко В.А., Гурьянов Е.С.

Факультет ВМиК МГУ им. М.В. Ломоносова, Россия
119992, Москва, ГСП-2, Ленинские горы, МГУ, 2-й уч. корпус, ф-т ВМиК, 
тел.: (095) 939-46-71, Email: kost@cs.msu.su


Введение

В некоторых системах реального времени и, в частности, в бортовых системах часто возникает проблема построения статического расписания обменов по централизованному каналу обменов (шине). Как правило, оконечными устройствами шины являются различные процессоры, датчики, контролирующие устройства. Они обмениваются (обычно периодически) результатами измерений и управляющей информацией.
Расписание, по которому происходят такие обмены, формируется статически и не может быть изменено динамически (в ходе работы системы). В соответствии с ним разрабатываются канальные программы обменов.
При построении расписания должны быть учтены различные виды ограничений, которые определяются допустимыми режимами работы конкретной бортовой системы и типом контроллера шины. Примерами таких ограничений являются максимально допустимая длина цепочки работ, следующих непрерывно друг за другом, и минимально необходимый интервал времени между цепочками работ, на котором не запланированы никакие обмены.
Для построения расписания обменов разработан эвристический алгоритм, допускающий настройку на ограничения, определяемые конкретной бортовой системой. Основные принципы построения алгоритма были кратко сформулированы в работе [1]. В основу алгоритма положены жадный принцип распределения работ в расписание в соответствии с локальным критерием "самый ранний срок возможного завершения выполнения работы" и проверка на каждом шаге оптимальности этого критерия. Если этот критерий на некотором шаге не является оптимальным, то осуществляется вызов эвристической процедуры выбора очередной работы для размещения в расписание. 
На каждом шаге алгоритма (после размещения очередной работы в расписание) вычисляется ближайший такт шины, с которого может выполняться следующая работа и соответственно корректируются допустимые временные интервалы для выполнения еще не распределенных в расписание работ. Учет ограничений, определяемых режимом работы бортовой системы и типом контроллера шины, осуществляется введением процедур проверки выполнения ограничений на каждом шаге алгоритма и корректировкой в соответствии с условиями ограничений ближайшего такта шины, с которого может выполняться следующая работа. 
В данной работе также приведены условия для исходных данных, при которых алгоритм строит оптимальные расписания и результаты экспериментального исследования алгоритма.


Постановка задачи построения расписаний обменов по шине с централизованным управлением

Краткое описание системы и протокола работы шины

В данном подразделе приведем пример конкретной бортовой системы и протокола работы шины. Описание системы и протокола работы шины ограничим уровнем детализации необходимым лишь для понимания формальной постановки задачи построения расписаний обменов по шине с централизованным управлением.
Система состоит из единственного канала обмена (шины) и ограниченного набора оконечных устройств, подключенных к этому каналу, которые являются источниками/приемниками информации, передаваемой по шине. Одно из оконечных устройств назначается контроллером шины, который управляет обменом информации и осуществляет контроль состояния других оконечных устройств. Эти оконечные устройства лишь выполняют адресованные им команды контроллера. Обмен информацией осуществляется асинхронно путем поочередной передачи информации по принципу "команда-ответ". Информация передается в виде сообщений, которые могут состоять из командных слов, слов данных и ответных слов.
В дальнейшем будем полагать, что форматы сообщений соответствуют стандарту MIL [2]. Стандарт MIL допускает основные и групповые форматы сообщений. Форматы основных сообщений используются для передачи информации одному из оконечных устройств и предусматривают выдачу им ответного слова. Форматы групповых сообщений используются для передачи информации одновременно нескольким оконечным устройствам без выдачи ими ответных слов. Последняя группа форматов обеспечивает понижение загрузки шины, но при этом снижается надежность. Если требуется подтверждение факта приема оконечным устройством группового сообщения, то контроллер в этом случае (используя формат основного сообщения) может послать оконечному устройству команды “передать ответное слово” или “передать последнюю команду”, и факт приема группового сообщения может быть установлен контроллером путем анализа в ответном слове признака “принято групповое сообщение”. Каждый формат определяет количество и порядок следования командных слов, ответных слов и слов данных. Ниже приведены примеры форматов одиночного сообщения (рис.1) и группового сообщения (рис.2) (КС – командное слово, ОС – ответное слово, СД – слово данных, t1, t2 – паузы).
	Одиночное сообщение (передача данных от оконечного устройства оконечному устройству).



Рис.1. Пример формата одиночного сообщения.

Контроллер должен без паузы передать команду обмена данными с адресом оконечного устройства А на прием данных и команду обмена данными с адресом оконечного устройства Б на передачу данных. Оконечное устройство Б после установления факта достоверности принятой команды должно передать без пауз ответное слово и указанное в команде количество слов данных. Оконечное устройство А после установления факта достоверности адресованной ему информации должно передать ответное слово.
	Групповое сообщение (передача данных от оконечного устройства оконечным устройствам).



Рис.2. Пример формата группового сообщения.
Контроллер должен передать без паузы групповую команду обмена данными на прием данных и команду обмена данными с адресом одного оконечного устройства на передачу данных. Это оконечное устройство после установления факта достоверности принятого командного слова должно передать без пауз ответное слово и указанное в команде количество слов данных.

Формальная постановка задачи построения расписания обменов по шине

Шина в данной системе может рассматриваться как одноприборное устройство, обслуживающее исходно заданный набор работ: . Для каждой работы известны: 
ti - время ее выполнения (оно однозначно определяется количеством слов и пауз в сообщении, соответствующем данной работе, и частотой работы шины); 
 - директивные сроки (директивный интервал) , в течении которых работа должна быть выполнена, т.е. передано соответствующее работе сообщение по шине (директивные сроки определяются требованиями работы в реальном масштабе времени оконечных устройств).
В дальнейшем будем полагать, что .
Расписание обменов по шине – это упорядоченный список непересекающихся по времени выполнения работ, в котором каждая работа определяется временем старта и временем окончания:
, где i, j - порядковые номера работ в расписании.
Для формулировки дополнительных ограничений на расписание, определяемых допустимыми режимами работы бортовой системы и типом контроллера шины, введем понятие цепочки работ. Цепочка работ – это последовательность работ, следующих непрерывно друг за другом, т.е. .
Расписание обменов корректно, если выполнены следующие дополнительные ограничения:
1. Длина любой цепочки работ в расписании не превосходит исходно заданной максимально допустимой длины k*.
2. Cвободный интервал времени (не запланированы никакие обмены) между любыми двумя последовательными цепочками работ не меньше исходно заданной минимально необходимой величины t*.
Первое ограничение определяется объемом буфера сообщений у контроллера шины, второе - необходимостью обработки внештатных ситуаций, которые могут возникнуть в ходе работы бортовой системы (например, восстановимый отказ одного из оконечных устройств).
Критерием оптимальности расписания (целевой функцией) является максимальное число работ (из исходно заданного набора), размещенных в расписание без нарушения ограничений. Расписание SP является оптимальным, если для любого другого расписания , построенного на тех же исходных данных, количество размещенных работ в  не превосходит количества размещенных работ в расписании SP.
Данная задача относится к классу задач построения расписаний без прерываний для детерминированных систем обслуживания с одним прибором [3-5]. Однако она имеет отличия от постановок задач рассматриваемых в теории расписаний. Постановки задач, обычно рассматриваемые в теории расписаний [3-5], предполагают, что:
директивные сроки, в течении которых работа ai должна быть выполнена, задаются как , т.е. допустимые времена старта всех работ одинаковы,
нет дополнительных ограничений на корректность расписания.
Также наиболее распространенным случаем является случай, когда целевая функция задается как сумма "штрафов" или максимальное значения "штрафа" по всем работам при нарушении директивных сроков выполнения работ. В этом случае целевая функция является неубывающей кусочно-непрерывной функцией, что позволяет строить оптимальные алгоритмы полиномиальной сложности для решения задач построения расписаний с такой целевой функцией.
В работе [6] приведен оптимальный жадный алгоритм построения расписаний для системы работ с индивидуальными директивными сроками как для старта, так и для завершения работ и с целевой функцией "максимальное число работ (из исходно заданного набора) размещенных в расписание без нарушения директивных сроков". Однако при этом должно выполняться условие , а также недопустимы дополнительные ограничения.
Предлагаемый в следующем разделе алгоритм позволяет снять ограничения, типичные для известных алгоритмов теории расписаний. Актуальность разработки такого алгоритма обусловлена необходимостью решения практических задач построения расписания обменов по шине с централизованным управлением.


Алгоритм построения расписания обменов

Введем обозначения и предикаты, которые потребуются для описания алгоритма.
Предикат intersect – пересечение директивных сроков двух работ:
.
Предикат compatible – совместимость двух работ:
, здесь  - самый ранний срок возможного завершения работы i,  - самый поздний срок возможного начала работы i.
Обозначим через  ближайший такт шины, с которого может выполняться очередная работа.
Алгоритм построения расписаний обменов (А1) можно представить следующей схемой:
1. Вызов процедуры разбиения списка работ SW на непересекающиеся по директивным срокам списки работ {SW1, SW2, SW3, …,  SWn}. Для любой пары списков SWi, SWj верно следующее условие:  "директивные сроки работ am, an не пересекаются".
Это позволяет свести исходную задачу к нескольким независимым подзадачам. Дальнейшие операции выполняются для каждой такой подзадачи.
2. Упорядочивание списка SWi по самому раннему сроку завершения f*. Задания с одинаковым временем завершения располагаем в произвольном порядке.
3. Жадный выбор из списка SWi: выбирается работа a0.
4. Вызов процедуры проверки дополнительных ограничений на корректность расписания при условии, что работа a0 будет добавлена в расписание. Если ограничения не выполнены – переходим к п.8.
5. Проверка оптимальности жадного выбора:

Если условие выполнено – переходим к п.7.
6. Вызов процедуры выбора работы из списка SWi для размещения в расписание (результат работы процедуры - номер работы, которая должна быть размещена в расписание на данном шаге алгоритма). На каждой итерации своей работы данная процедура осуществляет проверку дополнительных ограничений (аналогично п.4).
7. Перемещение выбранной в п.3 или п.6 работы (работа aj) из списка SWi в расписание SP. При этом полагаем: 
8. Вычисление ближайшего такта шины () с которого может выполняться следующая работа.
9. Корректировка директивных сроков каждой работы списка SWi:
1) если , положить ;
2) если , удалить работу из списка SWi.
10. Если список SWi не пуст, то переходим к п.2. Иначе – завершение работы алгоритма.

Пусть l – длина текущей цепочки работ в тактах,  - работа-кандидат на размещение в расписание.
Процедура проверки дополнительных ограничений на корректность расписания работает следующим образом:
если scur =  (директивное время старта текущей работы совпадает с ближайшим свободным тактом шины), проверить:  (текущая длина цепочки не будет превосходить максимально допустимую длину после размещения текущей работы в расписание);
иначе (scur > ), проверить  (в результате размещения текущей работы в расписание образуется пауза, величина которой будет не меньше минимально допустимой).
Процедура определения ближайшего свободного такта шины  работает следующим образом:
Если на предыдущем шаге в расписание была размещена j-я работа, положить . Иначе: если , положить: .
Процедура выбора работы из списка SWi для размещения в расписание может работать в одном из двух режимов: 
в режиме перебора с заданной глубиной, 
в режиме эвристики.
Стандартный алгоритм процедуры перебора.
Как частный случай, глубина может определяться размером списка, т.е. происходит полный перебор. Процедура рассматривает все работы списка, включая те работы, с которыми a0 не имеет пересечения директивных сроков. В результате перебора определяется максимальный набор совместимых работ. Среди всех максимальных наборов выбирается набор с наименьшим временем освобождения шины . В качестве результата процедуры возвращается номер первой работы в таком наборе.
Альтернативный алгоритм процедуры перебора.
1. Обозначим   работу, которая будет меняться на итерациях алгоритма. На первой итерации положим  = a0.
2. Формирование списка работ, имеющих с  непосредственное пересечение директивных сроков. Обозначим этот список буквой S.
3. Запустим по списку S перебор с глубиной n, , где n0 – параметр алгоритма (глубина перебора). В процессе перебора рассматриваются только те цепочки работ, для которых , где  – первая работа цепочки.
В результате перебора определим набор работ максимальной длины. Если таких наборов несколько, то выберем набор с наименьшим временем освобождения шины .
4. Если выбранный набор начинается с работы , тогда алгоритм останавливается и возвращает  в качестве результата.
5. Иначе – ="первая работа выбранного в п.3 набора" и переход к п. 2.
Скорость работы альтернативного алгоритма гораздо выше, чем у стандартного, т.к. в большинстве случаев он за одну итерацию возвращает решение. Следовательно, значительно сокращается множество перебираемых работ.
Алгоритм эвристического выбора.
Для каждой работы вычисляется «штраф за размещение в расписание» - количество работ, которые после размещения данной работы в расписание становятся неразмещаемыми (т.е. гарантированно не могут участвовать в результирующем расписании). Анализ ограничивается только теми работами, которые имеют с a0 непосредственное пересечение директивных сроков. В качестве результата эвристики возвращается номер работы с наименьшим штрафом.
В дальнейшем, в зависимости от используемой процедуры выбора работы для размещения в расписание, будем говорить, что алгоритм работает, соответственно, в режиме ограниченного перебора и в режиме эвристики.


Анализ эффективности алгоритма

Рассмотренный в предыдущем разделе алгоритм в общем случае не гарантирует получения оптимального решения. Однако при введении ограничений на структуру исходных данных (ограничений на взаимное расположения директивных интервалов работ, на совместимость работ при пересечении их директивных интервалов и на время выполнения работ) алгоритм гарантированно получает оптимальные решения при данных ограничениях. В данном разделе приведем пример таких ограничений и докажем оптимальность алгоритма в этом случае.
Будем говорить, что работа  имеет одно вложение, если существует лишь одна работа  из числа остальных работ, для которой выполняется следующее условие:
 .
Будем говорить, что работа имеет не больше двух пересечений,  если существует не более двух различных работ  и  (или хотя бы одна) из числа остальных работ, для которых выполняется следующее условие:
 и/или .
Теорема 1. Если выполнены следующие условия:
1. Каждая работа имеет не более одного вложения.
2. Каждая работа имеет не более двух пересечений (независимо от вложений).
3. Любые две вложенные работы совместимы в порядке (1; 2), где . Если они совместимы и в другом порядке, то требуется дополнительное условие: .
4. Если работы  и  пересекаются и , то ,
то алгоритм А1 построит оптимальное расписание обменов при работе в режиме эвристики.
Доказательство
Так как на структуру исходных данных в условии теоремы наложены жесткие ограничения, которые обеспечивают регулярную структуру взаимного расположения допустимых интервалов выполнения работ (рис. 3), то для доказательства оптимальности работы алгоритма достаточно доказать оптимальность его работы лишь на первых двух фрагментах (они включают в себя работы 1-4). В силу условий 3 и 4 всегда возможен следующий порядок выполнения работ: "1,2,3,4" и этот порядок является оптимальным. В случае другого порядка "2,1,…" возможны случаи когда работы 3 и 4 невозможно одновременно разместить в расписание без нарушения директивных сроков выполнения.



Рис.3. Структура взаимного расположения допустимых интервалов выполнения работ.

На первой итерации алгоритм выберет работу 1 для размещения в расписание. При размещении этой работы ни одна из работ не становится неразмещаемой (работы 1,2 совместимы по условию 3, работы 1,3 совместимы по условию 4). Для работы 3 штраф = 1, т.к. при ее размещении становится неразмещаемой работа 2. Работа 2 не будет выбрана, т.к.  или работы 2,1 несовместимы (условие 3). Далее алгоритм разместит работы 2,3,4. То есть, алгоритм гарантированно расположит работы рассматриваемых фрагментов в оптимальном порядке "1,2,3,4".
Аналогично можно показать оптимальность алгоритма и для более "сложных" условий, которые обеспечивают регулярную структуру взаимного расположения допустимых интервалов выполнения работ.
При определенных условиях алгоритм может отработать оптимально исключительно за счет жадного выбора работ. Пример таких условий показывает следующая теорема.
Теорема 2. Если для каждой итерации основного цикла алгоритма выполнено условие , или нет таких работ, для которых , то алгоритм строит оптимальное расписание обменов.
Доказательство.
Покажем, что существует оптимальное решение задачи, содержащее работу  (работу с наименьшим значением ) и алгоритм выберет ее для размещения в расписание. Поскольку работы в списке SWi упорядочены по самому раннему сроку завершения f*, и по условию теоремы, выполнено условие проверки оптимальности жадного выбора (п.5 алгоритма), то алгоритм выберет для размещения в расписание работу . Если в каком-то оптимальном расписании, работа  не содержится, то можно заменить в нем работу с самым ранним временем возможного завершения (работа ) на работу . Такая замена не нарушит условий совместимости работ и дополнительных ограничений, поскольку , а также не изменит их общего количества. Следовательно, существует оптимальное решение начинающееся с работы , и алгоритм выберет ее для размещения в расписание. 
Далее алгоритм (п.9 алгоритма) удалит все работы не совместимые с работой . После этого задача сводится к построению оптимального расписания из оставшихся работ (совместимых с работой ). То есть задача сведена к аналогичной задаче с меньшим числом работ. Рассуждая по индукции, получаем, что алгоритм строит оптимальное расписание при выполнении условия теоремы.
При выполнении условия теоремы ( или нет таких работ для которых ) все работы будут размещены в расписание обменов в соответствии с жадным выбором.
Что означает для исходных данных выполнение этого условия? Равносильное утверждение сформулировать невозможно, т.к. происходит постоянная корректировка директивных сроков. Но очевидно, что данное условие будет выполнено, если:
,
т.е. директивный интервал каждой работы не пересекается с директивными интервалами других работ, а если пересекается, то эти работы попарно несовместимы. 

Численное исследование алгоритма

Работу алгоритма будем оценивать по следующим критериям:
эффективность работы алгоритма - отношение количества работ в расписании к количеству работ в исходной системе работ (в дальнейшем всегда приводится в %);
количество работ, размещенных в расписание по жадному критерию (в дальнейшем всегда приводится в %).
Будем генерировать заведомо совместимые системы работ без дополнительных предположений о величине директивных интервалов работ (максимальное время работы шины – 1000 тактов; число работ в исходной системе – 50). На рисунках 4 и 5 приведены результаты работы алгоритма в режиме перебора и в режиме эвристики. 

Рис.4. Режим эвристики.

Рис.5. Режим ограниченного перебора.

Следует отметить, что эвристический режим работы алгоритма существенно быстрее режима перебора. Это объясняется тем, что для перебора используется дорогостоящая операция рекурсии. В связи с этим не применялась функция перебора с глубиной более 2, т.к. при большей глубине перебора время работы алгоритма становится неприемлемым. Тем не менее, в ряде задач операция перебора с большой глубиной может дать более хорошее решение, чем эвристика.
Из рисунков видно, что операция жадного выбора применяется относительно редко по сравнению с операцией перебора (эвристического выбора). Это объясняется тем, что директивные интервалы для работ в данном примере генерировались случайным образом по всему отрезку планирования, вследствие чего до 97% директивных интервалов имеют пересечение с директивным интервалом как минимум одной из работ, а это обстоятельство делает невозможным жадный выбор (см. п.5 алгоритма). 
Введем дополнительные предположения о величине директивных интервалов работ (относительно времени их выполнения). Предположим, что в худшем случае директивный интервал в два раза превосходит время, необходимое для выполнения работы. Тогда при тех же допущениях, что в предыдущих случаях, эвристический режим дает результаты приведенные на рисунке 6.

Рис.6. Результаты работы алгоритма при ограничении на исходные данные: "директивный интервал в среднем в два раза превосходит время, необходимое для выполнения работы".

Фиксируем загрузку шины на значении 50% и будем изменять величину отношение директивного интервала к времени выполнения работы. Расположим по оси абсцисс среднее отношение директивного интервала к времени выполнения работы. На рисунке 7 не показана эффективность алгоритма, т.к. она постоянна и в данном случае составляет от 99,9% до100%. Из графика приведенного, на рисунке 7,  видно, что если в исходной системе работ директивные сроки не более, чем в 2 раза превосходят времена выполнения работ, то большинство работ будет размещено в расписание в соответствии с жадным критерием.

Рис.7. Зависимость числа работ, разведенных по жадному критерию, от отношения директивного интервала к времени выполнения работы при загрузке шины равной 50%.


Заключение

Предложенный в данной работе алгоритм построения расписаний обменов по шине с централизованным управлением может быть легко адаптирован и к другим видам ограничений на расписание обменов, которые определяются допустимыми режимами работы и составом аппаратных средств конкретной бортовой системы. Для адаптации алгоритма достаточно лишь добавить процедуры проверки этих ограничений.
Результаты проведенных численных исследований подтвердили высокую эффективность работы алгоритма по критериям "число работ размещенных в расписание" и "время работы алгоритма". При загрузке шины равной 50% алгоритм на всех тестах построил оптимальное расписание обменов. Следует отметить, что для бортовых систем реального времени очень часто накладывается ограничение, что загрузка шины не должна превышать 50%. Приемлемые значения критериев "число работ размещенных в расписание" и "время работы алгоритма". могут быть достигнуты за счет индивидуальной настройки глубины перебора на конкретную специфику исходных данных или использованием специальной эвристики, настроенной на учет специфики исходных данных.
Подчеркнутые выше особенности алгоритма позволяют сделать предположение о эффективности его применения в системах автоматического построения циклограмм обмена по шине с централизованным управлением.


Литература.

1. Костенко В.А., Гурьянов Е.С. Алгоритм построения расписаний обменов по шине с централизованным управлением// Интеллектуализация обработки информации: тезисы докладов Международной научной конференции. - Симферополь: Крымский научный центр НАН Украины, 2004.
2. Государственный стандарт СССР «Интерфейс магистральный последовательный системы электронных модулей» ГОСТ 26765.52-87.
3. В.С. Танаев, В.В. Шкурба. Введение в теорию расписаний. - М.: Наука, 1975.
4. Конвей Р.В., Максвелл В.Л., Миллер Л.В. Теория расписаний. - М.: Наука, 1975.
5. Теория расписаний и вычислительные машины/ Под ред. Э.Г. Коффмана - М.: Наука, 1984.
6. Кормен Т., Лейзерсон Ч., Ривест Р. Алгоритмы: построение и анализ. - М.: МЦНМО, 2002.

В.А. Костенко Проблемы использования результатов теории расписаний для планирования вычислений в системах реального времени // VI Московская международная конференция по исследованию операций (ORM2010). Труды. – М.: МАКС Пресс, 2010. – С.304-306.


Проблемы использования результатов теории расписаний для планирования вычислений в системах реального времени
В.А. Костенко
Фак-т. ВМиК МГУ им.М.В.Ломоносова, Москва
Задача построения расписания может быть представлена как задача комбинаторной оптимизации в следующем виде: 
					(1)
Где H – расписание выполнения заданного набора работ,  - вектор значений требований к расписанию,  - ограничения на корректность расписания,  - модель вычислений, которая позволяет вычислить критерий оптимальности расписания k. Например, представление задачи построения расписаний обменов по каналу с централизованным управлением в виде (1) рассмотрено в работе [1]. 
Можно выделить три основные причины, которые ограничивают применение результатов теории расписаний для планирования вычислений в системах реального времени (ВСРВ): 1)использование в теории расписаний упрощенных моделей вычислений ; 2)учет ограничений на корректность расписания, которые обусловлены особенностями аппаратных и программных средств вычислительной системы (в дальнейшем, технологические ограничения); 3)неприемлемая точность алгоритмов построения расписаний.
Недостаточная точность модели вычислений связана с проблемами оценки времени выполнения работ на процессорах и оценками задержек обусловленных доступом к разделяемым ресурсам (каналам обмена и модулям памяти). В теории расписаний время выполнения работ обычно задается константой зависящей лишь от типа процессора. Однако для современных процессоров время выполнения работы зависит также и от контекста расположения ее в расписании, объема и распределения требуемой работе памяти. Также в большинстве моделей вычислений затраты времени на обмен определяются лишь объемом передаваемых данных и не учитываются затраты времени на арбитраж и ожидание времени освобождения канала. Использование упрощенной модели вычислений приводит к тому, что мы решаем задачу (1) с целевой функцией , которая может существенно отличаться по свойствам и рельефу от функции соответствующей реальной ВСРВ. Обычно  и как следствие получаемые расписания не удовлетворяю требованиям работы в реальном времени.
Задачи с одной и той же целевой функцией и различным набором технологических ограничений могут принципиально отличаться друг от друга и задач с набором ограничений, обусловленных только требованием работы в реальном времени (в теории расписаний обычно рассматриваются только эти ограничения) [1]. Это приводит к тому, что для рассматриваемой задачи построения расписания требуется или существенное изменение известного алгоритма или разработка нового [1].
Большинство задач планирования вычислений в ВСРВ относятся к классу NP-трудных и для их решения используются приближенные алгоритмы. Оценки точности алгоритмов приводятся для общей задачи. Многие алгоритмы являются неприемлемыми по точности для задач с критерием оптимальности «максимальное число работ размещенных в расписание». Однако для конкретной ВСРВ достаточно рассматривать частную задачу (на возможные значения исходных данных налагаются ограничения). Алгоритм неприемлемый по точности для общей задачи очень часто оказывается приемлемым по точности для частной задачи и может быть расширен на решение задач c технологическими ограничениями.
1. Костенко В.А. Алгоритмы построения расписаний для одноприборных систем, входящих в состав систем реального времени// Методы и средства обработки информации: Третья Всероссийская научная конференция. Труды конференции. - М.: Издательский отдел факультета ВМиК МГУ имени М.В. Ломоносова; МАКС Пресс, 2009.-С.245-258. (http://lvk.cs.msu.su/~ashalimov/doc/MCO09_-_part4.pdf).Костенко В.А. Задача построения расписания при совместном проектировании аппаратных и программных средств // Программирование - 2002. - №3 - С.64-80.
ЗАДАЧА ПОСТРОЕНИЯ РАСПИСАНИЯ ПРИ СОВМЕСТНОМ ПРОЕКТИРОВАНИИ АППАРАТНЫХ И ПРОГРАММНЫХ СРЕДСТВ.

Костенко В.А.
Факультет вычислительной математики и кибернетики МГУ
119899, Москва, Воробьевы горы

В работе рассмотрены структуры данных для непосредственного и параметрического представления расписаний и введены соответствующие системы операций коррекции расписаний для построения итерационных алгоритмов. Доказано, что непосредственный и параметрический способы представления расписаний и соответствующие операции коррекции, допускают построение итерационных алгоритмов, обеспечивающих переход от произвольного допустимого расписания к оптимальному за линейное число итераций относительно числа планируемых работ  и исключают возможность получения недопустимых расписаний на всех итерациях алгоритма.

Введение
Можно выделить два базовых варианта задачи совместного проектирования аппаратных и программных средств вычислительных систем (ВС) реального времени:
1) минимизируется время выполнения прикладной программы (расписания выполнения программы) при заданных ограничениях на аппаратные ресурсы (ВС мягкого реального времени);
2) минимизируются аппаратные ресурсы при ограничении времени выполнения прикладной программы (ВС жесткого реального времени).
Частные варианты задачи получаются из базовых, выбором набора варьируемых характеристик аппаратных средств и выбором функции для оценки затрат аппаратных средств. В качестве меры эффективности расписания могут быть использованы и другие критерии: среднее взвешенное время завершения, время ожидания обслуживания, среднее количество процессов, выполненное на заданном временном интервале.
Основной особенностью задачи построения расписания при совместном проектировании аппаратных и программных средств ВС является то, что расписание строится одновременно с синтезом архитектуры (определением оптимизируемых параметров архитектуры). Эффективность и применимость методов построения расписания при совместном проектировании аппаратных и программных средств, кроме точности и вычислительной сложности методов, также определяется:
универсальностью методов построения расписания в классе допустимых архитектур ВС, которые могут быть получены в результате синтеза;
совместимостью методов построения расписания и методов выбора оптимальных параметров архитектуры;
возможностью методов построения расписания строить расписания для архитектур ВС с различным уровнем детализации.
В первом разделе рассматривается понятие инварианта поведения программы, во втором разделе расписание рассмотрено как комбинаторная структура и введены ограничения на расписание, при которых сохраняется инвариант поведения программы. В третьем разделе проведен анализ различных подходов к разработке алгоритмов построения расписания при совместном проектировании аппаратных и программных средств ВС. В четвертом и пятом разделах рассматриваются непосредственные и параметрические способы представления расписания и вводятся функционально полные системы операций коррекции расписаний.

1. Модель прикладной программы
При определении модели прикладной программы предполагаем, что выделение работ, подлежащих планированию, и параллелизм, допускаемый при выполнении программы заданы (выявлены) предварительно.
В качестве модели прикладной программы будем использовать частный случай инварианта поведения программы предложенного в работах [1,2]. Следуя [1], обозначим поведение программы Bh(PR) и определим Bh(PR) следующим образом: Bh(PR) = < S, {R  (PR)}, {R  (PR)}>, где S – множество всех возможных шагов процессов в допустимом диапазоне входных данных программы, {R  (PR)} - отношения, определяющие частичный порядок на множестве шагов каждого процесса, {R  (PR)} - отношения взаимодействия между процессами.
Шаги процесса определяются последовательностью взаимодействий с другими процессами [1]. Назовем рабочим интервалом процесса внутренние действия процесса между двумя последовательными взаимодействиями с другими процессами. Каждый рабочий интервал процесса по существу является реализацией соответствующего шага процесса. 
Для задачи синтеза архитектур будем использовать одну из историй поведения программы H(PR)Bh(PR) [1] (поведение программы для конкретного набора входных данных). Для H(PR) отношение {R  (PR)} является отношением полного порядка, а множество S сужается до множества шагов, которые делают процессы для конкретного набора входных данных.
H(PR) можно представить ациклическим ориентированным размеченным графом. Вершинам соответствуют рабочие интервалы процессов, дугам ={ik=(pi,pk)}(i,k)Î(1...N) - связи, определяющие взаимодействия между рабочими интервалами из множества P (определяются объединением отношений {R(PR)}, {R(PR)}). Где Ni - число рабочих интервалов в i-ом процессе, K - число процессов в программе PR, N=N1+N2+…+NK - мощность множества P. Чередование рабочих интервалов различных процессов, назначенных на один и тот же процессор, допустимо, если не нарушается частичный порядок, заданный . Отношение ik представляется следующим образом: если , то рабочий интервал pi, необходимо выполнить до начала выполнения рабочего интервала pk. На  накладываются условия ацикличности и транзитивности. Каждая вершина имеет свой уникальный номер и метки: принадлежности рабочего интервала к процессу и вычислительной сложности рабочего интервала. Вычислительная сложность рабочего интервала позволяет оценить время выполнения рабочего интервала на процессоре. Дуга определяется номерами смежных вершин и имеет метку, соответствующую объему данных обмена. Объем данных обмена для каждой связи из  позволяет оценить затраты времени на выполнение внешнего взаимодействия.
При сделанных выше допущениях используемый инвариант поведения программы будет частным случаем (одна история) инварианта поведения программы, определенном в [2]. Используемый инвариант поведения определим:
1. Множеством рабочих интервалов процессов, составляющих программу PR:

Нумерация рабочих интервалов является сквозной и удовлетворяет условиям полной топологической сортировки. Каждый рабочий интервал имеет метку принадлежности к процессу.
2. Частичным порядком на P:
={ik=(pi,pk)}(i,k)(1...N);
3. Вычислительной сложностью рабочих интервалов:
;
4. Объемом данных обмена для каждой связи из :
{vik}(i,k)(1...N);.

2. Расписание
Расписание выполнения программы определено, если заданы: 1)множества процессоров и рабочих интервалов, 2)привязка, 3)порядок. Привязка - всюду определенная на множестве рабочих интервалов функция, которая задает распределение рабочих интервалов по процессорам. Порядок задает ограничения на последовательность выполнения рабочих интервалов и является отношением частичного порядка, удовлетворяющим условиям ацикличности и транзитивности. Отношение порядка на множестве, рабочих интервалов распределенных на один и тот же процессор, является отношением полного порядка.
Модель расписания выполнения программы определим набором простых цепей и отношением частичного порядка HP на множестве P: HP=({SPi}i=(1...M) ,HP).
Где {SPi}i=(1...M) -набор простых цепей (ветвей параллельной программы). Они образуются рабочими интервалами процессов, распределенными на один и тот же процессор (M – число процессоров в ВС). Отношение частичного порядка HP на множестве P для HP определим как объединение отношений: HP=c1M, i - отношение полного порядка на SPi, которое определяется порядковыми номерами рабочих интервалов в SPi; c - набор секущих ребер, которые определяются связями рабочих интервалов, распределенных на разные процессоры. Если рабочие интервалы pi и pj распределены на разные процессоры и в  существует связь ij, то она определяет секущее ребро в HP. На отношение HP накладываются условия ацикличности и транзитивности.
Модель расписания можно рассматривать как граф HP, вершины которого имеют дополнительную метку “номер списка”, а дуги определяются отношением HP или как граф H, вершины которого доразмечены двойками: {“номер списка”, “порядковый номер вершины в соответствующем списке”}. В модели HP сохраняются нумерация вершин, дуг и их метки заданные в модели поведения программы H. В дальнейшем при рассмотрении свойств расписаний в некоторых разделах будет использоваться ярусная форма представления расписания [3]. Ярусной формой максимальной высоты будем называть такую ярусную форму, у которой на каждом ярусе находится не более одной вершины.
Ограничения на расписание
Расписание HP является допустимым (сохраняет инвариант поведения программы), если выполнены следующие ограничения:
1. Каждый рабочий интервал должен быть назначен на процессор (в SPi).
2. Каждый рабочий интервал должен быть назначен лишь на один процессор (в один SPi).
3. Частичный порядок, заданный в H сохранен в HP: .
4. Расписание HP должно быть беступиковым. Условием беступиковости является отсутствие контуров в графе HP: .
5. Все рабочие интервалы одного процесса должны быть назначены на один и тот же процессор (в один и тот же SPi).
Ограничения 1-4 обеспечивают сохранение инварианта поведения программы и являются обязательными. Ограничение 5 запрещает возобновление работы процесса после прерывания на другом процессоре, т.е. определяет способ организации параллельных вычислений в ВС, и не всегда является обязательным. В дальнейшем будем говорить, что расписание допустимо , если оно удовлетворяет ограничениям 1-5. Нижний индекс в  указывает ограничения налагаемые на расписание.

3. Анализ различных подходов для решения задачи построения расписаний
Понятия динамических критериев и ограничений
Значения динамических критериев и ограничений для конкретного варианта решения задачи синтеза архитектур ВС могут быть получены из анализа динамики функционирования ВС при выполнении прикладной программы. Для описания динамики функционирования ВС выделен набор состояний рабочих интервалов и аппаратных ресурсов (приложение 1). Динамику функционирования ВС TR будем определять множеством событий привязанных к временной оси, происходящих при выполнении расписания HP, на архитектуре HW. Под событием будем понимать переход любого аппаратного ресурса и рабочего интервала из одного состояния в другое. 
Динамика функционирования ВС может быть получена совместной интерпретацией моделей HW и HP: TR = (HW, HP). Можно выделить следующие основные уровни интерпретации, определяемые набором временных задержек, учитываемых динамически (т.е. величина задержки определяется состоянием системы в конкретный момент времени поступления запроса на ресурс или данные) при вычислении функции TR = (HW, HP):
1. tEP,	tD,
2. tEP,	tD, tEAS,
3. tEP,	tD, tEAS, tSYS,
где tEP- временные задержки, обусловленные занятостью процессоров, tD- ожиданием завершения выполнения предшественников, tEAS- ожиданием получения доступа к разделяемым ресурсам и tSYS- задержки вносимые логической средой и доступом к памяти, которые не могут быть учтены статически.
Для первых двух уровней интерпретации оценка времени выполнения рабочего интервала (время нахождения в состоянии SP_W) по его вычислительной сложности не зависит от расположения рабочего интервала в расписании и может быть получена статически. На первом уровне интерпретации вычислительную сложность рабочих интервалов можно задавать временем выполнения. С учетом отсутствия задержек на получение разделяемых ресурсов в это время можно включить затраты времени на взаимодействие с рабочими интервалами других процессов. На втором уровне интерпретации время нахождения рабочего интервала в состоянии SP_EAS не может быть определено статически.Для третьего уровня интерпретации оценка времени нахождения рабочего интервала в состоянии SP_SPR (ожидание обновления данных в памяти процессора или завершения, вызванного системного процесса) может потребовать знания семантики используемых данных и соответственно может зависить от расположения рабочего интервала в расписании.
Набор динамически учитываемых временных задержек определяет точность вычисления оценок значений динамических критериев и ограничений для различных классов архитектур и чем выше уровень интерпретации, тем выше требуемый уровень детализации представления архитектуры ВС. Например, для полносвязной архитектуры достаточно динамически учитывать лишь задержки tEP, tD, а для архитектур с коммутационной средой, в которой возможно ожидание получения канала связи, динамический учет лишь tEP, tD и статический tEAS будет приводить к неточным оценкам.
В соответствии с данными уровнями интерпретации будем выделять следующие уровни проектирования: 1)абстрактный, 2)системный и 3)уровень регистровых передач.
Независимо от уровня интерпретации, оператор интерпретации всегда должен удовлетворять условию: HP = -1((HW, HP)), т.е. расписание однозначно восстанавливается по динамике функционирования ВС. Расписание HP интерпретируемо, если отношение порядка ациклично и транзитивно, а привязка - всюду определеная функция на множестве процессов. Для выполнения оператора интерпретации, независимо от конкретного варианта постановки задачи синтеза архитектур ВС, всегда должно быть построено расписание выполнения программы HP. Что, собственно говоря, и обеспечивает важность параметра и его присутствие в большинстве вариантов постановки задачи синтеза архитектур.
Задача построения расписания при совместном проектировании аппаратных и программных средств, классы алгоритмов для ее решения
При разработке ВС реального времени можно выделить два базовых варианта задачи совместного проектирования аппаратных и программных средств:
3) минимизируется время T выполнения расписания при заданных ограничениях на аппаратные ресурсы (ВС мягкого реального времени);
4) минимизируются аппаратные ресурсы при ограничении времени выполнения расписания TTdir (ВС жесткого реального времени).
Частные варианты задачи получаются из базовых, выбором набора варьируемых характеристик аппаратных средств и выбором функции для оценки затрат аппаратных средств. В качестве меры эффективности расписания могут быть использованы и другие критерии [4]: среднее взвешенное время завершения, время ожидания обслуживания, среднее количество процессов, выполненное на заданном временном интервале.
В дальнейшем в качестве динамического критерия для определенности будем рассматривать время выполнения расписания: T=f(HP,HW). Функция T=f(HP,HW) задана алгоритмически: правилами/алгоритмами ее вычисления. Выбор наиболее подходящего метода решения определяется как подклассом задачи совместного проектирования аппаратных и программных средств ВС, так и характеристиками функции T=f(HP,HW). Функцию T=f(HP,HW) будем характеризовать:
1) размером моделей HP,HW:
HP: число рабочих интервалов (N), число процессов (K), мощность исходного отношения порядка (), 
HW: число процессоров (M), число разделяемых ресурсов (MEAS), число уровней памяти (MMEM), число вызываемых системных процессов (MSYS);
2) cтруктурой модели H:
тип ,
дисперсия ,
суммарная вычислительная сложность рабочих интервалов и критический путь;
3) набором временных задержек, учитываемых динамически (см. уровни интерпретации):
tEP,	tD,
tEP,	tD, tEAS,
tEP,	tD, tEAS, tSYS;
4) законом распределения значений T: i=(Ti). Значение функции (Ti) равно относительному числу допустимых вариантов расписания для которых значение функции T=f(HP,HW) равно Ti.
В работах [4,5] показано, что почти все задачи построения расписаний являются NP-полными в строгом смысле. В данной работе на вариантах постановки задач построения расписаний, для которых существуют полиномиальные алгоритмы, останавливаться не будем, достаточно полный обзор таких задач и алгоритмов приведен в [4]. Отметим, что большинство таких задач являются практически вырожденными, поскольку на исходные условия накладываются жесткие ограничения: тип исходного отношения – лес или пустое, число процессоров менее трех, одинаковая вычислительная сложность рабочих интервалов, дополнительные ресурсы не допустимы, допустимость прерывания выполнения любого рабочего интервала и возобновление его выполнения на любом из процессоров ВС. Данным ограничениям большинство реальных ВС и программ не удовлетворяют.
Анализ различных подходов к разработке алгоритмов построения расписаний
Возможный широкий спектр частных вариантов задачи и характеристик функции T=f(HP,HW) обуславливает широкий спектр используемых алгоритмов. Алгоритмы построения расписаний можно разбить на три большие группы:
алгоритмы, основанные на декомпозиции задачи составления расписаний на подзадачи (вложении задачи в семейство более простых задач);
алгоритмы, основанные на методе ветвей и границ;
алгоритмы, основанные на коррекции текущего расписания (итерационные алгоритмы).
Алгоритмы, использующие декомпозицию расписаний, могут быть основаны:
на динамическом программировании [6,7];
на жадных стратегиях [8,9,10].
Алгоритмы, основанные на динамическом программировании, требуют введения двух операций: 1)вложение решаемой задачи в семейство более простых задач; 2)нахождение возвратного соотношения, связывающего оптимальные значения этих подзадач. Данные алгоритмы позволяют получить глобальный оптимум, но при этом для большинства задач комбинаторной оптимизации имеют не полиномиальную сложность. В частности, для NP-полных задач составления расписаний сложность алгоритмов – факториальная функция от размера входа (число процессов, число рабочих интервалов и мощность множества исходного отношения частичного порядка).
Какие-либо жадные стратегии, гарантированно получающие оптимальное расписание, на настоящий момент времени не известны, за исключением небольшого числа вариантов задач составления расписаний, которые не принадлежат к классу NP-полных. Все жадные эвристические алгоритмы подразумевают существование критериев оптимизации для решения подзадач (локальных целевых функций). Решение о распределении очередного процесса принимается исходя из принципа получения оптимального расписания на текущем шаге при условии, что расписание, полученное на предыдущем шаге, не может быть изменено. То есть, на каждом шаге алгоритм делает выбор, оптимальный с точки зрения получения частичных расписаний, предполагая, что эти локально-оптимальные решения приведут к приемлемому решению задачи.
Применение жадных алгоритмов для составления расписаний при совместном проектировании аппаратных и программных средств ограничивается [11-14]:
классом архитектур без последействия или даже без разделяемых ресурсов, если их влияние на значение функции T=f(HP,HW) не может быть локализовано;
проблемой выбора локальных целевых функций индивидуально для каждой подзадачи;
жадные алгоритмы построения расписания совместимы с алгоритмами выбора оптимальных параметров архитектуры в рамках метода покоординатного спуска.
Основной областью эффективного применения жадных алгоритмов при решении задачи совместного проектирования аппаратных и программных средств ВС может быть решение задачи “оценка принципиальной возможности построения ВС при заданных ограничениях и сужение класса рассматриваемых архитектур” на абстрактном уровне проектирования ВС. При решении этой задачи структура ВС может рассматриваться как полносвязная и достаточен лишь первый уровень интерпретации. Определяется число процессоров в ВС, строится расписание выполнения программы, определяются требования к коммутационной среде и памяти, и проводится оценка возможности различных способов их реализации при заданных ограничениях.
Алгоритмы, основанные на методе ветвей и границ [4,7], используют разделение пространства возможных решений (представление в форме некоторого разветвления), верхнюю/нижнюю оценку значения целевой функции для выделенных областей и отсечение областей в которых нет оптимального решения. Данные алгоритмы позволяют получить глобальный оптимум, но при этом для большинства задач комбинаторной оптимизации имеют не полиномиальную сложность. В частности, для NP-полных задач составления расписаний сложность алгоритмов – факториальная функция от размера входа.
Алгоритмы, основанные на коррекции текущего расписания, (итерационные алгоритмы) можно разбить на два подкласса:
алгоритмы, опирающиеся на метод проб и ошибок: генетические и эволюционные алгоритмы [15-18], алгоритмы имитации отжига [19,20], алгоритмы случайного поиска (ненаправленного, направленного, направленного с самообучением)[20,21];
алгоритмы детерминированной коррекции расписания.
Схематично работу итерационных алгоритмов для решения задачи построения расписания можно представить следующим образом:
1. Задать начальное приближение HP0, k=0.
2. Вычислить целевую функцию f(HPk,HW) и проверить выполнение ограничений (если в п.3 возможно получение недопустимых значений HP).
3. Получить HPk+1=D({HPi},{f(HPi,HW)},Prk:i(1,,k)).
4. Если заданный критерий останова не достигнут, то k=k+1 и перейти к п.2; в противном - завершить работу алгоритма.
Где, D – некоторая стратегия коррекции текущего расписания, Prk – параметры стратегии (для ряда стратегий, возможно, их изменение в ходе работы алгоритма).
Алгоритмы, опирающиеся на метод проб и ошибок, содержат элементы случайного выбора привязки и порядка, что дает возможность получать информацию о влиянии привязки и порядка на значения целевой функции и ограничений. Данная информация используется для адаптации алгоритма (в ходе его работы) к закону влияния привязки и порядка на значения целевой функции и ограничений. Кроме возможности адаптации к решаемой задаче, алгоритмы, опирающиеся на метод проб и ошибок, наиболее полно удовлетворяют требованиям, к свойствам алгоритмов построения расписания при совместном проектировании аппаратных и программных средств ВС: 1)возможностям методов строить расписания для архитектур ВС с различным уровнем детализации; 2)универсальности методов в классе допустимых архитектур ВС; 3)совместимости методов построения расписания и методов выбора оптимальных параметров архитектуры.
Данные особенности алгоритмов обеспечивают эффективность их использования на системном уровне проектирования: определение числа процессоров, типа каждого процессора (тип процессора характеризуется стоимостью и производительностью), топологии и характеристик компонентов коммутационной среды, распределение памяти (тип – ПЗУ/ОЗУ, объем, способ доступа – локальная/разделяемая, циклы считывания/записи) и построение расписания выполнения прикладной программы.
Алгоритмы детерминированной коррекции расписания для своего построения требуют некоторых априорных сведений о влиянии привязки и порядка на значения целевой функции и ограничений. Это обуславливает специализацию методов на конкретный класс архитектур ВС. Однако, для уточнения расписания (локальной оптимизации расписания) можно предложить алгоритмы детерминированной коррекции расписания исправляющие “плохие” фрагменты расписания и не использующие априорные сведения о влиянии привязки и порядка на значения целевой функции и ограничений. Если некоторый рабочий интервал находится длительное время в состояниях SP_D - ожидание данных от других рабочих интервалов или SP_EAS - ожидание получения разделяемого ресурса, то можно попытаться уменьшить время нахождения рабочего интервала в этих состояниях путем изменения расположения в расписании рабочего интервала или его непосредственных предшественников. То есть, работа алгоритма основана на использование информации о “плохих” фрагментах расписания, которая может быть определена при анализе динамики функционирования ВС (TR). Такое построение алгоритмов детерминированной коррекции расписания позволяет устранить их узкую специализацию на конкретный класс архитектур ВС. Основная область эффективного применения алгоритмов детерминированной коррекции решений – уточнение расписаний на уровне регистровых передач при решении задачи уточнения деталей реализации ВС с учетом элементной базы и системного программного обеспечения.
В генетических алгоритмах система операций преобразования расписаний определена: операции скрещивания, мутации и селекции. Требуется выбрать такую форму представления расписаний, чтобы операции генетического алгоритма не приводили к получению недопустимых вариантов расписаний и любое допустимое расписание могло быть представлено в выбранной форме представления расписаний. В алгоритмах имитации отжига, случайного поиска, детерминированной коррекции расписаний система операций преобразования расписаний вводится при разработке алгоритма. Для этих алгоритмов способ представления расписаний и система операций преобразования расписаний должными обладать следующими свойствами: применение операции должно приводить к допустимому варианту расписания и система операций должна быть функционально полной.
Использование в итерационных алгоритмах системы операций преобразования расписаний, получающих недопустимые расписания , приводит к необходимости введения в функцию T=f(HP,HW) слагаемых, отвечающих за штрафы, или барьерных функций. При этом возникают проблемы корректной оценки значений T для неинтерпретируемых расписаний и искажения пространства решений.
В последующих разделах предлагается решение проблемы согласованного изменения задающих расписание переменных, позволяющее избежать получения недопустимых вариантов решения на всех итерациях алгоритма, и допускающее построение итерационных алгоритмов обеспечивающих переход от произвольного допустимого расписания к оптимальному за линейное число итераций относительно числа рабочих интервалов. 

4. Непосредственное представление и операции преобразования расписания
В данном разделе рассмотрим математические структуры данных для непосредственного представления расписаний (бинарное и целочисленное представления) и функционально полную систему операций для преобразования расписаний.
Бинарное непосредственное представление расписания
Расписание задается:
Матрицей привязки Y(HP)NM и матрицей смежности X(HP)NN графа HP, где элементы матриц определяются: 
		
(первый индекс рабочий интервал-предшественник, второй индекс рабочий интервал-приемник). Где M – число процессоров в ВС, N – число рабочих интервалов в H.
Недостатком данного представления является большое число бинарных переменных N2+NM.
Целочисленное непосредственное представление расписания
1. Расписание задается матрицей Y(HP)NM, где элемент матрицы определяется: ,
c – порядковый номер рабочего интервала pi в SPj.
При данном способе представления расписания число целочисленных переменных равно NM.
2. Расписание задается: вектором привязки Y(HP)K и вектором порядка X(HP)N, где i-й элемент вектора Y(HP)K равен номеру списка в который назначены рабочие интервалы i-го процесса, а i-й элемент вектора X(HP)N равен порядковому номеру рабочего интервала в соответствующем списке. При данном способе представления расписания число целочисленных переменных равно K+N.
Операции преобразования расписания
Можно выделить следующие варианты отличия расписаний HP и HP друг от друга:
расписания HP и HP отличаются лишь порядком рабочих интервалов как минимум в одном SPj;
расписания HP и HP отличаются привязкой рабочих интервалов.
Введем соответствующие операции преобразования расписаний, позволяющие устранить указанные варианты отличия: O={O1,O2}. Операции O1,O2 определим для целочисленного непосредственного представления расписания. Операции будем определять при предположениях: каждый процесс имеет не более одного рабочего интервала или при условии, что на расписание не накладывается ограничение 5. После доказательства теоремы о функциональной полноте системы операций O={O1,O2} и получении условий их применимости покажем возможность снятия указанных предположений.
Операция изменения порядка рабочих интервалов в одном списке изменяет порядковый номер рабочего интервала pi в списке SPm (порядковый номер рабочего интервала становится равным c) и корректирует порядковые номера соответствующих рабочих интервалов в данном списке (NSm – число рабочих интервалов в списке SPm):

Операция изменения привязки рабочих интервалов переносит рабочий интервал pi из списка SPm в список SPk (порядковый номер рабочего интервала становится равным c) и корректирует порядковые номера соответствующих рабочих интервалов в списках SPm и SPk:

Указанные интервалы параметра операций c могут привести к нарушению ограничений 3,4. Ниже покажем функциональную полноту системы операций O={O1,O2} и получим условия их применимости (выбор значения параметра c) не нарушающие ограничений 3,4.
Теорема 1. Если HP и HP - произвольные допустимые расписания (), то существует конечная цепочка команд , переводящая расписание HP в HP, такая, что все K промежуточных расписаний являются допустимыми и K  2N.
Доказательство. Введем понятие канонического расписания HP0: все рабочие интервалы находятся в SP1 и порядковые номера рабочих интервалов в SP1 равны номерам рабочих интервалов в графе H. HP0 является допустимым, поскольку нумерация рабочих интервалов в графе H удовлетворяет условиям полной топологической сортировки. Полноту системы операций {O1,O2} докажем, показав, что существует стратегия (последовательность выбора рабочих интервалов, операция для каждого интервала из последовательности и значение параметра c) с числом шагов K  N позволяющая перевести произвольное расписание HP в расписание HP0, такая, что все промежуточные расписания HPi (полученные после выполнения отдельной операции Oi) являются допустимыми и любая операция из цепочки  является обратимой.
Применение операций O1,O2 не может привести к нарушению ограничений 1,2 по определению операций при любой стратегии.
Расписания HP, HP0 и HPi будем представлять в ярусной форме максимальной высоты. Покажем, что следующая стратегия позволяет перевести HP в HP0, не нарушая ограничений 3-4 для промежуточных расписаний HPi:
1) выбор рабочих интервалов осуществляется в соответствии с их номерами в H;
2) если очередной рабочий интервал , то применяем O1; если , то применяем O2 (нижний индекс – номер рабочего интервала в H, верхний – номер яруса на котором расположен рабочий интервал);
3) для рабочего интервала  параметр c=i.
Рассмотрим применение данной стратегии к рабочему интервалу с номером i=1. Если рабочий интервал находится в SP1 на первом ярусе, то его перенос не требуется. Если рабочий интервал находится в SP1 на ярусе отличном от первого, то увеличиваем на 1 номера ярусов с первого яруса по ярус, предшествующий ярусу на котором находился первый рабочий интервал, и применяем к нему операцию O1. Полученное при этом расписание HP1 удовлетворяет ограничению 3 в силу того, что нумерация рабочих интервалов в H удовлетворяет условиям полной топологической сортировки, и является ярусным, следовательно, удовлетворяет ограничению 4. Если рабочий интервал не находится в SP1, то применяем к нему операцию O2, осуществляющим его перенос в SP1 на первый ярус. Если рабочий интервал находился на ярусе отличном от первого, то аналогично, как и при применении операции O1, корректируем номера ярусов. Полученное при этом расписание HP1 удовлетворяет ограничению 3 в силу того, что нумерация рабочих интервалов в H удовлетворяет условиям полной топологической сортировки, и является ярусным, следовательно, удовлетворяет ограничению 4. Поскольку, HP допустимое расписание, то операции O1/O2 являются обратимыми (параметр c в обратной операции принимает старый номер рабочего интервала).
Пусть расписание HPi-1 является допустимым. На предыдущих шагах все предшественники i-го рабочего интервала перенесены на ярусы лежащие выше i-го яруса в SP1. Переносим i-й рабочий интервал в SP1 на i-й ярус, используя операцию O1/O2. Если i-й рабочий интервал находился не на i-м ярусе, то перед применением операции увеличиваем на 1 номера ярусов с i-го яруса по ярус, предшествующий ярусу на котором находился i-й рабочий интервал. Полученное расписание HPi, удовлетворяет ограничениям 3 и 4, так как все предшественники i-го рабочего интервала находятся на ярусах выше i-го яруса, последователи на ярусах ниже i-го яруса, и граф HPi представлен в ярусной форме максимальной высоты. Поскольку, HPi-1 и HPi допустимые расписания, то операции O1/O2 являются обратимыми (параметр c в обратной операции принимает старый номер рабочего интервала).
После обхода всех вершин в соответствии с используемой стратегией получим расписание HP0. Если операции O1/O2 применялись для всех рабочих интервалов то K=N. Поскольку, каждая операция из цепочки  обратима, то существует стратегия перехода от HP0 к произвольному HP, такая, что все K промежуточных расписаний являются допустимыми и KN. Следовательно, существует стратегия перехода от произвольного допустимого варианта расписания HP к произвольному допустимому варианту расписания HP, такая, что все промежуточные расписания допустимы и K2N.
Следствие 1. Существует стратегия перехода от произвольного допустимого расписания к оптимальному расписанию, такая, что длина цепочки команд , переводящей произвольное допустимое расписание в оптимальное, не превосходит значения 2N (K2N) и все K промежуточных расписаний являются допустимыми.
Условия применимости операций не нарушающие ограничений на HP
Получим интервал значений параметра c при применении операции O1/O2 к рабочему интервалу . Расписания HP будем представлять в ярусной форме максимальной высоты. Обозначим через  - множество непосредственных предшественников рабочего интервала  (всегда выполняется k<i и l<s),  - множество непосредственных последователей рабочего интервала  (всегда выполняется k>i и l>s). Операция  - получает максимальный номер яруса, на котором расположен один из непосредственных предшественников рабочего интервала , для рабочих интервалов, не имеющих предшественников lin=0 (нулевой ярус всегда пуст). Операция  - получает минимальный номер яруса, на котором расположен один из непосредственных последователей рабочего интервала , для рабочих интервалов, не имеющих последователей lout=N (N – число ярусов в HP, для ярусной формы максимальной высоты число ярусов всегда равно числу рабочих интервалов). Тогда, рабочий интервал  может быть размещен в любой из списков SPj на любой из ярусов из интервала lin<s<lout. Если выбранный ярус занят, то осуществляется коррекция ярусной формы путем соответствующего сдвига ярусов.
Пусть рабочий интервал  переносится в SPj или изменяется его порядковый номер в этом списке. Разобьем множество SPj на три подмножества:  - множество рабочих интервалов из списка SPj, находящихся на ярусах, расположенных выше яруса (lin-1);  - множество рабочих интервалов из списка SPj, находящихся на ярусах ;  - множество рабочих интервалов из списка SPj, находящихся на ярусах, расположенных ниже яруса (lout+1). Параметр c при размещении рабочего интервала  в SPj может принимать следующие значения, не нарушающие ограничения на HP (индекс j  для PIN, PI, POUT будем опускать):

PIN
PI
POUT
C
1
PIN=
PI=
POUT=
c=1
2
PIN=
PI=
POUT
c=1
3
PIN=
PI
POUT=

4
PIN=
PI
POUT

5
PIN
PI=
POUT

6
PIN
PI=
POUT=

7
PIN
PI
POUT=

8
PIN
PI
POUT

Указанные выше интервалы значений параметра c не нарушающие ограничения на HP могут быть расширены, если ярусная форма максимальной высоты будет приведена к такому виду, что все рабочие интервалы SPj, которые не находятся в отношении транзитивного порядка с непосредственным предшественником рабочего интервала  (находящимся на ярусе lin) и расположены на ярусах с меньшими номерами чем lin, будут перенесены на ярусы с номерами большими чем lin. Аналогичное преобразование ярусной формы может быть осуществлено и для непосредственного последователя рабочего интервала , находящимся на ярусе lout.
Пусть непосредственным предшественником рабочего интервала  является рабочий интервал , находящийся на ярусе lin, и рабочий интервал  переносится в SPj или изменяется его порядковый номер в этом списке. Пусть lin* ярус, на котором находится транзитивный предшественник рабочего интервала , принадлежащий SPj и с наибольшим порядковым номером в SPj. Рабочие интервалы SPj, находящихся между ярусами lin* и lin могут быть перераспределены по ярусам, таким образом, что они будут находиться на ярусах с большими номерами, чем lin (при этом осуществляется соответствующее перераспределение по ярусам рабочих интервалов и других списков). Аналогичное преобразование ярусной формы осуществляется и для последователей.
Возможность снятия условий: каждый процесс имеет не более одного рабочего интервала или на расписание не накладывается ограничение 5
Поскольку, при доказательстве теоремы 1 и получении условий применимости операций O1/O2 использована ярусная форма максимальной высоты (на каждом ярусе находится лишь один рабочий интервал), то полученные результаты легко могут быть обобщены на случаи когда: каждый процесс может иметь более одного рабочего интервала или на расписание накладывается ограничение 5. При перемещении рабочего интервала из одного списка в другой, перемещаются также и все рабочие интервалы процесса, которому принадлежит перемещаемый рабочий интервал, но при этом остаются на прежних ярусах. В результате получаем ярусную форму нового расписания, и, следовательно, полученное расписание удовлетворяет ограничениям 3-5.

5. Параметрическое представление расписания
В данном разделе рассмотрим математические структуры данных для параметрического представления расписаний, соответствующие алгоритмы восстановления расписания по его параметрическому представлению не нарушающие ограничений 1-5, введем операции изменения параметров и докажем возможность задания любого допустимого расписания параметрическим представлением с использованием приоритетов и соответствующих быстрых алгоритмов восстановления.
Параметрическое представление расписаний с использованием приоритетов
Расписание задается вектором YN+K :



K - число процессов в H, Ni – число рабочих интервалов в i-ом процессе,  - число рабочих интервалов в H,  - операция построения вектора  из параметров  и .
Параметр  содержит номер процессора, на котором выполняются рабочие интервалы i-го процесса, т.е. параметры  однозначно определяют распределение рабочих интервалов по SP (привязку). Параметры  могут принимать значения от 1 до K. Если значения всех параметров  равны, то все рабочие интервалы выполняются на одном процессоре, если все значения различны, то рабочие интервалы каждого процессора выполняются на своем процессоре. В силу ограничения 5, максимальное число не пустых процессоров равно числу процессов K в H.
Параметры  используются алгоритмом восстановления расписания (определение отношения полного порядка в каждом SPi) в качестве приоритетов рабочих интервалов.
При данном способе представления расписания число целочисленных переменных равно N+K.
Для описания алгоритма восстановления, множество рабочих интервалов разобьем на три подмножества: . P1 - множество рабочих интервалов распределенных в SP (определен порядковый номер рабочего интервала) алгоритмом восстановления на предыдущих шагах; P2 - множество рабочих интервалов, у которых все предшественники принадлежат P1; P3 - множество рабочих интервалов, у которых хотя бы один из предшественников не принадлежит P1.
Алгоритм восстановления полного порядка рабочих интервалов в SP (A1).
1. Начальное разбиение множества P:
P1=; 
 - множество рабочих интервалов в H без предшественников; 
- множество рабочих интервалов в H, у которых имеются предшественники.
2. Находим в P2 рабочий интервал с наименьшим значением параметра  (если таких интервалов более одного, то выбираем интервал с наименьшим номером):
размещаем его в конец соответствующего списка SP (номер списка определяется значением параметра );
переносим его из P2 в P1.
3. Проверяем P3 с целью возможности переноса рабочих интервалов в P2:
если есть рабочие интервалы, у которых все предшественники принадлежат P1, то переносим их в P2.
4. Если P2, то к п.2, иначе завершить работу.

Утверждение 1. Алгоритм A1 восстановления расписания по его параметрическому представлению YN+K получает расписание , и расписание восстанавливается однозначно.
Доказательство. Ограничение 5 не нарушается в силу того, что все рабочие интервалы, принадлежащие одному и тому же процессу, имеют одно и тоже значение параметра  и будут размещены (п.2 алгоритма) в один и тот же список.
Ограничения 1,2 не нарушается в силу того, что каждый рабочий интервал переносится из P2 в соответствующий SP, причем перенос осуществляется лишь один раз в ходе работы алгоритма.
Выполнение ограничений 3,4 и однозначность восстановления расписания докажем показав, что алгоритм A1 получает на каждом шаге допустимое частичное расписание и это расписание получается однозначно. Будем представлять расписание в ярусной форме максимальной высоты. Расписание, полученное после размещения первого выбранного из P2 рабочего интервала, всегда удовлетворяет ограничениям 3,4. Множество P2 определено однозначно (содержит рабочие интервалы без предшественников), выбор рабочего интервала из P2 однозначен и его порядковый номер в соответствующем SP определен однозначно, равен 1 (п.2 алгоритма). Пусть частичное расписание, полученное после размещения (j-1) рабочих интервалов допустимо и однозначно. Покажем, что на j-м шаге рабочий интервал выбирается и размещается алгоритмом A1 в расписание однозначно и полученное частичное расписание удовлетворяет ограничениям 3,4. Множество P2 на j-м шаге алгоритма A1 определяется однозначно рабочими интервалами, размещенными в расписание на предыдущих шагах. Выбор рабочего интервала из P2 однозначен и его порядковый номер в соответствующем SP определен однозначно, максимальный порядковый номер рабочего интервала в данном SP плюс 1 (п.2 алгоритма). Данный рабочий интервал размещается на j-й ярус. Поскольку все его предшественники (в соответствии с определением множества P2) уже распределены на предыдущих шагах на ярусы с меньшими номерами, то отношения частичного порядка заданное в H не нарушается (выполняется ограничение 3). Ограничение 4 выполняется в силу того, что полученное промежуточное расписание представлено в ярусной форме. Таким образом, после выполнения алгоритмом A1 N шагов полученное расписание будет удовлетворять ограничениям 3,4 и порядковые номера рабочих интервалов в списках определяются однозначно.
Теорема 2. Любое допустимое расписание  может быть задано параметрическим представлением с использованием приоритетов (YN+K) и однозначно восстановлено алгоритмом A1, если допустимая верхняя граница L значений параметров  больше или равна числу рабочих интервалов (LN).
Доказательство. Расписания могут отличаться друг от друга привязкой и порядком рабочих интервалов (смотри раздел 3). Любая допустимая привязка (распределение рабочих интервалов по SP) может быть задана соответствующими значениями параметров  и однозначно восстановлена алгоритмом A1.
Возможность задания любого допустимого порядка для фиксированной привязки можно доказать методом математической индукции. Для любого произвольно выбранного SPk можно показать, что для рабочего интервала с порядковым номером равным 1, значение параметра  для этого рабочего интервала можно выбрать таким образом, что он может иметь любой допустимый порядковый номер в SPk, который однозначно получает алгоритм A1 (место возможного размещения рабочего интервала определяется размещением его последователей в HP с использованием ярусной формы HP). Далее полагаем, что для (i-1) рабочих интервалов из списка SPk с наименьшими порядковыми номерами, можно получить любые допустимые варианты порядка, выбирая соответствующий набор значений параметров . Можно показать, что для рабочего интервала с порядковым номером равным i, значение параметра  для этого рабочего интервала можно выбрать таким образом, что он может иметь любой допустимый порядковый номер в SPk, который однозначно получает алгоритм A1 (место возможного размещения рабочего интервала определяется размещением его предшественников и последователей в HP с использованием ярусной формы HP).
Выбор значений параметров , позволяющих получить требуемое расписание алгоритмом восстановления A1, можно сделать, проведя соответствующую топологическую сортировку вершин требуемого расписания. Поскольку, в P2 максимум может находиться N рабочих интервалов, то для получения любого допустимого варианта порядка может потребоваться максимум N различных значений параметров , т.е. может потребоваться полная топологическая сортировка.
Операции преобразования расписания
При параметрическом представлении расписания с использованием приоритетов операции преобразования расписания могут быть введены как операции изменения значений параметров  и : 
1) параметры  могут принимать целочисленные значения в диапазоне [1,…,K],
2) параметры  могут принимать целочисленные значения в диапазоне [1,…,L],
3) количество изменяемых параметров может изменяться от 1 до N+K.
Операции преобразования параметрической формы представления расписаний, удовлетворяющие условиям 1-3 при использовании алгоритма восстановления A1, будут получать расписания удовлетворяющие ограничениям 1-5, что следует непосредственно из утверждения 1. Из теоремы 2 следует, что данные операции преобразования расписания и алгоритм восстановления A1 позволяют получить любой допустимый вариант расписания.
Параметрическое представление расписаний с использованием характеристик рабочих интервалов
Расписание задается вектором YK :

Параметр  содержит номер процессора, на котором выполняются рабочие интервалы i-го процесса, т.е. параметры  однозначно определяют распределение рабочих интервалов по SP (привязку). Параметры  могут принимать значения от 1 до K.
При данном способе представления расписания число целочисленных переменных равно K.
Алгоритм восстановления A1 вместо значений параметров  в качестве приоритетов может использовать характеристики рабочих интервалов:
вычислительную сложность рабочего интервала,
число непосредственных последователей,
число непосредственных предшественников,
априорно заданные приоритеты.
Для данного способа параметрического представления расписания справедливо утверждение 1, однако, теорема 2 не выполняется. При построении алгоритмов оптимизации, использующих данный способ представления расписания, следует обращать внимание на принципиальную возможность получения расписания с требуемым качеством.

Заключение.
В работе рассмотрена проблема построения расписаний при совместном проектировании аппаратных и программных средств вычислительных систем. Основная область эффективного применения жадных алгоритмов - построение расписаний на абстрактном уровне проектирования при решении задачи оценки принципиальной возможности построения ВС при заданных ограничениях и сужение класса рассматриваемых архитектур. Основная область эффективного применения алгоритмов, основанных на методе проб и ошибок - построение расписаний на системном уровне проектирования при решении задачи определения основных параметров структуры ВС. Основная область эффективного применения алгоритмов детерминированной коррекции решений – уточнение расписаний на уровне регистровых передач при решении задачи уточнения деталей реализации ВС с учетом выбранных элементной базы и системного программного обеспечения.
Комбинаторный характер задачи построения расписания, а именно транзитивность отношения порядка, создает проблему согласованного изменения задающих расписание переменных для получения на очередной итерации алгоритма допустимого варианта расписания. Для алгоритмов, основанных на методе проб и ошибок, и алгоритмов детерминированной коррекции предложено решение проблемы согласованного изменения переменных задающих расписание, которое позволяет избежать получения недопустимых вариантов решения на всех итерациях алгоритма и допускает построение итерационных алгоритмов обеспечивающих переход от произвольного допустимого расписания к оптимальному за линейное число итераций.
Для непосредственного способа представления расписания (привязка и порядок задаются явно) получена функционально полная система операций преобразования расписаний. Данные операции используются в алгоритмах случайного поиска, имитации отжига и детерминированной коррекции решений.
Для параметрического представления расписания (привязка и порядок задаются значениями некоторых параметров, по которым, с использованием алгоритма восстановления, их значения могут быть восстановлены) доказана возможность представления любого допустимого варианта расписания и однозначность его восстановления. Данная форма представления используется в генетических алгоритмах. Параметрическое представление допускает независимое изменение значений всех переменных в заданных интервалах, что позволяет гарантированно получать допустимые варианты расписания при выполнении операций генетического алгоритма. Данная форма представления может быть использована также и в алгоритмах случайного поиска и имитации отжига.

Литература.
1. Смелянский Р.Л. Модель функционирования распределенных вычислительных систем, // Вестн. Моск. Ун-та. сер 15, Вычисл. Матем. и Кибернетика. 1990, No. 3, стр. 3-21.
2. Смелянский Р.Л. Об инварианте поведения программ // Вестн. МГУ, сер. 15, Вычислительная математика и Кибернетика, 1990., No. 4, С. 54-60.
3. В.В. Воеводин. Математические модели и методы в параллельных процессах. – М.: Наука, 1986.
4. Теория расписаний и вычислительные машины/ Под ред. Э.Г.Коффмана. М.: Наука, 1984. - 334с.
5. Гэри М., Джонсон Д. Вычислительные машины и трудно решаемые задачи. - М.: Мир, 1982. - 416с.
6. Беллман Р. Динамическое программирование. – M.: ИЛ, 1960.
7. М. Мину. Математическое программирование. Теория и алгоритмы.- М.: Наука, 1990.
8. Т. Кормен, Ч. Лейзерсон, Р. Ривест. Алгоритмы: построение и анализ. – М.: МЦНМО, 1999.
9. Костенко В.А. Метод автоматизированного синтеза параллельных программ для вычислительных систем с MIMD архитектурой// Программирование, 1993., No. 1, стр. 43-57.
10. Костенко В.А. Автоматизация составления параллельных программ для вычислительных систем с MIMD архитектурой// Кибернетика и системный анализ, 1995., No. 5, стр. 170-179.
11. Костенко В.А., Романов В.Г., Смелянский Р.Л. Алгоритмы минимизации аппаратных ресурсов ВС// Искусственный интеллект (Донецк), 2000., No2, С.383-388.
12. Костенко В.А. Задачи синтеза архитектур: формализация, особенности и возможности различных методов для их решения// Программные системы и инструменты. Тематический сборник. - M.: МАКС Пресс, 2000., № 1, С.31-41.
13. Батищев Д.И., Гудман Э.Д., Норенков И.П., Прилуцкий М.Х. Метод комбинирования эвристик для решения комбинаторных задач упорядочивания и распределения ресурсов// Информационные технологии, 1997., N 2 - С.29-32.
14. Норенков И. П. Эвристики и их комбинации в генетических методах дискретной оптимизации// Информационные технологии, 1999, N 1.
15. Holland J.N. Adaptation in Natural and Artificial Systems. Ann Arbor, Michigan: Univ. Michigan Press, 1975.
16. Zbigniev Michalewicz. Genetic Algorithms + Data Structures = Evolution Programs// Third, Revised and Extended Edition – Springer, 1999.
17. Костенко В.А. Принципы построения генетических алгоритмов и их использование для решения задач оптимизации// Труды IV Международной конференции "Дискретные модели в теории управляющих систем" (19-25 июня 2000 г.) – М.: МАКС Пресс, 2000., С.49-55.
18. Обозрение прикладной математики. Серия “Методы оптимизации”. Эволюционные вычисления и генетические алгоритмы// Т.3, выпуск 5. - 1996.
19. Уоссермен Ф. Нейрокомпьютерная техника. Теория и практика.- М.: Мир, 1992.
20. Костенко В.А. Алгоритмы оптимизации, опирающиеся на метод проб и ошибок, в совместном проектировании аппаратных и программных средств ВС// Труды Всероссийской научной конференции "Высокопроизводительные вычисления и их приложения" (30 октября - 2 ноября 2000 г., г. Черноголовка). -М.: Изд-во МГУ, 2000., С.123-127.
21. Л.А. Растригин. Статистические методы поиска.- М.: Наука, 1968.

Приложение 1.
Набор состояний рабочих интервалов процессов и аппаратных ресурсов.
Состояния рабочего интервала процесса:
SP_INI - ожидание инициализации;
SP_D – ожидание завершения предшественников;
SP_EAS - ожидание получения разделяемого ресурса;
SP_W - работа (выполнение внутренних действий SP_WE или внешних взаимодействий SP_WEAS);
SP_SPR – ожидание обновления данных в памяти процессора или завершения, вызванного системного процесса;
SP_END - рабочий интервал выполнен.

Состояния процессора:
SE_W - выполняет один из рабочих интервалов, назначенных на этот процессор;
SE_EX - простой из-за нахождения текущего рабочего интервала в состояниях SP_D или SP_EAS;
SE_SPR – выполняется системный процесс;
SE_END - завершение выполнения всех рабочих интервалов назначенных на процессор.

Состояния разделяемого ресурса:
SEAS_INI - арбитраж заявок на обслуживание и инициализация выполнения заявки, выигравшей арбитраж;
SEAS_W - обслуживание заявки процессора;
SEAS_EX - простой из-за отсутствия заявок на обслуживание от процессоров.
ИЗВЕСТИЯ РАН. ТЕОРИЯ И СИСТЕМЫ УПРАВЛЕНИЯ, 2012, № 2, с. 124–131

 	 КОМПЬЮТЕРНЫЕ   	 МЕТОДЫ
УДК


АЛГОРИТМ СИНТЕЗА АРХИТЕКТУРЫ ВЫЧИСЛИТЕЛЬНОЙ СИСТЕМЫ РЕАЛЬНОГО ВРЕМЕНИ
С  УЧЕТОМ  ТРЕБОВАНИЙ  К  НАДЕЖНОСТИ
© 2012 г.  Д. А. Зорин, В. А. Костенко
Москва, МГУ
Принята в редакцию 22.09.11 г., после доработки 01.11.11 г.


Рассматривается задача построения вычислительной системы реального времени с мини- мальным числом процессоров. При этом требуется соблюдение директивных сроков на время выполнения программы, а также должны быть выполнены требования к надежности систе- мы, которые подразумевают, что система должна выдерживать как аппаратные, так и про- граммные отказы. Приведена формальная постановка данной задачи, предложен метод ее ре- шения с использованием итерационного алгоритма построения расписания, основанного на методе имитации отжига, и проведено экспериментальное исследование предложенного ал- горитма.
Compaq_615
2013-01-26 07:57:46
--------------------------------------------
№ 3, С.76–83. 


Введение. В [1, 2] предложен подход к построению алгоритмов на основе схемы имитации от- жига для решения задачи построения расписания с минимальным временем выполнения на за- данном числе процессоров. Алгоритмы на основе схемы имитации отжига последовательно из- меняют расписание с целью уменьшения времени его выполнения. Основными проблемами, ко- торые необходимо решить для построения алгоритма, является введение системы операций преобразования расписания и разработка стратегии применения этих операций на каждой ите- рации алгоритма. Система преобразования операций должна допускать существование цепочки операций конечной длины, позволяющей преобразовать произвольный корректный вариант расписания в оптимальный вариант расписания, и при этом все промежуточные расписания должны быть корректными. Стратегия применения операций на каждой итерации алгоритма определяет его сложность и точность.
В данной работе подход к построению системы операций преобразования расписаний и стра- тегии их применения расширен для решения задачи синтеза архитектуры вычислительной си- стемы реального времени, а именно определения минимального необходимого числа процессо- ров и построения статического расписания выполнения прикладных программ. При этом долж- ны соблюдаться заданные ограничения на время выполнения расписания и надежность вычислительной системы. Повышать надежность системы можно с помощью введения резерв- ных элементов – как процессоров, так и копий программных модулей. В данной работе для по- вышения надежности вычислительной системы используется горячее резервирование процессо- ров и многоверсионное программирование. Задачи такого типа возникают при проектировании систем жесткого реального времени.
1. Задача построения расписания с минимизацией числа используемых процессоров. 1.1. М о - д е л ь с и с т е м ы. Аппаратная часть системы состоит из множества процессоров, соединенных друг с другом посредством коммутатора. Все процессоры одинаковы, т.е. время выполнения од- ной и той же программы будет одинаково на любом процессоре, и надежность процессоров оди- накова. Известно время передачи единицы данных от одного процессора к другому. Коммутатор устроен таким образом, что если к нему подключено N процессоров, то гарантируется наличие N/2 свободных каналов в любой момент времени, таким образом, для любой передачи всегда найдется канал. Существуют реальные коммутаторы, удовлетворяющие данным требованиям, в частности, это коммутатор FibreChannel.
Программа, для которой строится расписание, состоит из конечного множества взаимодей- ствующих заданий. Для каждого из заданий известно, какие вычисления оно производит и каков объем результата, получаемого на выходе. Программу можно представить в виде графа потока данных. Формально модель системы состоит из следующих объектов:
M – счетное множество процессоров,
G = {V, E} – граф потока данных программы, ориентированный граф без циклов,

124

V – множество вершин, соответствующих заданиям,
E – множество ребер; в графе есть ребро (v , v ), если задание v

принимает на вход результа-
1
ты работы задания v ,
1	2	2
F : E → – функция, задающая объем передаваемых данных для каждой взаимодействую- щей пары заданий,
A : M × M → – функция, задающая время передачи единицы данных между двумя процес- сорами; если первый аргумент равен второму, то значение этой функции равно нулю: передача данных в пределах одного процессора не занимает времени,
C : V × M → – функция, задающая время работы задания на определенном процессоре; для каждого задания определена мера вычислительной сложности, по которой можно рассчитать время выполнения на конкретном процессоре.
В работе введены следующие ограничения:
∀mi, mj ∈ M, v ∈ V: C(v, mi) = C(v, mj) (функция C не зависит от m, поэтому в дальнейшем будем для простоты писать C(V));
∀mi, mj ∈ M, mi ≠ mj: A(mi, mj) = 1. Время передачи единицы данных между любыми двумя про- цессорами одинаково. Далее для простоты время передачи данных от одного задания к другому
вместо F(v , v ) · A(m , m ) будем обозначать F(v , v ).
1	2	1	2	1	2
1.2. Модель надежности. Рассмотрены два метода повышения отказоустойчивости: ре- зервирование для процессоров и многоверсионное программирование. Резервирование процес- соров заключается в том, что в систему добавляется новый процессор, на котором выполняются те же задания, что и на другом. В этом случае система отказывает, только если отказывают оба процессора. Дублирующий процессор работает в режиме горячего резерва, т.е. принимает все те же данные и выполняет те же вычисления, что и основной, но передает данные только в случае отказа основного. Устройство коммутатора таково, что введение резервного процессора не вы- зывает никаких задержек в работе системы.
У т в е р ж д е н и е 1. Пусть на процессоре mi выполняются задания v …v . Тогда добавление
1	n
резервного процессора mr и дублирование на нем всех заданий v …v
обеспечивает  надежность
1	n
не меньшую, чем добавление резервных процессоров mr…mr+k и дублирование на каждом из них
некоторых из заданий v …v .
1	n
При многоверсионном программировании создается несколько версий реализации какого- либо задания и считается, что если больше половины из них выдали идентичный результат, то за- дание завершается успешно.
i
i
i
Для задания модели надежности системы необходимо, чтобы были известны величины P(mi) – надежность отдельного процессора, Vers(v ) – множество доступных версий каждого из заданий, P(v ) – надежность отдельного задания с учетом количества версий. Формулы для вы- числения P(v ) при различных конфигурациях версий приведены в [3–6]. Надежность всей си- стемы определяется как произведение надежностей всех ее компонентов.
1.3. М о д е л ь р а с п и с а н и я. Будем считать, что для программы задано расписание, если для каждого из заданий определены привязка – однозначно известно, на каком процессоре оно выполняется, и порядок – для каждого процессора известно, в какой очередности выполняются задания. Если используется многоверсионное программирование, то помимо указания задания необходимо указывать номер его версии, т.е. привязка и порядок определяются не для задания, а для пары “задание–версия”.
Формально расписание (для системы с резервированием и многоверсионным программиро- ванием) определяется как пара (S, D). Здесь S – множество четверок (v, k, m, n), где v ∈ V, k ∈
∈ Vers(v), m ∈ M, n ∈ N, такое, что
∀v ∈V ∀k ∈Vers (v) : ∃! s = (vi, ki, mi, ni ) ∈ S : vi  = v,
ki  = k;
∀si = (v i, ki, mi, ni ) ∈ S,
∀s j  = (v j, k j, m j, n j ) ∈ S : (si  ≠ s j  ∧ mi  = m j ) ⇒ ni  ≠ n j.
Второй элемент, D – мультимножество, состоящее из элементов множества процессоров M. Содержательно m и n задают соответственно привязку к процессору и порядок выполнения для каждой версии каждого задания. Мультимножество D обозначает резервируемые процессоры.
Расписание можно представить в виде графа. Вершинами этого графа являются элементы множества S. Если между соответствующими заданиями есть дуга в графе G, то она добавляется в граф расписания, также в граф расписания добавляются дуги между вершинами, назначенны-

ми на один процессор и имеющими соседние номера. Элемент расписания s2 будем называть за-
висимым от s1, если либо (v , v ) ∈ E, либо m = m
∧ n  < n . Иначе говоря, s
зависит от s , если s
1	2	1
2	1	2
2	1	2
не может начать выполняться раньше s1 из-за зависимости по данным или порядка выполнения на процессоре.
Из определения следует, что каждая версия каждого задания может присутствовать в расписа- нии в единственном экземпляре, а также на каждом процессоре у всех заданий различные номе- ра и как минимум одна версия каждого задания должна быть включена в расписание. Помимо этих ограничений необходимо ввести еще одно, чтобы гарантировать завершимость программы. Будем говорить, что расписание S корректно, если его граф является ациклическим. Множество
всех корректных расписаний обозначим S . Для каждого корректного расписания определены функции t(S) – время выполнения расписания, R(S) – надежность системы при заданном распи- сании и M(S) – количество процессоров, требуемых для работы по данному расписанию.
1.4. П о с т а н о в к а з а д а ч и. Пусть заданы программа G, tdir – срок, к которому программа должна быть выполнена, и Rdir – надежность, которой должна обладать система. Требуется по- строить расписание  S, для которого требуется минимальное  количество  процессоров,  но  при этом удовлетворяются ограничения на время выполнения и надежность:
min M(S);
S ∈ S
t(S) < t dir ,
R(S) > Rdir .
(1.1)
У т в е р ж д е н и е 2. Задача (1.1) является NP-трудной.
Данное утверждение может быть доказано путем сведения к задаче о разбиении множества чисел на два подмножества с равной суммой [7]. Каждому числу ai в задаче о разбиении ставится
в соответствие задание vi со временем выполнения C(v ) = a , связей между заданиями нет, Rdir = 0,
i	i
директивный срок tdir равен полусумме всех чисел {ai}.
i
1.5. Операции преобразования расписани я. Введем следующие обозначения: Dup(mi) – кратность процессора mi в мультимножестве D; Dep(s) – множество таких элементов si, что в графе G есть ребро (v , v), т.е. множество вершин – непосредственных предшественников s; Succ(s) – множество заданий, косвенно зависящих от s. По определению, si ∈ Succ(sj), если либо
в графе G есть путь из v в v , либо в графе расписания есть путь из s в s , не содержащий ребро от
j	i	j	i
sj к следующему за ним заданию на процессоре. Для преобразования расписаний введены следу- ющие операции.
Операция добавления резервного процессора. В исходном расписании (S, D) к мультимножеству D добавляется новый элемент. При этом создается дополнительная нагрузка на среду передачи данных, так как на резервный процессор передаются все необходимые данные, однако время пе- редачи данных между основными процессорами не меняется, так как в силу описанного ранее устройства среды обменов для передачи данных на резервные процессоры гарантированно най- дутся свободные каналы.
Операция удаления резервного процессора. В исходном расписании (S, D) из мультимножества
D удаляется элемент m, для которого Dup(m) > 1.
Операция переноса задания. В исходном расписании (S, D) выбирается элемент s1 = (v , k , m ,
n1), процессор m2 и номер n2, такой, что
∀si  = mi  = m2 : (ni  < n2 ⇒ si ∉ Succ(s1)) ∧ (ni  ≥ n2 ⇒ s1 ∉ Succ(si )),
и происходит следующая замена:
1	1	1
s1' = (v1, k1, m1, n1),
∀si  : mi  = m2 : ni  ≥ n2 ⇒ si' = (v i, ki, mi, ni  + 1).
Эта операция позволяет или изменить порядковый номер выполнения задания на процессо- ре, или перенести задание на другой процессор.
Операция добавления версии. Версии можно добавлять только парами в силу принципа работы NVP. Добавление одной версии (v, k) эквивалентно следующей последовательности операций: 1) добавить новый процессор m0; 2) назначить версию первым заданием на этот процессор s = (v, k, m0, 1); 3) перенести s на другой процессор в соответствии с определением операции переноса за- дания; 4) удалить m0.
Операция удаления версии. Версии удаляются также парами. Из расписания удаляются два эле- мента, соответствующих удаляемым версиям.

У т в е р ж д е н и е 3. Замкнутость системы операций. Если (S, D) – корректное расписание, то после применения любой из операций также получается корректное расписание.
У т в е р ж д е н и е 4. Полнота системы операций. Если (S1, D1), (S2, D2) – корректные распи- сания, то существует последовательность операций, приводящая (S1, D1) к (S2, D2), такая, что все промежуточные расписания корректны.
Доказательство этих утверждений может быть проведено аналогично доказательству утвер- ждения о замкнутости и полноте системе операций преобразования расписаний для решения за- дачи построения расписания с минимальным временем выполнения на заданном числе процес- соров, которое приведено в [8].
2. Алгоритм построения расписания. 2.1. Общая схема алгоритм а. Для решения сфор- мулированной задачи предлагается алгоритм, основанный на схеме имитации отжига. Общая схема работы одной итерации алгоритма следующая.
Ш а г 1. Анализируется текущее приближение расписания и выбирается операция для выпол- нения.
Ш а г 2. Выбираются параметры операции, и она выполняется.
Ш а г 3. Если после выполнения операции новое расписание оказывается лучше предыдуще- го, делается переход к новому расписанию: оно берется в качестве следующего приближения. Ес- ли новое расписание хуже, то переход делается с некоторой вероятностью.
Ш а г 4. Если достигнут критерий останова, алгоритм завершает работу.
В качестве возможных операций используются операции, введенные в разд. 1. Наиболее важ- ным элементом алгоритма является используемая в нем стратегия применения операций над расписанием. Стратегия для заданного текущего приближения определяет, какую операцию сле- дует применить и какие для этой операции следует выбрать параметры, т.е. задает поведение ал- горитма на шагах 1 и 2 в вышеописанной схеме. Далее рассмотрим каждый из шагов подробно.
2.2. В ы б о р о п е р а ц и и. Выбирать операцию случайным образом нецелесообразно (как это обычно делается в алгоритмах имитации отжига), поскольку не все операции одинаково не- обходимы в конкретной ситуации. Так, если надежность в некотором расписании не ниже требуе- мой, нет смысла добавлять новые версии и процессоры, так как это только ухудшит время выпол- нения и увеличит количество процессоров. Поэтому предлагается перед выбором операции анали- зировать текущие характеристики расписания и на основе этого анализа выбирать операцию.
Поскольку соблюдение имеющихся в задаче двух ограничений на время и надежность являет- ся обязательным (в то время как число процессоров есть оптимизируемый параметр), рассмат- риваются четыре ситуации: t > tdir, R > Rdir; t > tdir, R < Rdir; t < tdir, R > Rdir; t < tdir, R < Rdir. Если на- дежность меньше, чем требуется, то следует добавлять процессоры и версии, иначе их можно удалять. Если время выполнения превышает директивный срок, то имеет смысл либо удалять версии, либо переносить задания на другие позиции в расписании. Чтобы избежать потенциаль- ных зацикливаний алгоритма, выбор операции сделан недетерминированным. Для каждой из четырех возможных ситуаций заданы вероятности выбора той или иной операций (в том числе возможны нулевые значения). Эти вероятности являются параметрами настройки алгоритма и задаются до начала работы алгоритма. В разд. 3 будут приведены значения этих параметров, с ко- торыми проходило исследование алгоритма.
Применение некоторых операций на определенной итерации алгоритма может быть невозмож- но. Например, если ни у одного процессора нет резервных копий, то удалять процессоры нельзя, а если все имеющиеся версии использованы, то нельзя добавлять версии. Такую ситуацию всегда можно определить, поэтому на этом шаге невозможные операции не рассматриваются.
2.3. В ы б о р п а р а м е т р о в о п е р а ц и й. После выбора операции необходимо выбрать со- ответствующий набор параметров.
Добавление версии. Случайно выбирается задание, версии которого добавляются (среди зада- ний, для которых имеется нужное количество доступных версий). Вероятность выбора задания обратно пропорциональна количеству уже использующихся его версий.
Удаление версии. Случайно выбирается задание, версии которого удаляются. Вероятность вы- бора задания пропорциональна количеству уже использующихся его версий.
Добавление резервного процессора. Аналогично добавлению версии задания, процессоры с меньшим числом резервов имеют большую вероятность добавления.
Удаление резервного процессора. Удаляется резерв для случайно выбранного процессора. Чем больше резервов процессоров, тем больше вероятность его удаления.



Выбор параметров
t < tdir	t >tdir


Уменьшение числа процессоров
Уменьшение времени выполнения
p < pcut
p > pcut	p < p
p > pnew


new
Перенос заданий с некоторого процессора




Перенос плохо расположенного задания
Перенос задания на новый процессор



Стратегия уменьшения задержек
Стратегия заполнения простоев

Смешанная стратегия


Рисунок. Выбор параметров для операции


Вероятности удаления и добавления процессоров и версий заданы таким образом, чтобы стремиться соблюдать баланс между надежностью различных компонентов.
Перенос задания. На рисунке приведена схема выполнения данной операции (в ней p – слу- чайное число от 0 до 1). Рассмотрим ее подробнее.
Если t < tdir, т.е. директивный срок не нарушается, то следует пытаться уменьшить число про- цессоров. С вероятностью pcut происходит следующая операция: выбирается процессор, на кото- ром меньше всего заданий, и все задания с него переносят на другие процессоры. С вероятно- стью 1 – pcut выполняется процедура переноса задания в соответствии с одной из трех стратегий, описанная далее.
Если t > tdir, то необходимо улучшить время выполнения расписания. Это можно сделать, если перенести часть заданий на пустой процессор либо поменять порядок или привязку на существу- ющих. С вероятностью pnew выбирается случайное задание (вероятность зависит от задержки, по- дробно описанной далее) и переносится на отдельный процессор. С вероятностью 1 – pnew вы- полняется одна из стратегий выбора параметров операции переноса задания: уменьшение задер- жек, заполнение простоев и смешанная стратегия.
Стратегия уменьшения задержек основана на следующем утверждении. Если время начала выполнения каждого задания равно длине критического пути в графе G от истоков до задания, то расписание будет оптимальным. Длина критического пути является минимально возможным временем начала выполнения задания и равна сумме времен выполнения заданий, соответству- ющих вершинам критического пути. Для каждого элемента расписания s можно определить мо- мент времени, когда s может начать выполняться, т.е. все задания из Dep(s) завершены. Разница между этим моментом и моментом, когда задание s начало выполняться, является задержкой за- дания s. В качестве параметра алгоритма задается натуральная константа Cver, и первым парамет- ром операции переноса становится одно из Cver заданий с наибольшей задержкой: чем больше за- держка, тем больше вероятность выбора задания. Далее определяется позиция (пара (m, n) из четверки, определяющей элемент расписания), куда можно перенести выбранное задание. Это задание переносится на случайно выбранную позицию (в которую перенос возможен без нару-

Таблица 1. Вероятность перехода к новому приближению

M(S) > M(Snew)
M(S) = M(Snew)
M(S) < M(Snew)

t < tdir
t > tdir

t < tdir
t > tdir

t < tdir
t > tdir
R > Rdir R < Rdir
1
f1(d)
f1(d)
f2(d)
R > Rdir R < Rdir
f1(d)
f2(d)
f2(d)
f3(d)
R > Rdir R < Rdir
f2(d)
f3(d)
f3(d) 0

шения условий корректности), причем чем раньше по времени стоит задание, занимающее эту позицию в текущий момент, тем вероятнее перенос.
Стратегия заполнения простоев основана на эмпирической гипотезе: чем меньше времени в сумме простаивают процессоры, тем лучше расписание. Для каждой позиции (m, n) можно опре- делить время простоя. Если n = 1, то простой – время от начала работы до начала выполнения задания на позиции (m, 1). Если позиция (m, n) обозначает место после завершения последнего задания на процессоре m, то простой – время от конца работы последнего задания на m до конца выполнения всего расписания. Иначе простой позиции (m, n) – это время между концом работы задания в (m, n – 1) и началом работы задания в (m, n). Из всех позиций выбираются Cpos позиций с максимальным простоем, на которые допустимо переместить выбранное задание, после чего из них выбирается случайно одна позиция, причем наибольший приоритет имеют позиции, зада- ния на которых начинаются раньше по времени. Задание для переноса выбирается случайно (при соблюдении условий корректности), при этом чем позже оно стоит, тем больше вероятность его выбора.
Смешанная стратегия объединяет две предыдущих. В качестве первого параметра операции переноса выбирается одно из Cver заданий с наибольшей задержкой, чем больше задержка, тем больше вероятность выбора задания. Из всех позиций выбираются Cpos позиций с максимальным простоем, на которые допустимо переместить выбранное задание, после чего из них выбирается случайно одна позиция, причем наибольшую вероятность имеют позиции, задания на которых начинаются раньше по времени. Таким образом, в этой стратегии ищутся области в расписании, когда один из процессоров бездействует в ожидании завершения работ на других процессорах, при этом делается попытка поставить задание с большой задержкой как можно раньше, чтобы уменьшить время задержки.
2.4. У с л о в и е п е р е х о д а. После применения выбранной операции получается новое рас- писание, для которого можно рассчитать время выполнения, надежность и число процессоров. В зависимости от соотношений характеристик нового и предыдущего расписаний, новое распи- сание может стать текущим приближением на следующей итерации алгоритма. Как и в стандарт- ном алгоритме имитации отжига, присутствует параметр d, моделирующий температуру. Его на- чальное значение высокое, но с каждой итерацией оно уменьшается.
Вероятность перехода к новому приближению задается тремя функциями f1(d), f2(d), f3(d), ко- торые должны принимать значения от 0 до 1 и убывать с ростом d. Предполагается, что ∀d: f1(d) ≥
≥ f2(d) ≥ f3(d). Вероятности выбора нового расписания в качестве приближения на следующей
итерации для разных соотношений времени, надежности и числа процессоров приведены в табл. 1. Конкретный вид функций, которые были использованы при экспериментальном исследовании алгоритма, представлен в разд. 3.
2.5. Вычислительная сложность и корректность алгоритм а. Вычисли- тельная сложность одной итерации алгоритма составляет O((N + E)2), где N – число вершин гра- фа программы G, а E – число его ребер.
Корректность алгоритма следует из того, что к расписаниям применяются только операции, описанные в разд. 1, а согласно утверждению 3, в результате применения любой из этих опера- ций получается корректное расписание.
3. Экспериментальное исследование алгоритма. 3.1. Классификация исходных дан- н ы х . Все возможные частные задачи рассматриваемой задачи построения расписания можно классифицировать по следующим параметрам: N – число заданий (от 1 до бесконечности), E – число связей между заданиями (от 0 и не более N2), Q – соотношение между суммарным временем выпол- нения заданий и временем передачи данных при отсутствии конфликтов в среде передачи данных. Рассмотрим еще два параметра классификации частных задач, которые определяются отноше- нием директивного срока и оценками нижней границы времени выполнения программы и отно- шением требуемой надежности и оценками верхней границы надежности.

9   ИЗВЕСТИЯ РАН. ТЕОРИЯ И СИСТЕМЫ УПРАВЛЕНИЯ	№ 2	2012

Нижнюю границу времени выполнения программы можно оценить, найдя в графе програм- мы критический путь (путь, имеющий максимальное суммарное время выполнения входящих в него заданий). Эта граница не гарантирует существование решения, так как возможны задержки при выполнении заданий из этого пути из-за передачи данных. Если прибавить к суммарному времени выполнения критического пути суммарное время передачи данных для всех его зада- ний, то получится более реалистичная оценка нижней границы времени выполнения програм- мы. Из-за возможных конфликтов на портах существование решения не гарантируется и в этом случае. Выделим следующие отношения нижних оценок времени выполнения программы к за- данному директивному интервалу.
Невозможное: 0 < tdir < L, где L – длина критического пути. Данный вариант интересен только для исследования поведения алгоритма на заведомо неразрешимых задачах.
Очень жесткое: tdir ≈ L.
Жесткое: tdir ≈ L + K, где K – время передачи данных для всех заданий критического пути. Нормальное: tdir ? L + K.
Заведомо выполнимое: tdir = +∞.
Верхнюю границу надежности системы можно оценить как произведение надежностей всех заданий при использовании максимального доступного числа версий в NVP. Будем считать огра- ничение на требуемую надежность жестким, если оно равно этой верхней границе. Нормальным ограничением будем считать ограничение, достижимое при наличии у каждого из процессоров не больше одного резерва и использования не более трех версий каждого задания.
3.2. Формулировка гипотез и способ  их  проверк и. Гипотеза о субоптималь- ности алгоритма. Пусть E ≈ N, отношения нижних оценок времени выполнения программы к за- данному директивному интервалу и отношения оценок надежности к заданному значению на- дежности нормальные, Q > 1. Пусть
= N
tS	∑C(vi ),
=

Mmin


=
[tS

/t dir ].
i    1
Тогда при любом значении N с уровнем значимости α выполняется гипотеза: алгоритм выдает в качестве результата расписание S, такое, что M(S) ≤ Mmin + 1 с вероятностью не ниже θ0. Число Mmin  – нижняя оценка для минимального числа процессоров, так как если взять меньшее число
процессоров, то с учетом ограничения на время выполнения все задания на них распределить не- возможно. Данная гипотеза утверждает, что алгоритм находит решение, не более чем на единицу превосходящее оптимальное.
Гипотеза о локальной оптимальности алгоритма. Пусть отношения нижних оценок времени выполнения программы к заданному директивному интервалу и отношения оценок надежности к заданному значению надежности нормальные. Тогда при любых значениях N, E, Q с уровнем значимости α выполняется гипотеза: алгоритм с вероятностью не ниже θ0 выдает в качестве ре- зультата расписание S, такое, что для любого расписания S', которое можно получить из S при- менением одной операции, выполняется выражение M(S) ≤ M(S') ∨ t(S') > tdir ∨ R(S') < Rdir.
Данная гипотеза утверждает, что результат, выдаваемый алгоритмом, является локально опти-
м⎯альным, т.е. применение любой операции к этому расписанию не улучшает его характеристики. Гипотезы проверялись с помощью Z-тестов [9] со следующими параметрами: число экспери-
ментов: 100, значимость α = 0.05, вероятность успеха 0 = 0.9. Использовались следующие на- стройки алгоритма: Cver = N/3, Cpos = N/3, pnew = 0.5, pcut = 0.5, число итераций равно 10N, f1(d) = 1 – d/(30N), f2(d) = 1 – d/(20N), f3(d) = 1 – d/(10N). Вероятности выбора операций приведены в табл. 2. В качестве начального приближения алгоритма использовалось расписание, в котором у каждого из заданий была только одна версия, и каждое задание было расположено на отдельном
процессоре.
3.3. Р е з у л ь т а т ы э к с п е р и м е н т о в. Результаты тестов показывают, что гипотеза о суб- оптимальности алгоритма является верной. Наблюдаются небольшие изменения в точности раз- ных стратегий выбора параметров операции переноса заданий и при разном объеме входных данных, но они не являются статистически значимыми. Гипотеза о локальной оптимальности алгоритма также была доказана. Следует заметить, что, несмотря на это, во многих выданных ал- горитмом решениях можно было уменьшить время выполнения (без изменений надежности и числа процессоров) с помощью одной итерации, что не противоречит данной ранее формули- ровке гипотезы. Кроме того, экспериментально была подтверждена ранее полученная теорети-

Ситуация
Добавление процессора
Удаление процессора
Добавление версии
Удаление версии
Перенос задания
t > tdir, R > Rdir
0
1/6
0
1/3
1/2
t < tdir, R > Rdir
0
1/3
0
1/6
1/2
t > tdir, R < Rdir
1/2
0
1/3
0
1/6
t < tdir, R < Rdir
1/3
0
1/2
0
1/6

ческая оценка вычислительной сложности одной итерации алгоритма. Проведенное исследова- ние показало общую эффективность предложенного алгоритма при применении к частным за- дачам, которые возникают при проектировании вычислительных систем реального времени.
Заключение. В рамках данной работы была сформулирована задача синтеза архитектуры вы- числительной системы реального времени с учетом требований к надежности как задача комби- наторной оптимизации. Был разработан итерационный алгоритм решения сформулированной задачи и теоретически обоснована его корректность. Выделен практически значимый класс ис- ходных данных, для которого сформулированы и доказаны статистические гипотезы об основ- ных свойствах алгоритма: субоптимальность алгоритма и его локальная оптимальность.


СПИСОК ЛИТЕРАТУРЫ
1. Калашников А.В., Костенко В.А. Параллельный алгоритм имитации отжига для построения многопро- цессорных расписаний// Изв. РАН. ТиСУ. 2008. № 3. С. 133–142.
2. Калашников А.В., Костенко В.А. Итерационные алгоритмы построения расписаний,
3. основанные на разбиении пространства решений на области // Вестн. МГУ. Сер. 15. Вычислительная математика и кибернетика. 2008. № 3. С. 56–60.
4. Avizienis A., Laprie J.C., Randell B. Dependability and its threats: a taxonomy // Building the Information So- ciety Proc IFIP 18th World Computer Congress. Toulouse, 2004. Р. 91–120.
5. Wattanapongsakorn N., Levitan S.P. Reliability optimization models for embedded systems with multiple appli- cations// IEEE Transactions on Reliability. 2004. V. 53. P. 406–416.
6. Eckhardt D. E., Lee L.D. A theoretical basis for the analysis of multiversion software subject to coincident er- rors// IEEE Transactions on Software Engineering. 1985. V. 11. P. 1511–1517.
7. Laprie J.-C., Arlat J., Beounes C. et al. Definition and analysis of hardware- and software-fault-tolerant archi- tectures// Computer. 1990. V. 23. P. 39–51.
8. Ахо А., Хопкрофт Дж., Ульман Дж. Построение и анализ вычислительных алгоритмов. М.: Мир, 1979. 535 c.
9. Костенко В.А. Задача построения расписания при совместном проектировании аппаратных и про- граммных средств// Программирование. 2002. №3. С.64–80.
10. Ивченко Г.И., Медведев Ю.И. Математическая статистика. М.: Высш. шк., 1984. 248 с.






















ИЗВЕСТИЯ РАН. ТЕОРИЯ И СИСТЕМЫ УПРАВЛЕНИЯ	№ 2	2012	9*Костенко В.А., Винокуров А.В. Локально-оптимальные алгоритмы построения расписаний, основанные на использовании сетей Хопфилда // Программирование. - 2003. - №4 - С.27-40.
ЛОКАЛЬНО-ОПТИМАЛЬНЫЕ АЛГОРИТМЫ ПОСТРОЕНИЯ РАСПИСАНИЙ, ОСНОВАННЫЕ НА ИСПОЛЬЗОВАНИИ СЕТЕЙ ХОПФИЛДА

Костенко В.А., Винокуров А.В.
Факультет вычислительной математики и кибернетики МГУ
119899, Москва, Воробьевы горы

В работе рассматриваются локально-оптимальные алгоритмы построения расписаний выполнения программ в многопроцессорных вычислительных системах, основанные на использовании сетей Хопфилда, и приводятся результаты исследования разработанных алгоритмов.

Введение
В работах [1,2] показано, что большинство задач построения расписаний являются NP-полными в строгом смысле. NP-полнота задач построения расписаний обусловила широкое применение для их решения эвристических алгоритмов, основанных на жадных стратегиях [3,4], и итерационных алгоритмов [3-5]: генетические и эволюционные алгоритмы, алгоритмы имитации отжига, алгоритмы случайного поиска (ненаправленного, направленного, направленного с самообучением), алгоритмы детерминированной коррекции расписания.
Жадные алгоритмы не обладают свойством локализации оптимального решения. Итерационные алгоритмы для локализации оптимального решения требуют специальной настройки параметров, при которых число итераций алгоритма увеличивается и очень часто снижается качество получаемых решений из-за попадания в “плохой” локальный оптимум. Использование сетей Хопфилда [6,7] в алгоритмах построения расписания было обусловлено их свойством быстрой локализации ближайшего оптимума.

1. Постановка задачи построения расписаний
Общая задача построения статических (априорных) расписаний заключается в распределении и упорядочивании множества фиксированных работ (процессов) на заданное число ресурсов (процессоров) таким образом, чтобы оптимизировать желаемую меру эффективности и выполнить заданные ограничения. Прежде чем конкретизировать постановку задачи построения расписаний, определим модели исходных данных и расписания.
При определении модели прикладной программы предполагаем, что выделение работ, подлежащих планированию, и параллелизм, допускаемый при выполнении программы, заданы (выявлены) предварительно. В качестве модели прикладной программы будем использовать частный случай инварианта поведения программы, предложенного в работах [8,9].
Инвариант поведения программы H(PR) (отражает свойства, которые должны сохраняться независимо от среды реализации программы [8]) определим множеством процессов , составляющих программу, и отношением частичного порядка ={ik=(pi,pk)}(i,k)Î(1...N) на множестве P. Отношение ik представляется следующим образом: если , то процесс pi, необходимо выполнить до начала выполнения процесса pk. На  накладываются условия ацикличности и транзитивности. Каждый процесс имеет свой уникальный номер и метку вычислительной сложности. Нумерация процессов является сквозной и удовлетворяет условиям полной топологической сортировки. Вычислительная сложность процесса позволяет оценить время его выполнения на процессоре. Отношение ik определяется номерами смежных процессов и имеет метку, соответствующую объему данных обмена. Объем данных обмена для каждой связи из  позволяет оценить затраты времени на выполнение внешнего взаимодействия.
Модель расписания выполнения программы [3,4,10] определим набором упорядоченных списков (ветвей параллельной программы) {SPi}i=(1...M) и отношением частичного порядка HP на множестве P: HP=({SPi}i=(1...M),HP). SPi образуются процессами, распределенными на один и тот же процессор (M – число процессоров в ВС). Отношение частичного порядка HP на множестве P определим как объединение отношений: HP=c1M, i - отношение полного порядка на SPi, которое определяется порядковыми номерами процессов в SPi; c - набор секущих ребер, которые определяются связями процессов, распределенных на разные процессоры. Если процессы pi и pj распределены на разные процессоры и в  существует связь ij, то она определяет секущее ребро в HP. На HP накладываются условия ацикличности и транзитивности.
Таким образом, расписание выполнения программы определено, если для каждого процесса из множества P заданы: 1)привязка к одному из списков SPi, i(1...M); 2)порядковый номер в соответствующем списке.
Расписание HP является допустимым (интерпретируемо и сохраняет инвариант поведения программы), если выполнены следующие ограничения [3,10,11]:
1. Каждый процесс должен быть назначен на процессор (в SPi): .
2. Каждый процесс должен быть назначен лишь на один процессор (в один SPi): .
3. Частичный порядок, заданный в H должен быть сохранен в HP: .
4. Расписание HP должно быть беступиковым. Условием беступиковости при неограниченном объеме буферов обмена является отсутствие контуров в графе HP: .
В дальнейшем будем говорить, что расписание допустимо , если оно удовлетворяет ограничениям 1-4. Нижний индекс в  указывает ограничения, налагаемые на расписание.
Задачу построения расписаний будем рассматривать в следующем варианте постановки.
Для заданных:
H(PR)=(P,)- инварианта поведения программы,
HW- архитектуры вычислительной системы (ВС): число процессоров фиксировано (M), однородная по типу процессоров, полносвязная,
требуется определить:
HP=({SPi}i=(1...M),HP)- расписание выполнения программы,
при этом должны выполняться условия:
T=f(HP,HW)®min – время выполнения расписания должно быть минимальным,
- должны выполняться ограничения 1-4.
Поскольку класс архитектур ограничен полносвязными однородными архитектурами, вычислительную сложность процессов будем задавать временем выполнения . С учетом однородности и полносвязности архитектуры в это время можно включить затраты времени на взаимодействие с процессами других процессоров.

2. Сети Хопфилда и проблемы их применения для решения задач комбинаторной оптимизации
В общем случае нейросеть может иметь произвольные обратные связи, по которым переданное возбуждение возвращается данному нейрону, и он повторно изменяет свое состояние. Нейродинамика в таких системах становится итерационной. Безитерационная динамика состояний нейронов является, очевидно, всегда устойчивой. Обратные связи могут приводить к возникновению неустойчивости. В нейронных сетях с обратными связями неустойчивость проявляется в блуждающей смене состояний нейронов, не приводящей к возникновению стационарных состояний. В общем случае ответ на вопрос об устойчивости динамики произвольной нейросети с обратными связями крайне сложен и до настоящего времени является открытым.
Модель нейросети Хопфилда (J.J. Hopfield) [6] является частным случаем нейросетевой архитектуры с обратными связями, для которой свойства устойчивости хорошо исследованы. Рассмотрим нейросеть, состоящую из N формальных нейронов (рис.1). Любой нейрон характеризуется степенью возбуждения (состоянием) , . Каждый нейрон связан со всеми остальными (граф, описывающий сеть, - полный). Силу связи (вес связи) -го нейрона с -ым обозначим . В модели Хопфилда предполагается условие симметричности связей  с нулевыми диагональными элементами .

Рис.1. Нейросеть с обратными связями.

Изменение состояния каждого нейрона  в модели Хопфилда происходит по правилу для формальных нейронов МаккКаллока-Питтса. Поступающие на входы -го нейрона сигналы  в момент времени  взвешиваются с весами матрицы связей и суммируются, определяя полный уровень силы входного сигнала :

Далее в момент времени  нейрон определяет свое состояние в зависимости от уровня сигнала и индивидуального порога  [6,7]:

Определение состояния может носить стохастический характер - выбирается произвольный нейрон и его состояние определяется по выше приведенному правилу - стохастическая динамика [7]. Возможно одновременное определение состояний всех нейронов, тогда говорят о параллельной динамике [7]. Также рассматривается и последовательная динамика [7], при которой определение состояний нейронов происходит циклично, по одному нейрону за итерацию. Многочисленные исследования показали, что свойства нейросети практически не зависят от типа динамики. При моделировании нейросети на обычном компьютере удобнее использовать стохастическую или последовательную динамику, а в аппаратных реализациях нейросети Хопфилда применяется параллельная динамика.
Совокупность значений состояния всех нейронов в некоторый момент времени образует  - вектор состояния сети. Нейродинамика приводит к изменению вектора состояния . Конец вектора состояний при этом описывает траекторию в пространстве состояний нейросети. Это пространство для сети с двумя уровнями возбуждения каждого нейрона представляет собой множество вершин гиперкуба размерности , равной числу нейронов. Возможные наборы значений координат вершин гиперкуба определяют возможные значения вектора состояний.
Рассмотрим проблему устойчивости динамики изменения состояний. Определим энергию нейросети Хопфилда следующим образом [6,7]:
.
Поскольку на каждом временном шаге некоторый нейрон  изменяет свое состояние в соответствии со знаком величины , то всегда верно следующее неравенство:
, где 
 - вклад -го нейрона в энергию нейросети.
Таким образом, энергия нейросети , может либо убывать, либо сохранять свое значение в процессе нейродинамики.
Поскольку число нейронов в сети конечно, функция E ограничена снизу и обладает свойством невозрастания при изменении состояний нейронов, то она является для нейросети функцией Ляпунова. Поведение такой динамической системы устойчиво при любом исходном векторе состояний  и при любой симметричной матрице связей  с нулевыми диагональными элементами. Сеть приходит в стационарное состояние в одном из минимумов функции Ляпунова, причем состояния всех нейронов будут совпадать по знаку с входными сигналами .
Задача составления расписаний относится к классу задач комбинаторной оптимизации с ограничениями. В зависимости от способа представления расписаний [3,10] задача может быть представлена как бинарная или целочисленная задача оптимизации с ограничениями. В отличие от задач целочисленного или бинарного математического программирования комбинаторный характер задачи создает проблему согласованного изменения задающих расписание переменных для получения на очередной итерации алгоритма допустимого варианта расписания. Данные свойства задачи делают неприемлемым использование традиционных локально-оптимальных методов, например градиентных. Для локальной оптимизации (улучшения) расписаний используются алгоритмы, основанные на перестановке отдельных процессов в соответствии с некоторыми локальными критериями эффективности [12,13]. Однако подобные алгоритмы не гарантируют нахождение локального оптимума. Использование сетей Хопфилда в алгоритмах построения расписаний делает возможным гарантированное нахождение локального оптимума.
Применение сетей Хопфилда для решения задач комбинаторной оптимизации с ограничениями требует решения следующих проблем:
1. Выбор “нейронного” представления задачи – установление соответствия между состояниями нейронов и значениями оптимизируемых параметров.
2. Построение функции энергии сети с учетом целевой функции и ограничений и приведение ее к симметричной квадратичной форме. Функция энергии сети в точках минимума целевой функции должна также иметь точки минимума. При нарушении ограничений должны вводится штрафы, увеличивающие значение функции энергии.
3. Определение значений весов сети и порогов, т.е. установление соответствия между членами в построенной функции энергии сети и членами общей формы энергии сети.
4. Определение весовых коэффициентов при штрафных функциях.

3. Построение расписаний для набора независимых процессов
В данном разделе рассмотрим сети Хопфилда и результаты их исследования для решения задачи построения расписаний при . В этом случае для сохранения инварианта поведения программы достаточно выполнение лишь первых двух ограничений на расписание, т.е. .
Нейронное представление расписания можно задать, используя лишь матрицу привязки [3,10,11] S(HP)NM, где элемент матрицы определяется:
.
Вектор состояний нейросети Хопфилда имеет размер и может быть представлен в виде матрицы:
	, 
где M – количество процессоров, N – количество процессов.
Для данной конфигурации нейросети Хопфилда общая форма функции энергии имеет следующий вид:
.
Рассмотрим функцию , где 
,  , - время выполнения процесса ,
,
.
Функция отвечает за равномерное распределение процессов по процессорам. Функциииявляются штрафными функциями, они отвечают за выполнения ограничений 1 и 2 соответственно.  отвечает за то, чтобы каждый процесс был назначен на процессор (в SPi),  отвечает за то, чтобы каждый процесс был назначен лишь на один процессор (в один SPi).
Чтобы использовать нейросеть Хопфилда для минимизации функции  необходимо вычислить весаи порогинейросети. Для этого нужно разрешить уравнениев смысле неизвестныхи . Если веса и пороги задать следующим образом:
,
, 
,
то получим (см. приложение 1), что функция  равна энергии с точностью до константы: 
, 
Из этого равенства следует, что минимумы функции энергии  совпадают с минимумами функции , т.е. функция  будет минимизироваться в процессе динамики нейросети.
Для окончательного решения задачи необходимо найти . Без ограничений общности можно считать  и искать только коэффициенты и. Коэффициенты  и  при штрафных функциях оказывают сильное влияние на динамику нейросети Хопфилда и являются предметом исследования. Ниже приведены результаты численных исследований для .

Результаты численного исследования
В таблицах1-4 приведены результаты численного исследования алгоритма. Для каждого графа производилось 1000 запусков алгоритма. Во всех таблицах используются следующие обозначения:
- число процессов;
- суммарное время работы всех процессоров на ВС с одним процессором:;
- среднее отклонение : ;
- минимальное из ;
-максимальное из ;
-число процессоров;
- лучшее из времен выполнения расписаний, полученных алгоритмом;
- загрузка процессоров, соответствующая:  ;
- среднее время выполнения расписаний, получаемых алгоритмом, по всем запускам;
- среднее число итераций, производимое алгоритмом (включая те случаи, когда алгоритм сходится к недопустимому решению), одна итерация сети – срабатывание одного нейрона;
 - величина, показывающая процент допустимых решений из общего числа запусков;
- время выполнения расписания, полученного эвристикой;
 - загрузка процессоров, полученная эвристикой.
В таблице 1 начальное приближениезадается случайным образом, т.е. для используется следующее распределение вероятностей: :

Таблица 1

Исследования показали, что количество корректных решений составляет в среднем 33.8% процентов, при этом процент загрузки процессоров 98.8%, количество итераций в среднем составляет.
В таблице 2 начальное приближениезадается с помощью эвристики [14].

									Таблица 2.

В случае если начальное приближение получено эвристикой процент допустимых решений в среднем возрастает до 55.6%, процент загрузки процессоров снижается в среднем до 95.5%, число итераций снижается до . Эти три явления связаны с тем, что в данном случае сеть Хопфилда скатывается к ближайшему локальному минимуму. Как видно из таблицы 2, разным начальным приближениям могут соответствовать разные локальные минимумы. 
Влияние размеров задачи приведено в таблице 3, - варьируются, , начальное приближениезадается случайным образом.

									Таблица 3.

В среднем с ростомзагрузка процессоров увеличивается. Это связано с тем, что при  и увеличениизначения  уменьшаются. С ростом числа процессоров их загрузка уменьшается. Количество корректных решений с ростомпадает, а с ростом в среднем возрастает. 
Влияние среднего отклонения  приведено в таблице 4, , , , - варьируется, начальное приближениезадается случайным образом.

									Таблица 4.

Исследования влияния значения среднего отклонения  показали, что по мере уменьшения отклонения процент корректных решений возрастает и уменьшается количество итераций.

4. Построение расписаний для процессов с произвольными связями
Если , то для сохранения инварианта поведения программы необходимо выполнение ограничений 1-4 на расписание, т.е. . Были рассмотрены различные варианты нейронного представления расписания при . Самый экономичный (из рассматривавшихся) вариант представления расписаний, позволяющий построить функцию энергии сети, требует  нейронов. Количество слагаемых в функции энергии сети, отвечающих за штрафы, при этом возрастает до семи. Некоторые из этих слагаемых имеют четвертую степень. При сведении построенной функции энергии сети к квадратичной форме пришлось сделать ряд априорных допущений. Возникает также проблема выбора значений весовых коэффициентов при слагаемых в функции энергии сети.
Вычислительные эксперименты с построенной сетью (при использовании асинхронной случайной динамики) показали ее низкую эффективность с точки зрения процента получаемых допустимых вариантов расписания. При случайном задании HP0 число допустимых расписаний (), получаемых сетью, составляет всего 0.5%.
В следующем разделе рассматривается подход позволяющий решить проблему получения недопустимых вариантов расписаний сетью Хопфилда при.

5. Комбинирование сети Хопфилда и жадных эвристических алгоритмов
Из приведенных в работах [3,5] свойств жадных и генетических алгоритмов следует, что изменение привязки процессов к процессорам оказывает более сильное влияние на время выполнения расписания, чем изменение порядка выполнения процессов на процессорах при фиксированной привязке.
На основании свойства о влиянии привязки и порядка можно предложить следующий комбинированный алгоритм построения расписаний:
1. Получение привязки сетью Хопфилда при предположении .
2. Получения порядка жадным эвристическим алгоритмом с учетом привязки, полученной в п.1, и заданного .
Утверждение 1. Локальному оптимуму  функции T=f(HP,HW) для HP без учета  (т.е. в предположении ), может соответствовать множество локальных оптимумов функции T=f(HP,HW) для HP с учетом .
Зафиксируем привязку процессов к процессорам для некоторого локального оптимума при . Тогда различные варианты расписания будут отличаться лишь порядком процессов на процессорах. Если  при , то при  соответствующее . При  все эти варианты расписаний имеют одно и тоже время выполнения . При  различные варианты могут иметь различное время выполнения. Следовательно, возможно, что в этом случае одной и той же привязке процессов к процессорам будет соответствовать некоторое множество локальных оптимумов.
Утверждение 2. Значение  является нижней гранью множества .
Справедливость этого утверждения следует из того, что любое расписание из множества  является также допустимым вариантом расписания  при предположении  () и всегда выполняется неравенство .
Предположение 1. Если  и  два различных локальных оптимума при , ,  соответствующие им множества локальных оптимумов при  и , то справедливо .
Если предположение 1 справедливо и выполняется условие “различные способы привязки процессов к процессорам оказывают более сильное влияние на время выполнения расписания, чем различные способы порядка выполнения процессов на процессорах при фиксированной привязке”, то комбинированный алгоритм “сеть Хопфилда-эвристика” может находить с высокой скоростью достаточно близкий вариант расписания к одному из локальных оптимумов соответствующих заданному начальному приближению HP0 (в зоне притяжения HP0 находится соответствующий множеству  локальный оптимум ) и полученное .
Ниже описан алгоритм получения порядка с одновременным получением оценки времени выполнения расписания. Все процессы  разобьем на три множества: . Где - множество процессов, распределенных в SP (определен порядковый номер рабочего интервала) алгоритмом на предыдущих шагах, - множество процессов, у которых все предшественники (в соответствии с отношением) принадлежат множеству, - множество процессов, у которых хотя бы один из предшественников не принадлежит множеству. Приведём алгоритм получения порядка при известной привязке процессов к процессорам:
1. Полагаем, - содержит процессы без предшественников, - все остальные процессы.
2. Находим в  процесс с наибольшим приоритетом и переносим его в , одновременно определяем время его инициализации.
3. Проверяем  с целью возможности переноса процессов в (все предшественники принадлежат).
4. Если , то переходим к шагу 2, иначе завершаем работу.
Модификации этой эвристики отличаются способом введения приоритетов. Для численного исследования алгоритма была выбрана схема приоритетов, основанная на том, что наивысшим приоритетом во множестве  обладает тот процесс, который обеспечивает наименьший простой соответствующего процессора из-за ожидания инициализации процесса.

Результаты численного исследования
Результаты численного исследования алгоритма “сеть Хопфилда – эвристика“ приведены в таблицах 5 и 6. Дополнительные обозначения, используемые в таблицах 5 и 6:
 - критический путь (по времени выполнения);
 - тип графа: - ориентированное дерево, - ориентированный граф с произвольной структурой связей,  - набор цепочек.
В таблице 5 приведены результаты численного исследования при задании начального приближенияслучайным образом. 

									Таблица 5.

В таблице 6 приведены результаты численного исследования при задании начального приближенияс помощью эвристики [14].

										Таблица 6.

Исследования показали, что для графов с произвольными связями и деревьев алгоритм улучшает решение, полученное эвристикой. Время выполнения уменьшается в среднем на 15.8%. Для набора цепочек (Chain) и некоторых видов деревьев (Tree) алгоритм дает плохое решение. Для набора цепочек решения, получаемые эвристикой, даже лучше. В этом случае качество решения, возможно, удастся улучшить подбором алгоритма получения порядка. Все полученные решения очень сильно зависят от начального приближения.

6. Проблемы мультистарта и увеличения скорости сходимости
Автономное использование сетей Хопфилда
Автономное использование сетей Хопфилда или комбинированного алгоритма (“сеть Хопфилда-эвристика“) для решения задачи построения расписаний создает проблему выхода из локальных оптимумов. Что присуще всем локально-оптимальным алгоритмам. Данная проблема обычно решается введением механизма мультистарта. При произвольном задании начального приближения HP0 количество стартов для нахождения приемлемого варианта решения может быть велико. Что объясняется нерегулярностью (большим количеством локальных оптимумов) функции T=f(HP,HW).
Для решения проблемы уменьшения числа стартов алгоритма предлагается ввести обратную связь, т.е. очередное начальное приближение HP0 выбирать не произвольным образом, а направленной коррекцией расписания, полученного на предшествующем старте алгоритма.
Направленная коррекция предполагает анализ расписания, полученного на предшествующем старте алгоритма. При анализе расписания выделяются следующие множества процессов:
- множество процессов, которые обуславливают простои процессоров,
- множество процессов, которые обуславливают задержки инициализации (из-за ожидания завершения их выполнения) процессов из множества .
Направленная коррекция расписания с целью получения очередного начального приближения HP0 может осуществляться двумя способами:
1. Для процессов из множества , которые обуславливают простой процессоров превосходящих заданный порог , и соответствующих им процессов из множества  применяется операция O2 – перестановки их в другой SP [3,10,11].
2. Для процессов из множества , которые обуславливают простой процессоров превосходящих заданный порог , и соответствующих им процессов из множества  осуществляется увеличение (для процессов из ) и уменьшение (для процессов из) времени их выполнения на значение . Сеть Хопфилда работает с моделью H, в которой используются измененные времена выполнения процессов. Эвристика и вычисление значения функции T=f(HP,HW) осуществляется для исходно заданных времен выполнения процессов. Данный способ можно рассматривать как алгоритм обучения сети Хопфилда, поскольку для каждого запуска пересчитываются значения весов сети.

Возможность увеличения скорости сходимости
Скорость сходимости сети Хопфилда, может быть увеличена введением парной динамики: если некоторый нейрон изменил свое состояние (например, в первой строке матрицы S(HP)NM появилась еще одна единица), то проверяется на возможность изменения состояния соответствующий ему парный нейрон или группа нейронов (нейрон первой строки находящийся в состоянии “1”). Если данный нейрон не изменяет своего состояния, то он заносится в “черный” список. Нейроны из “черного” списка определяют свое состояние с повышенной частотой.

Заключение
Разработанные сети Хопфилда для решения задач построения расписаний ориентированы на совместное применение с жадными и итерационными эвристическими алгоритмами. Сеть Хопфилда использует в качестве начального приближения расписание, полученное эвристическим алгоритмом, и осуществляет его доводку до соответствующего локального оптимума. Приведенные результаты вычислительных экспериментов показали высокую скорость локализации оптимума и возможность улучшения качества расписаний, получаемых эвристическими алгоритмами.
При введении механизмов мультистарта возможно автономное использование разработанных сетей Хопфилда для решения задач построения расписаний.
Комбинированный алгоритм (“сеть Хопфилда-эвристика”) легко позволяет расширить область применения для более общих моделей инварианта поведения программы и расписаний: процесс может содержать более одного рабочего интервала. Единицами планирования в этом случае являются рабочие интервалы. То есть комбинированный алгоритм может быть использован при решении задач многостадийного планирования.

Список литературы
1. Теория расписаний и вычислительные машины/ Под ред. Э.Г.Коффмана. М.: Наука, 1984. - 334с.
2. Гэри М., Джонсон Д. Вычислительные машины и трудно решаемые задачи. - М.: Мир, 1982. - 416с.
3. Костенко В.А. Построение расписаний при совместном проектировании аппаратных и программных средств ВС реального времени// Труды Меж. конф. "Параллельные вычисления и задачи управления" (РАСО'2001) - М.: ИПУ РАН, 2001., с.125-141.
4. Костенко В.А. Задачи синтеза архитектур: формализация, особенности и возможности различных методов для их решения// Программные системы и инструменты. Тематический сборник. - M.: МАКС Пресс, 2000., № 1, С.31-41.
5. Костенко В.А., Смелянский Р.Л., Трекин А.Г. Синтез структур вычислительных систем реального времени с использованием генетических алгоритмов// Программирование, 2000., №5, С.63-72.
6. Hopfield J.J. Neural networks and physical systems with emergent collective computational abilities. Proceedings of the National Academy of Science, 1982.
7. Уоссермен Ф. Нейрокомпьютерная техника: Теория и практика. – М.: Мир, 1992. – 240с.
8. Смелянский Р.Л. Об инварианте поведения программ// Вестн. МГУ, сер. 15, Вычислительная математика и Кибернетика, 1990., No. 4, С. 54-60.
9. Смелянский Р.Л. Модель функционирования распределенных вычислительных систем// Вестн. Моск. Ун-та. сер 15, Вычисл. Матем. и Кибернетика. 1990, No. 3, стр. 3-21.
10. Костенко В.А. Задача построения расписания при совместном проектировании аппаратных и программных средств// Программирование, 2002., . №3, С.1-16.
11. Костенко В.А. Способы представления и преобразования расписаний в итерационных алгоритмах// Программные системы и инструменты. Тематический сборник. - M.: МАКС Пресс, 2001., № 2, С.53-69.
12. P.Brucker, J.Hurink, F.Werner. Improving local search heuristics for some sheduling problems. Discrete Applied Mathmatics, 1997., N 72, pp.34-72.
13. Григорьева Н.С.,Федорова И.А. Алгоритмы поиска в локальной окрестности для задачи параллельного упорядочивания// Дискретная математика и математическая кибернетика: Труды международной школы-семинара. – М.: МАКС Пресс, 2001. – С.18.
14. Костенко В.А., Романов В.Г., Смелянский Р.Л. Алгоритмы минимизации аппаратных ресурсов ВС// Искусственный интеллект (Донецк), 2000., No2, С.383-388.

Приложение 1.
Определение весов сети и порогов.
В данном приложении приведен вывод значений весов и порогов нейросети Хопфилда для задачи построения расписания при . Преобразуем функции , ,  к виду квадратичной формы:






Таким образом, функция  принимает следующий вид:


Если веса и пороги задать следующим образом:
,
, 
где ,
то получим, что функция равна энергии с точностью до константы: 
.

Костенко В.А., Кунцьо С.Ю. Задача построения расписания обменов для вычислительных систем реального времени с коммутатором // Методы и средства обработки информации. Труды третьей Всероссийской научной конференции. - М.: Издательский отдел факультета ВМиК МГУ имени М.В. Ломоносова; МАКС Пресс, 2009. - С.259-265.

В.А. Костенко, Кунцьо С.Ю.
ЗАДАЧА ПОСТРОЕНИЯ РАСПИСАНИЯ ОБМЕНОВ ДЛЯ ВЫЧИСЛИТЕЛЬНЫХ СИСТЕМ РЕАЛЬНОГО ВРЕМЕНИ С КОММУТАТОРОМ 
Фак-т. ВМиК МГУ им.М.В.Ломоносова, Москва,
 Email: kost@cs.msu.su,  steplg@gmail.com 
1. Введение. В работе сформулирована задача построения статических расписаний обменов без прерываний для вычислительных систем реального времени (ВСРВ) со средой обмена, построенной на основе коммутатора. Предложен алгоритм построения расписаний, использующий идеи алгоритмов решения японских кроссвордов. Актуальность формулировки задачи построения расписаний обменов для коммутатора, которая учитывает требования передачи сообщений в реальном времени, и разработки алгоритмов ее решения обусловлена тем, что многие разработчики ВСРВ рассматривают стандарт Fibre Channel [1] как основной для построения среды обмена [2]. Одной из базовых топологий стандарта является коммутатор.
2. Задача построения расписания обменов. Будем рассматривать среду обмена, состоящую из одного коммутатора и N подключенных к нему устройств . Каждое устройство одновременно может участвовать только в одном обмене.
Обмен данными в среде происходит путем передачи сообщений. На размер передаваемых в сообщении данных ограничений не накладывается. Каждое сообщение на уровне сети разбивается на набор кадров, длина данных в каждом из которых не превышает 2112 байт и кратно четырем. Эти условия накладываются стандартом Fibre Channel, однако не являются принципиальными и могут быть изменены под конкретный стандарт организации сетевого обмена. 
Мы будем рассматривать организацию сетевого обмена с установлением соединения и с подтверждением о доставке каждого кадра. Любая передача сообщения должна будет начинаться с отправки устройством-источником служебного сообщения на установление соединения устройству-приемнику, а в конце передачи сообщения источник будет обязан дождаться подтверждения о доставке и закрытии соединения от приемника. Эти служебные сообщения в соответствии со стандартом Fibre Channel помечаются определенными флагами в заголовке сообщения.
Время доставки одного кадра, содержащего в себе  байт данных от устройства  до устройства :
,
где  – длина канала от устройства-источника до коммутатора,  – длина канала от устройства-приемника до коммутатора  – задержка на коммутаторе,  – частота передачи устройством данных в сеть,  – скорость передачи данных по сети.
Набор сообщений, представляет собой множество . Каждому сообщению сопоставлены следующие атрибуты:
 (байт) — размер передаваемых данных,
 — номер устройства-источника,
— номер устройства-приемника, 
— директивный срок начала передачи сообщения,
— директивный срок получения сообщения.
Время необходимое для передачи одного сообщения составит:
,
где  – количество байт в первом кадре, – количество фреймов, требуемых для передачи сообщения, – максимальный возможный размер передаваемых данных в кадре.
Расписание, соответствующее набору сообщений M, представляет собой множество , в состав которого входят сообщения из M (все или часть). Каждому сообщению  сопоставлен атрибут – время начала передачи сообщения . 
Будем называть расписание корректным, если выполняются следующие условия: 
1. Передача сообщения должна выполняться в рамках директивного интервала:

2. В любой момент времени любое оконечное устройство может участвовать только в одном обмене:

Пусть задан набор сообщений  и характеристики среды обменов: . Требуется построить расписание передачи сообщений такое что , где  – множество всех возможных корректных расписаний для заданных  и .
Если рассмотреть частный случай сформулированной задачи для одного коммутатора и двух устройств, то он полиномиально сводится к задаче построения расписания обменов для двух устройств, соединенных шиной с централизованным управлением. Данная задача является NP-трудной задачей построения однопроцессорного расписания без прерывания для заданного набора работ с индивидуальными директивными сроками выполнения [3]. Отсюда можно сделать вывод о принадлежности сформулированной задачи к классу NP-трудных задач.
3. Алгоритм японских кроссвордов и идея его применения для построения расписаний обменов. В японском кроссворде в отличие от обычного кроссворда, зашифрованы не слова, а изображение. Поле кроссворда представляет собой расчерченный на клетки лист фиксированного размера. При решении японского кроссворда необходимо восстановить картинку по числам, которые проставлены слева от строк и над колонками. Числа в сетке японского кроссворда показывают, в какой последовательности должны быть расположены группы черных клеток в соответствующей строке или столбце и сколько слитных черных клеток содержит каждая группа. При этом между двумя последовательными группами должна быть как минимум одна пустая клетка.
Основная идея решения японских кроссвордов [4] заключается в том, чтобы по заданным длинам групп вычислить те области, которые либо точно будут закрашены, либо точно останутся пустыми. Итеративно повторяя данный процесс, возможно «раскрасить» все поле японского кроссворда.
Рассмотрим, как можно применить идею алгоритмов решения японских кроссвордов для нахождения аналогичных участков (область точного размещения и область точного неразмещения соответственно) в расписании обменов. На рисунке 1 приведен пример задания исходных данных для алгоритма. Различными штриховками обозначаются три разных сообщения. Вертикальные линии отмеряют такты, горизонтальные линии соответствуют портам . Директивные интервалы могут пересекаться, что изображается в виде пересечений соответствующих прямоугольников. Так же в передаче одного сообщения участвуют всегда ровно два порта – именно поэтому для каждого сообщения всегда существует ровно два прямоугольника, расположенных на двух разных портах и занимающих один и тот же промежуток времени. Т.е. возможные клетки для закрашивания определяются директивными интервалами сообщений, количество групп на каждой линии определяется числом сообщений, которым требуется для передачи сообщения соответствующий линии порт, длина группы определяется временем передачи соответствующего сообщения.


Рисунок 1. Расположение директивных интервалов на диаграмме состояний портов.
Алгоритм японских кроссвордов работает в предположении, что всегда существует решение, в котором все заданные группы черных клеток размещены. Однако для сформулированной в разделе 2 задачи построения расписания обменов может не существовать корректного расписания, содержащего все сообщения из заданного исходного набора. В следующем разделе предложен алгоритм, учитывающий это отличие задач построения расписаний и задач решения японских кроссвордов, а также учитывающий, что при размещении сообщения закрашиваются две линии.
3. Алгоритм построения расписания обменов, использующий алгоритм решения японских кроссвордов. Окном будем называть директивный интервал для заданного сообщения. Связанным с окном сообщением будем называть сообщение, которое должно быть размещено в рамках выбранного окна. Область окна — интервал, целиком лежащий внутри заданного окна, которому приписано одно из состояний: 
занято — в данный промежуток времени уже передается какое-то сообщение на одном из портов, который требуется для передачи связного с окном сообщения, 
используется — в данный промежуток времени передается связное с окном сообщение, 
неопределено — ни один из предыдущих пунктов. 
Назовем i-тое окно связанным с k-той областью j-того окна, если интервалы i-того окна и k-той области j-того окна пересекаются, а сообщения, связанные с i-тым и j-тым окном, претендуют на один и тот же порт.

Рисунок 2. Промежуточный этап работы алгоритма японских кроссвордов.
На рисунке 2 показан промежуточный этап работы алгоритма японских кроссвордов. Директивные интервалы обозначаются прямоугольной рамкой, две области точного размещения (для первого и второго сообщений) обозначаются темной штриховкой, две области точного неразмещения (для первого и третьего сообщений) обозначаются незакрашеными прямоугольниками, три неопределенные области (для второго и третьего сообщений) обозначаются светлой штриховкой.
Схему алгоритма можно представить следующим образом:
I. Начальная инициализация. 
1. Для каждого окна (количество окон равно числу сообщений в исходно заданном наборе M) создаем одну область, которая совпадает с самим окном и имеет статус «неопределено». 
2. Помечаем все окна, как обновленные.
II. Построение областей точного размещения (статус области «используется») и точного неразмещения (статус области «занято»). 
1. Вызвать операцию выбора обновленного окна.
2. Вычислить для выбранного окна область точного размещения, используя стратегии решения японских кроссвордов [4]: простые блоки (simple boxes), простые пробелы (simple spaces), форсирование (forcing).
3. Если границы и набор областей окна изменились, то для каждой области окна, которая изменила свое состояние в связных с ней окнах обновить границы и статус соответствующих областей на «занято» и пометить окна как обновленные.
4. Если сообщение связное с выбранным окном невозможно разместить в расписание без нарушения ограничений на корректность, то: 1)поместить его в список неразмещенных, 2)удалить соответствующее ему окно из множества окон. (Примечание: при этом возможно изменение статусов и границ областей, связанных с областями удаленного окна со статусом «используется». В данной версии алгоритма это не используется.).
5. Проверить «полностью ли размещено сообщение, связное с выбранным окном» (т.е. длина области окна со статусом «используется» равна времени передачи, связного с окном сообщения). Если да, то исключить окно из множества окон. 
6. Если есть обновленные окна, то переход к п. II.1.
III. Эвристическое заполнение областей со статусом «неопределено». 
1. Если множество окон не пусто (т.е. в каждом из них есть области со статусом «неопределено»), то переход к п.III.2, иначе завершить работу алгоритма.
2. Вызов операции выбора области окна такой, что или справа, или слева от нее располагалась область со статусом «используется».
3. Изменение статуса выбранной области на статус «используется» и переход к пункту II.4.
Эвристическая операция выбора обновленного окна. Выбираем такое окно, для которого среднее значение профиля по всем его областям со статусом «неопределенно» минимально. Под профилем здесь понимается функция двух переменных . Значением функции в каждой точке является количество неопределенных областей для порта p в момент времени .
Эвристическая операция выбора области окна. Выбираем такую область окна со статусом «неопределенно», рядом с которой находится область со статусом «используется», для которой среднее значение профиля минимально.
В качестве критериев выбора окна в этих операциях могут также использоваться и критерии, имеющие меньшую вычислительную сложность: выбор такого окна, что связное с ним сообщение имеет минимально возможное время завершения передачи или минимальный директивный срок получения сообщения.
В случае, если не существует полного расписания (включающего все сообщения из заданного набора), порядок выбора окон будет влиять на результат, то есть на то, какие сообщения попадут в расписание, а какие в список неразмещенных. А значит критерий выбора окна, будет влиять на точность алгоритма. Подбирая критерий, по которому будет выбираться окно, можно осуществлять настройку алгоритма на частные задачи сформулированной в разделе 2 задачи построения расписания обменов. Частная задача получается путем введения дополнительных ограничений на исходные данные.
Верхняя оценка сложности алгоритма равна , где , - количество портов. Однако реальная сложность алгоритма для большинства частных задач, у которых среднее значение значительно меньше ее верхней оценки, при этом, чем меньше значение, тем меньше сложность алгоритма. Кроме того, для задач, имеющих полное корректное расписание, уменьшение  приводит к увеличению точности работы алгоритма.
1. FC-FS _ стандарт Fibre Channel «Framing and Signalling» [PDF] ftp://ftp.t11.org/t11/pub/fc/fs/98-146v1.pdf.
2. Павлов А.М. Коммерческая сетевая информационная технология для применения в военных проектах// Мир компьютерной автоматизации. 2000. № 4.
3. Гэри М., Джонсон Д. Вычислительные машины и трудно решаемые задачи. - М.: Мир, 1982.
4. Ueda, Nobuhisa; Nagao, Tadaaki (1996), NP-completeness results for NONOGRAM via Parsimonious Peduction, TR-96-0008, Technical Report, Departament of Computer Science, Tokyo Institute of Technology.Костенко В.А. Алгоритмы построения расписаний для одноприборных систем, входящих в состав систем реального времени // Методы и средства обработки информации. Труды третьей Всероссийской научной конференции. - М.: Издательский отдел факультета ВМиК МГУ имени М.В. Ломоносова; МАКС Пресс, 2009. - С.245-258.

В.А. Костенко
АЛГОРИТМЫ ПОСТРОЕНИЯ РАСПИСАНИЙ ДЛЯ ОДНОПРИБОРНЫХ СИСТЕМ, ВХОДЯЩИХ В СОСТАВ СИСТЕМ РЕАЛЬНОГО ВРЕМЕНИ
Фак-т. ВМиК МГУ им.М.В.Ломоносова, Москва,
 Email: kost@cs.msu.su 
1.Введение. В данной работе рассматриваются алгоритмы построения статических расписаний без прерываний для одноприборных систем, входящих в состав систем реального времени (ВСРВ). Рассматриваемые алгоритмы позволяют строить расписания выполнения набора прикладных программ для однопроцессорных вычислительных узлов, расписания обменов для каналов информационного обмена с централизованным управлением и каналов информационного обмена с распределённым управлением и единым временем на абонентах канала.

2. Задача построения расписания. В работе [1] показано, что для одноприборных систем, входящих в состав ВСРВ, задача построения статических расписаний без прерываний в общем виде может быть сформулирована следующим образом.
Дано:
Множество работ, которые должны выполняться на системе . Для каждой работы заданы - время выполнения, - директивный интервал выполнения и выполняется условие ;
Дополнительные ограничения на корректность расписания , которые обусловлены технологическими требованиями к расписанию;
Вектор значений технологических требований .
Требуется построить расписание выполнения работ, которое представляет собой упорядоченное (по критерию время начала выполнения работы) множество .(k - порядковый номер j-ой работы в расписании) и такое что:



Здесь  - время начала выполнения j-ой работы в расписании ,  - время завершения выполнения j-ой работы.
Ограничения g1,g2,g3 являются обязательными для одноприборных расписаний без прерываний и соответственно означают: 
1) интервал выполнения каждой работы располагается в рамках её директивного интервала;
2) не допустимы прерывания;
3) интервалы выполнения работ не пересекаются.
Ограничения  определяются технологическими требованиями к расписанию (схемой обменов или вычислений, особенностями аппаратных и программных средств ВСРВ, требованиями к отказоустойчивости).
Для циклической схемы (интервал планирования разбивается на отрезки равной длины - подциклы), возможны следующие дополнительные ограничения (gi) [1]:
4) в каждом подцикле может находиться не более 1 цепочки работ и работы в цепочке следуют друг за другом без пауз;
5) время выполнения работ не должно пересекать границы подцикла;
6) время начала цепочки работ относительно начала соответствующего подцикла не должно быть меньше заданного значения;
7) в конце подцикла должен быть зарезервирован интервал времени, длительность которого не меньше, чем заданная доля  длительности подцикла;
8) число работ в цепочке не должно превышать заданного значения;
9) сдвиг работы «вправо» по временной оси на время, не превышающее значение равное заданному проценту от интервала «время начала выполнения работы минус время начала цепочки» не должен приводить к нарушению директивного времени завершения работы  или требования к минимальному резерву времени в конце подцикла;
В схеме без подциклов возможны следующие дополнительные ограничения (gi):
4) число работ в цепочке не должно превышать заданного значения;
5) суммарная длительность выполнения работ цепочки не должна превышать заданного значения;
6) интервал времени между последовательными цепочками должен быть не меньше заданного значения;
7) сдвиг работы «вправо» по временной оси на время, не превышающее значение равное заданному проценту от интервала «время начала выполнения работы минус время начала цепочки» не должен приводить к нарушению директивного времени завершения работы или требования к минимальному интервалу времени между последовательными цепочками.
В [1] показана возможность представления ограничений 6-9 для циклической схемы и ограничений 4-7 для схемы без подциклов в виде условий , где функция , - множество всевозможных векторов значений требований, {H} – множество расписаний удовлетворяющих ограничениям 1-3. Ограничения 4,5 для циклической схемы могут быть представлены предикатами аналогично обязательным ограничениям 1-3. Отметим, что ограничения на корректность расписания могут проверяться при размещении работы в расписание. Если все работы размещались в расписание без нарушения ограничений, то полученное расписание будет корректным.
Для каналов информационного обмена обычно задается в набор сообщений. Для каждого сообщения указывается частота передачи или частота передачи и фазовые сдвиги границ директивного интервала от левой и правой границы периода выполнения сообщения или набор директивных интервалов передачи сообщения. К введенному в общей постановке способу представления работ (для каждой работы задан директивный интервал), указанные выше способы могут быть сведены путем формирования для каждого сообщения набора работ. Количество работ в наборе, если для сообщения задана частота передачи, определяется интервалом планирования и требуемой частотой выполнения сообщения, а директивные интервалы для работ из набора вычисляются исходя из частоты, фазовых сдвигов и номера работы в наборе. Количество работ в наборе, если для сообщения задан набор директивных интервалов, определяется количеством заданных директивных интервалов передачи сообщения. В этом случае для ряда каналов с централизованным управлением вводится еще одно дополнительное ограничение (gp):
 в каждой цепочке последовательность номеров сообщений, построенная по последовательности соответствующих им работ в цепочке, должна являться подпоследовательностью некоторой упорядоченной последовательности сообщений.
Если в наборе дополнительных ограничений присутствует ограничение gp, то задача принципиально отличается от задач с различными наборами ограничений gi. В этом случае кроме построения расписания необходимо строить упорядоченную последовательность заданного набора сообщений.
Задачи построения статических расписаний без прерываний для одноприборных систем, входящих в состав систем реального времени, отличаются друг от друга и задачи, которая обычно рассматривается в теории расписаний (присутствуют лишь ограничения 1-3), различным набором ограничений . Частная задача получается из исходной задачи путем введения дополнительных ограничений на исходные данные. Например, “для любой работы из исходного набора директивный интервал равен времени выполнения работы”.
Задача с ограничениями 1-3 является NP-трудной [2]. Можно показать, что эта задача полиноминально сводится к любой конкретной (задан набор ограничений gi) задаче с ограничениями gi. Т.е. рассматриваемые задачи являются NP-трудными.

3. Алгоритмы сочетающие жадные стратегии и стратегии ограниченного перебора. В работе [3] был предложен алгоритм построения расписания обменов по каналу с централизованным управлением. В основу алгоритма положен жадный принцип распределения работ в расписание обменов в соответствии с локальным критерием "самый ранний срок возможного завершения выполнения работы" и проверка на каждом шаге оптимальности этого критерия. Если этот критерий на некотором шаге не является оптимальным, то осуществляется вызов эвристической процедуры выбора работы (из набора еще неразмещенных работ) для размещения в расписание. На каждом шаге алгоритма выбранная работа размещается в расписание без нарушения условий корректности расписания и вычисляется ближайший такт шины, с которого может выполняться следующая работа. Ближайший такт шины вычисляется с учетом  дополнительных ограничений gi и времени выполнения размещенной работы. После этого корректируются директивные интервалы еще не размещенных в расписание работ, и на следующем шаге осуществляется выбор работы в соответствии с жадным критерием. Для многих частных задач оказалось, что более 90% работ размещаются в конечном итоге в расписание обменов в соответствии со значением жадного критерия, то есть для них можно не проверять оптимальность жадного критерия. Это позволит уменьшить вычислительную сложность алгоритма. 
Будем полагать, что для заданных ограничений и набора работ выполняются условия: длительность выполнения любой работы не больше максимально возможной длительности цепочки; максимально возможное число работ в цепочке не меньше единицы, для циклической схемы - длительность выполнения любой работы не больше заданной длительности подцикла минус резерв времени в начале и конце подцикла. Если есть работы, для которых эти условия не выполняется, то их можно исключить из исходного набора, т.к. они не могут быть размещены в расписание без нарушения условий корректности расписания. 
Схему алгоритма без проверки оптимальности жадного критерия выбора работы на очередном шаге можно представить следующим образом:
1. Выбор из множества J работы по критерию минимально возможное время завершения выполнения работы  (работа j).
2. Вызов операции проверки ограничения  при условии, что работа j будет добавлена в расписание (множество Н). Если ограничение нарушено, то переход к п.4.
3. Вызов операций проверки остальных ограничений при условии, что работа j будет добавлена в расписание ( для циклической схемы и  для схемы без подциклов):
a. если есть ограничения, которые нарушены, то вызов операции корректировки ближайшего такта шины (), с которого может выполняться очередная работа и переход к п.2.
b. если нет ограничений, которые нарушены, то переход к п.6.
4. Вызов эвристической операции построения фрагмента расписания длины L. Входные данные операции: j-я работа и  последних работ из множества Н; выходные данные: корректный фрагмент расписания длины , множество работ, которые не удалось разместить в фрагменте, и  - ближайший такт шины с которого может выполняться следующая работа.
5. Удаление из множества J работ, входящих в , для которых выполняется условие  и переход к п.7.
6. Перемещение выбранной работы (работа j) из множества J в расписание H:  и 
7. Корректировка директивного срока начала работ и вычисление минимально возможного времени завершения каждой работы списка J: если , то ;
8. Если , то переходим к п.1, иначе – завершение работы алгоритма.
Различные эвристические операции построения фрагмента расписания длины L строятся аналогично эвристическим операциям выбора очередной работы для размещения в расписание, которые предложены в [3]. Например, при небольших L может быть использована операция полного перебора всех корректных вариантов размещения (L+1)-ой работы. Если существует несколько фрагментов расписания, которые содержат максимально возможное число работ, то выбирается такой фрагмент, что множество  содержит максимальное число работ для которых . Если такой фрагмент не один, то выбирается фрагмент с наименьшим значением .
Выбор из множества J работы по критерию минимально возможное время завершения выполнения работы позволяет избежать перебора при проверке ограничений  для циклической схемы и  для схемы без подциклов. Т.к. если выбранная по этому критерию работа нарушает ограничения, то не существует в множестве не размещенных работ работы, которая на данном шаге алгоритма может быть размещена в расписание без нарушения этих ограничений. Кроме того, если время выполнения любой работы из исходного набора равно директивному интервалу работы алгоритм строит точное расписание для схемы без подциклов.
Операция корректировки ближайшего такта шины (), с которого может выполняться очередная работа (п.3а) устанавливает значение  равным времени открытия следующего подцикла плюс резерв времени в начале подцикла или для схемы без подциклов равным минимально возможному времени начала следующей цепочки.
Алгоритм может быть настроен на конкретную задачу путем вызова (п.3) операций проверки ограничений соответствующих заданному набору ограничений {gi} и соответствующих операций корректировки ближайшего такта шины () с которого может выполняться очередная работа. Настройка на частные задачи осуществляется путем подбора эвристической операции построения фрагмента расписания (п.4) и выбора значения L.
Алгоритм, может быть также использован для решения задач в которых для циклической схемы есть ограничение , для схемы без подциклов ограничение - . Однако, для многих частных задач у которых в исходном наборе есть работы с пересекающимися директивными интервалами такие, что  точность алгоритма уменьшается. Чем больше число таких работ и меньше значение , тем ниже точность алгоритма. Это происходит из-за того, что алгоритм переходит к построению новой цепочки или заполнению нового подцикла, несмотря на то, что в множестве неразмещенных работ есть работы, которые можно разместить в конец текущей цепочки или в текущий подцикл и на следующих шагах эти работы не могут быть размещены в расписание или «вытесняют» другие работы.
Повысить точность алгоритма для задач с данными ограничениями можно путем введения операции перебора работ, для которых . Если есть ограничения, которые нарушены (п.3а), то проверяется возможность размещения этих работ в конец текущей цепочки или в текущий подцикл. Отметим, что для задач без ограничений , данная операция будет только повышать сложность алгоритма, т.е. ни одна работа не может быть размещена в расписание в результате выполнения этой операции.
Верхняя оценка вычислительной сложности алгоритма равна , где  - сложность эвристической операции построения фрагмента расписания длины L. Для многих практически значимых частных задач сложность алгоритма составляет % - 10%) от верхней оценки сложности алгоритма. Также для многих практически значимых частных задач при  алгоритм строит оптимальные расписания. 
Для частных задач у которых отношение  велико алгоритм может оказаться неприемлемым или по сложности или по точности. Кроме того, алгоритм не может быть расширен на задачи, в которых есть ограничение gp. Точнее расширение возможно, но точность алгоритма становится неприемлемой из-за того, что большое количество работ не размещается в расписание из-за нарушения ограничения gp.

4. Алгоритмы «упаковки». Данные алгоритмы ориентированы на построение расписаний для циклической схемы обменов и вычислений и позволяет решать задачи, в которых есть ограничение gp.
Задачу построения расписаний для циклической схемы можно рассматривать, как задачу упаковки. Подциклы рассматриваются как набор контейнеров. Размер контейнера - длина подцикла минус время, определяемое ограничениями g6 , g7. Дополнительные ограничения (кроме не превышения разиера) на возможность размещения работы в контейнер и место возможного размещения в контейнере формируются на основе остальных ограничений на корректность расписания. Время выполнения работы – размер предмета. Стоимость всех работ равна 1. Т.е. задачи построения расписаний для циклической эквивалентны задачам упаковки заданного набора предметов одинаковой стоимости в заданное число контейнеров. При этом не должны нарушаться дополнительные ограничениями на возможность размещения предметов в контейнеры и критерием оптимальности является «стоимость упакованных предметов».
Схему алгоритма можно представить следующим образом:
1. Вызов операции выбора работы из множества  по критерию  (работа j).
2. Вызов операции определения в соответствии с ограничениями  (ограничения  обязательны) множества подциклов (P) в которые может быть размещена работа j. При этом учитывается, что работа может быть размещена не только в конец цепочки, но и в любое место в цепочке, если сдвиг соответствующих работ цепочки не приводит к нарушению ограничений .
3. Если , то вызов операции выбора подцикла по критерию k2, в противном случае переход к п.5.
4. Переместить работу j из множества J в расписание H.
5. Удалить работу j из множества J.
6. Если , то переходим к п.1, в противном случае завершение работы алгоритма.
В качестве критериев  и k2 можно использовать известные критерии для задачи об упаковки в контейнеры [4]. Для рассматриваемых задач можно использовать кроме известных критериев ряд специальных критериев связанных с особенностями задач. Критерии выбора работы (): время выполнения работы, длина директивного интервала работы, директивный срок завершения работы, количество подциклов, в которые может быть размещена работа на текущем шаге алгоритма (учитывается заполненность подциклов). Критерии выбора подцикла (): резерв свободного времени в подцикле; количество работ из множества неразмещенных работ, которые могут быть размещены в подцикле. При выборе работ (подциклов) по одному из этих критериев мы можем получить некоторое множество работ (подциклов). Для однозначного выбора работы из этих подмножеств введем критерии:  - номер работы в J,  - номер подцикла в H.
Использование различных комбинаций «один критерий выбора работы, один критерий выбора подцикла» не позволяет достичь для большинства задач приемлемой точности алгоритма. Поэтому для выбора на очередном шаге алгоритма работ (подциклов) используются подходы, сочетающие выбор по нескольким критериям:
1. Иерархическое использование критериев, заключается в задании порядка использования критериев и последовательном сужении множества выбранных работ (подциклов): .
2. Задание функции: . На каждом шаге алгоритма выбирается работа (подцикл) для которой значение этой функции максимально.
Алгоритм может быть настроен на задачу путем вызова (п.2) операций проверки соответствующих ограничений . На частную задачу настройка алгоритма осуществляется путем задания набора и порядка использования критериев выбора работы (подцикла) для иерархического подхода и при использовании второго подхода путем задания функции .
Рассмотрим наполнение схемы алгоритмов «упаковки» для решения задач с ограничением gp: в каждой цепочке последовательность номеров сообщений, построенная по последовательности соответствующих им работ в цепочке, должна являться подпоследовательностью некоторой упорядоченной последовательности сообщений. Для задач с ограничением gp кроме расписания строится и упорядоченная последовательность сообщений. При проверке ограничения gp (п.2) будем формировать такое множество P (возможных подциклов размещения работы), что при размещении работы j в подцикл не требуется пополнение текущей последовательности сообщений или пополнение последовательности работ возможно без нарушения ограничения gp для сформированных на предыдущих шагах цепочек работ. Если на данном шаге алгоритма выбирается подцикл, требующий пополнения последовательности сообщений, то кроме размещения работы j в расписание также осуществляется пополнение текущей последовательности сообщений (в последовательность добавляется номер сообщения соответствующего работе j).
Ведем критерий выбора подцикла: «пополнение последовательности сообщений при возможном размещении работы в подцикле» и критерий выбора работы «номер соответствующего работе сообщения». Тогда для решения задач содержащих ограничение gp можно использовать в иерархической схеме выбора работы следующий порядок критериев: 1)длина директивного интервала работы (min), 2)время выполнения работы (min или max), 3)номер соответствующего работе сообщения (min), 4)директивный срок завершения работы (min). При таком порядке критериев в первую очередь будут выбираться работы, для которых число подциклов, в которые они могут быть потенциально размещены минимально. Если есть работы с одинаковой длиной директивного интервала соответствующие разным сообщениям, то работы сообщения с меньшим номером будут выбираться последовательно друг за другом. Последнее «облегчает» возможность выполнения ограничения gp. Для выбора подцикла можно использовать следующий порядок критериев: 1) резерв свободного времени в подцикле (max или min), 2) пополнение последовательности сообщений при возможном размещении работы в подцикле (min), 3) номер подцикла в H (min). 

5. Алгоритмы, основанные на использовании схемы муравьиных колоний. Основной проблемой при использовании алгоритмов, описанных в разделах 3 и 4., является их настройка на решение частных задач. Это связано с проблемой формирования ограничений на исходные данные таким образом, что бы «четко» выделить частную задачу, для которой алгоритм будет гарантировано находить решение с известной точностью и сложностью. В большинстве случаев возможно получение лишь статистических оценок точности и сложности алгоритма. Муравьиные алгоритмы позволяют автоматически настраиваться на пример задачи (заданы конкретные значения исходных данных) путем дополнительной разметки исходных данных, которая используется для построения решения на каждой итерации алгоритма и уточняется по мере увеличения числа итераций. Т.е. при использовании муравьиных алгоритмов не возникает проблема «четкого» выделения частной задачи.
Идея муравьиных алгоритмов [5,6] основана на моделировании поведения муравьев при нахождении кратчайшего пути от муравейника к источнику пищи. Муравьи при перемещении оставляют особое вещество феромон, который используется в дальнейшем другими муравьями при выборе пути. Чем выше концентрация феромона на том или ином пути, тем выше вероятность того, что муравьи будут выбирать для движения именно этот путь.
Для применения муравьиных алгоритмов задачу построения расписания надо свести к задаче нахождения в графе замкнутого пути минимальной длины, в который каждая вершина входит однократно (задача коммивояжера). Общую схему работы муравьиных алгоритмов можно представить в следующем виде:
1. Задание начального количества феромона на ребрах графа, количества и начального положения муравьев.
2. Построение муравьями пути (каждый муравей строит путь независимо от остальных).
3. Обновление количества феромона на ребрах.
4. Если условие останова не выполнено, то переход к п.2.
Операция построение муравьем пути. Муравей строит путь, переходя из одной вершины в другую. Пройденные муравьем вершины добавляются в табу-список (память муравья), чтобы избежать повторного их посещения. Вероятность перехода муравья из i-й вершины в j-ю зависит от количества феромона на данном ребре,  значения локальной целевой функции на ребре и состояния табу-списка. Вероятность перехода k-го муравья из i-й вершины в j-ю на t-й итерации алгоритма рассчитывается по следующей формуле:


Здесь ij(t) - количество феромона на ребре (i,j),  - значение локальной целевой функции на ребре (i,j),  и  - параметры алгоритма, определяющие важность феромонного следа и локальной целевой функции, Lk – множество вершин, включенных в табу-список муравья k.
Операция обновление количества феромона на ребрах. После того, как все муравьи завершили построение путей, обновляется количество феромона на ребрах:


Здесь Tk(t) – путь, построенный k-м муравьем, а F(T) – целевая функция, определяющая качество пути, m – количество муравьев, p[0,1] – коэффициент испарения феромонов. Испарение феромонов вводится для избегания попадания алгоритма в локальный оптимум, когда первый найденный путь с относительно хорошим значением целевой функции становится единственно значимым.
В алгоритмах «упаковки» и алгоритмах сочетающих жадные стратегии и стратегии ограниченного перебора на каждом шаге алгоритма должны решаться две подзадачи: выбор очередной работы из множества J для размещения в расписание (п.1) и выбор «места» размещения этой работы в расписании H (остальные пункты). Для решения первой подзадачи можно использовать муравьиные алгоритмы. Муравьиный алгоритм упорядочивает множество работ J. Выбор работы на очередном шаге алгоритма построения расписания осуществляется в соответствии с порядком работ в множестве J. 
Введем полносвязный граф G=<J,D>, где J={j|j=1,...,Nj}{O} – множество вершин; D={(i,j)|i,j[1,..., Nj], ij}{(O,i)|i[1..n]} – множество ребер. Каждой вершине графа соответствует одна из размещаемых работ. Кроме того, добавляется еще одна вершина О, соответствующая началу расписания. 
Схему алгоритма можно представить следующим образом:
1. Задание начального количества феромона на ребрах графа G и количества муравьев (m).
2. Последовательный вызов m операций построения муравьем пути. В результате выполнения этой операции получаем m упорядоченных множеств J.
3. Для каждого множества J выполняются операции:
Выбор первой работы из множества J.
Вызов процедуры размещения работы в расписания (для алгоритма «упаковки» пп.2-6 и для алгоритма сочетающего жадные стратегии и стратегии ограниченного перебора пп. 2-8.).
4. Вызов операции обновления количества феромона на ребрах графа G.
5. Если критерий останова выполнен, то завершение алгоритма, в противном случае переход к п.2.
Локальные целевые функции на ребрах {(i,j)|i,j[1,..., Nj], ij} графа G задаются функцией:
,
где  - разница между минимально возможным временем завершения j-ой работы и минимально возможным временем начала i-ой работы. Если , j-ая работа не может быть размещена в расписание после i-ой работы без нарушения ограничения g1.
Локальные целевые функции на ребрах {(O,i)|i[1..n]} графа G задаются функцией:ij(t)=1/sj.
На частную задачу настройка алгоритма осуществляется путем задания параметров , , p, c.

6. Заключение. Задачи построения статических расписаний без прерываний для одноприборных систем, входящих в состав систем реального времени, отличаются друг от друга различным набором ограничений на корректность расписания. Эти ограничения обусловлены особенностями аппаратных и системных программных средств системы реального времени. 
В работе предложены три схемы алгоритмов для решения задач построения статических одноприборных расписаний: алгоритмы сочетающего жадные стратегии и стратегии ограниченного перебора, алгоритмы «упаковки», алгоритмы, основанные на использовании метода муравьиных колоний. Схема алгоритма определяет набор операций со специфицированными входами и выходами, которые должны обязательно выполняться в любой модификации алгоритма, и порядок выполнения этих операций. Операция может выполняться различными алгоритмами выполнения операции, которые отличаются друг от друга вычислительной сложностью, точностью, и возможностью учета различных дополнительных ограничений на корректность расписания. Специализированный алгоритм для решения конкретной задачи (задан конкретный набор ограничений на корректность расписания) получается выбором соответствующих операций и их параметров. Также возможно добавление новых операций без нарушения порядка выполнения операций, входящих в схему. В работе показано, что предложенный подход к построению алгоритмов также допускает их настройку на частные задачи (задан набор ограничений на возможные значения входных данных), что позволяет создавать, несмотря на NP-трудность задач, алгоритмы с приемлемой сложностью и точностью.
Специализированные алгоритмы построения расписаний обменов были использованы в инструментальной системе планирования обменов по каналу с централизованным управлением ГОСТ Р 52070-2003 («САПР циклограмм») [7,8]. Инструментальная система «САПР циклограмм» прошла апробацию при разработке авиационных и корабельных ВСРВ.
1. Балашов В.В., Костенко В.А. Задачи планирования вычислений для одноприборных систем, входящих в состав вычислительных систем реального времени//В данном сборнике.
2. Гэри М., Джонсон Д. Вычислительные машины и трудно решаемые задачи. - М.: Мир, 1982.
3. Костенко В.А., Гурьянов Е.С. Алгоритм построения расписаний обменов по шине с централизованным управлением и исследование его эффективности// Программирование, 2005., N6.
4. Теория расписаний и вычислительные машины/ Под ред. Э.Г.Коффмана. - М.: Наука, 1984.
5. Dorigo M. Optimization, Learning and Natural Algorithms// PhD Thesis. Dipartimento di Elettronica, Politechnico Di Milano, Milano. 1992.
6. Штовба С.Д. Муравьиные алгоритмы: теория и применение // Программирование. 2005. №4.
7. Балашов В.В., Вавинов С.В., Гурьянов Е.С., Костенко В.А., Смелянский Р.Л. Система автоматического построения циклограммы обменов по шине с централизованным управлением// Методы и средства обработки информации. Труды второй Всероссийской научной конференции. - М.: Издательский отдел факультета вычислительной математики и кибернетики МГУ им. М.В. Ломоносова, 2005.
8. V.V. Balashov, V.A. Kostenko, R.L. Smeliansky. A Tool System for Automatic Scheduling of Data Exchange in Real-Time Distributed Avionics Systems// Proceedings of the 2nd EUCASS European Conference for Aerospace Sciences (EUCASS'2007), 2007.В.А. Костенко, Д.С. Коваленко. Алгоритмы распознавания нештатного поведения динамических систем устойчивые к нелинейным искажениям фазовых траекторий системы // Труды Международной научно-практической конференции "Передовые информационные технологии, средства и системы автоматизации и их внедрение на российских предприятиях" AITA-2011. – М.: Институт проблем управления им. В. А. Трапезникова РАН, 2011. – С.897–905.

УДК 004.02+004.67

АЛГОРИТМЫ РАСПОЗНАВАНИЯ НЕШТАТНОГО ПОВЕДЕНИЯ ДИНАМИЧЕСКИХ СИСТЕМ УСТОЙЧИВЫЕ К НЕЛИНЕЙНЫМ ИСКАЖЕНИЯМ ФАЗОВЫХ ТРАЕКТОРИЙ СИСТЕМЫ

Д.С. Коваленко
МГУ им. М.В. Ломоносова
Россия, 119991, Москва, Ленинские горы, 
МГУ, 2-й Учебный Корпус, факультет ВМК
E-mail: dk@lvk.cs.msu.su 

В.А. Костенко
МГУ им. М.В. Ломоносова
Россия, 119991, Москва, Ленинские горы, 
МГУ, 2-й Учебный Корпус, факультет ВМК
E-mail: kost@cs.msu.su 

Ключевые слова: задача обучения по прецедентам, алгоритм распознавания, обучающая выборка, алгоритм обучения, динамическая система, алгебраический подход к задаче выделения трендов.

В данной работе рассматривается задача автоматического построения алгоритмов распознавания нештатного поведения динамических систем. Информация о поведении системы доступна в виде фазовой траектории в пространстве показаний датчиков. Особенностью рассматриваемой задачи распознавания является то, что в наблюдаемой фазовой траектории участки, соответствующие нештатному поведению системы, могут быть нелинейно искажены по амплитуде и растянуты или сжаты по времени друг относительно друга в различных условиях работы системы. В работе предложены параметрическое семейство алгоритмов и метод построения по обучающей выборке алгоритмов распознавания нештатного поведения динамических систем обладащих более высокой устойчивостью к искажениям фазовых траекторий по сравнени. с известными методами.


1. Задача распознавания нештатного поведения динамических систем

Рассматриваются системы, информация о поведении которых доступна в виде фазовых траекторий, получаемых с окружающих систему датчиков. Время рассматривается дискретное, датчики опрашиваются с некоторой фиксированной частотой . Фазовая траектория  в пространстве показаний датчиков представляет собой последовательные измерения всех датчиков системы: , где:  – это точка в многомерном пространстве показаний датчиков (в фазовой плоскости).
Состояние системы характеризуется точкой фазовой траектории. Со временем система изменяет свое состояние, последовательные изменения состояния системы будем называть ее поведением. Существует три класса состояний системы: 
штатное состояние, при котором система стабильно выполняет заложенные в нее функции;
нештатное состояние, при котором система в скором времени гарантированно перестанет выполнять заложенные в нее функции;
аварийное состояние, при котором система не выполняет заложенных в нее функций.
Нормальным поведением системы будем называть такое поведение, при котором все состояния, которые принимает система, принадлежат классу штатных состояний. Нештатным поведением системы будем называть такое, при котором все состояния, которые принимает система, принадлежат классу нештатных состояний. Считаем, что каждому аварийному состоянию системы предшествует нештатное поведение. Может существовать несколько классов нештатного поведения, приводящих к аварийному состоянию системы. Классы нештатного поведения определяются различными неисправностями, которые могут возникнуть в рассматриваемой системе. 
Будем считать, что для каждого класса нештатного поведения существует некоторая характерная фазовая траектория , такие траектории будем называть эталонными. Пусть число классов нештатного поведения системы равно . Обозначим:  – множество ответов, где  – соответствует штатному поведению системы,  – соответствует нештатному поведению под номером  из  возможных.
Участки нештатного поведения могут входить в анализируемую фазовую траекторию  в искаженном относительно эталонных траекторий виде. Можно выделить следующие типы искажений: искажения по амплитуде и искажения по времени. Под искажением траектории по амплитуде будем понимать изменение абсолютных значений точек траектории, без изменения числа отсчетов. Под искажением траектории по времени будем понимать изменение числа отсчетов, на которых определена траектория, то есть добавление в траекторию новых отсчетов или удаление из нее уже существующих. На рис. 1 показаны траектории, которые искажены по амплитуде и времени друг относительно друга. Подклассом искажений по амплитуде можно считать стационарный шум, возникающий в датчиках, окружающих систему.



Рис. 1. Пример искаженных друг относительно друга траекторий по амплитуде и времени.
  
Задача распознавания нештатного поведения состоит в следующем. Дано:  
наблюдаемая многомерная траектория ;
набор из  классов нештатного поведения системы, для каждого из которых задана эталонная траектория ;
ограничения на полноту и точность распознавания: 
	
где:  – число ошибок распознавания первого рода;  – число ошибок распознавания второго рода; ,  – заданные числовые ограничения. 
 Требуется с учетом ограничений на полноту и точность провести распознавание нештатного поведения в работе системы.


2. Параметрическое семейство алгоритмов распознавания

Разработанное семейство алгоритмов распознавания основано на идеях алгебраического подхода к разметке плоских конфигураций. Идея использования аксиоматического подхода для выделения трендов на временных рядах была предложена в работе [1], в работе [2] было предложено использование этого подхода для обнаружения нештатных режимов работы динамических систем. Основой аксиоматического подхода является разметка анализируемой траектории аксиомами и анализ траектории по полученному ряду разметки.
Определение 1: Элементарное условие  – это функция, определенная на отчете  и некоторой его окрестности  на траектории , зависящая от набора параметров , которая принимает значения из множества . 
Пример элементарного условия: 
		
 где: ; .
Определение 2: Аксиома  – это булева функция, заданная в виде формулы от элементарных условий, определенных на отсчете  и некоторой его окрестности  на траектории :  
		
  где:  
	 
Определение 3: Конечное множество аксиом  будем называть системой аксиом, если оно удовлетворяет условию:  
	
т.е. для любой точки  произвольной фазовой траектории  найдется и притом только одна аксиома  из множества , условия которой выполняются в данной точке.
Далее будем считать, что аксиомы в системе аксиом  пронумерованы последовательными натуральными числами: .
Любое множество аксиом возможно представить в виде системы аксиом выполнив: 
1. Введение порядка на множестве аксиом. Будем считать что, если аксиома с индексом  выполняется в некоторой точке произвольной фазовой траектории, то никакая аксиома с индексом  не выполняется в данной точке траектории.
2. Добавление тождественной аксиомы  в  с наименьшим приоритетом:  
	
Тождественная аксиома  – это аксиома, которая выполняется в любой точке любой фазовой траектории.
Определение 4: Разметкой траектории  относительно системы аксиом  будем называть последовательность , где  – индекс аксиомы в системе аксиом , условия которой выполняются на отсчете  траектории . 
 Алгоритм, который сопоставляет траектории  ее разметку относительно заданной системы аксиом, будем называть алгоритмом разметки и обозначать: .
В рамках разработанного подхода распознавание нештатного поведения в работе наблюдаемой системы происходит следующим образом:  
1. Размечаются эталонные траектории , соответствующие различным классам нештатного поведения. 
2. Размечается наблюдаемая траектория  и формируется ряд разметки . 
3. В ряду разметки  ищутся подпоследовательности номеров аксиом соответствующие разметкам эталонных траекторий. 
Таким образом, определение нештатного поведения в работе наблюдаемой системы ведется не путем поиска эталонных траекторий  в наблюдаемой траектории , а путем поиска разметок эталонных траекторий в ряду разметки .
Решение рассматриваемой задачи распознавания будем искать среди множества алгоритмов , каждый из которых включает в себя:  
алгоритм предобработки исходных данных, 
алгоритм разметки и система аксиом, 
алгоритм поиска разметок эталонных траекторий в разметке наблюдаемой траектории. 
Алгоритм предобработки включен в состав алгоритма распознавания с целью уменьшения влияния шумовых составляющих наблюдаемой траектории на качество распознавания. Использование алгоритмов нечеткого поиска разметок позволяет бороться с искажениями по времени. Для предобработки использовались следующие алгоритмы: сглаживания, сжатия и интерполяции траектории на произвольный коэффициент, быстрое преобразование Фурье. Для поиска разметок использовались: алгоритмы на основе метрики Минковского и DTW (Dynamic Time Warping) [3], алгоритмы на основе нейросетей, кроме того был предложен алгоритм на основе расширенных разметок [4].


3. Задача построения алгоритма распознавания по обучающей выборке

Пусть задан набор прецедентов  в виде экземпляров траекторий , полученных в различных условиях работы системы. Траектории  из набора  содержат как участки нештатного поведения, так и участки нормального поведения. Для каждой из траектории  указаны:  
точки наступления аварийных ситуаций (при этом отсчеты начала и окончания предшествующего участка нештатного поведения неизвестны, т.е. неизвестна точка возникновения неисправности в системе); 
для каждой аварийной ситуации указан ее тип из множества . 
Преобразуем всю известную выборку  следующим образом.  Каждая траектория , содержащую точку аварии, разделяется на части: траектория нормального поведения  и траектория  длиной  отсчетов, содержащая участок нештатного поведения ( - параметр преобразования). Траектория  представляет собой участок траектории  с отсчета  по отсчет , где  – это точка аварии на траектории . После преобразований выборка  представляет собой набор траекторий: . Часть из них является траекториями нормального поведения , другая часть  – это набор таких траекторий, каждая из которых содержит участок нештатного поведения, однако не известно на каких именно отсчетах. Далее, будем считать, что выборка  преобразована указанным образом.
Разделим всю преобразованную выборку  на  равные непересекающиеся части: выборка  для определения разметок участков нештатного поведения, обучающая выборка  и контрольная выборка . При этом в каждую из выделенных частей должны попасть траектории из наборов ,  в одинаковом соотношении. Такое разделение выборки обусловлено необходимостью выделения выборки  для определения разметок эталонных траекторий, необходимостью использования выборки  для построения системы аксиом  и необходимостью использования контрольной выборки  для оценки качества работы полученного алгоритма распознавания.
Пусть определена целевая функция , где  и  – число ошибок распознавания первого и второго рода, которая отвечает следующим требованиям:  
функция  определена для любых неотрицательных целых значений аргументов  и ;
функция  монотонно неубывает по каждому из аргументов. 
Число ошибок распознавания первого рода  (второго рода ) определяется для некоторого алгоритма распознавания  на некоторой траектории . Под числом ошибок распознавания на выборке  будем понимать сумму ошибок распознавания на всех траекториях данной выборки.
Задача построения алгоритма распознавания нештатных ситуаций в работе динамической системы состоит в следующем. Дано:  
выборка , 
целевая функция . 
 Требуется построить алгоритм распознавания , который будет удовлетворять следующему набору ограничений:  
1. Алгоритм  должен выдавать ограниченное число ошибок на обучающей выборке : 
	, 
где:  – заданные  числовые ограничения.
2. Алгоритм  должен минимизировать значение целевой функции  на контрольной выборке : 
	
3. Вычислительная сложность работы алгоритма распознавания  на произвольной траектории, длины не больше , должна быть ограничена наперед заданной функцией , которая определяется характеристиками используемого вычислителя и скоростью развития процессов в анализируемой системе: 
	
Данная задача построения алгоритма распознавания соответствует классической постановке задачи обучения по прецедентам [5]. Для случая, когда для траекторий из выборки  известны отсчеты начала и окончания участков нештатного поведения, разработаны алгоритмы решения сформулированной задачи, см. [6]. В работе [6] так же приводятся результаты сравнительного исследования алгоритмов на основе алгебраического подхода с другими широко применяемым алгоритмами решения сформулированной задачи. 
В данной работе рассматривается случай, когда для траекторий из выборки  известны только точки наступления аварийных состояний, а границы предшествующих участков нештатного поведения неизвестны. Для того, чтобы найти требуемый алгоритм распознавания в семействе , необходимо выбрать алгоритм предобработки и значение его параметров, построить систему аксиом, выбрать алгоритм нечеткого поиска и значение его параметров, определить эталоны участков нештатного поведения, которые необходимо обнаруживать в наблюдаемой фазовой траектории системы. Поиск алгоритма распознавания ведется в два этапа:  
1. Для каждой пары (алгоритм предобработки, алгоритм поиска разметок) ведется поиск алгоритма распознавания. Область поиска с заданным типом алгоритма предобработки и типом алгоритма поиска разметок будем называть шаблоном и обозначать .  При этом, для алгоритма распознавания настраиваются значения параметров заданных алгоритмов предобработки и поиска разметок, стоится система аксиом и формируются разметки участков нештатного поведения. 
2. Среди всех полученных решений выбирается то, которое показывает наименьшее значение целевой функции  на контрольной выборке . 
 Для настроек параметров алгоритмов предобработки и поиска разметок используются алгоритмы локальной оптимизации, в частности алгоритм градиентного спуска. Наибольшую сложность представляет задача построения системы аксиом и формирования разметок участков нештатного поведения. Решение этой задачи будет рассмотрено ниже.


4. Алгоритм построения системы аксиом

Алгоритм построения системы аксиом состоит в следующем: 
1. Для каждого класса  нештатного поведения системы производится построение элементарных условий и аксиом, которые выполняются на участках нештатного поведения именно этого класса. Для этого выполняется: 
a. Составление сокращенной обучающей выборки  из траекторий выборки , содержащих участки нештатного поведения класса , и траекторий нормального поведения из . Таким образом, из  в  попадают все траектории, кроме траекторий, содержащих участки нештатного поведения, не относящиеся к классу  нештатного поведения системы.  
b. Выбор элементарных условий и настройка их параметров. На этом этапе выбираются множество таких элементарных условий с заданными параметрами, которые чаще выполняются на траекториях, содержащих участки нештатного поведения класса , и реже на траекториях нормального поведения из обучающей выборки. Для этого происходит:
i. Создание набора из  элементарных условий, в который включаются все заданные условия вместе с их отрицаниями:  
		
	Для того, чтобы учесть, что некоторое элементарное условие  с определенным набором параметров может выполняться на участках нормального поведения и не выполняться на участках нештатного поведения, в набор  включаются все элементарные условия с отрицаниями.
ii. Для каждого элементарного условия  из набора  определяется область значений его параметров, при которых условие  принимает значение . В полученной области строится сетка значений параметров  с заданным шагом  по каждому из параметров  условия .
iii. Заданное количество  элементарных условий с определенными значениями параметров, которые чаще выполняются на траекториях, содержащих участки нештатного поведения класса , и реже на траекториях нормального поведения, сохраняются и представляют собой результат работы данного этапа алгоритма. 
c. Формирование аксиом из выбранных элементарных условий. Лучшие аксиомы, которые чаще выполняются на траекториях, содержащих участки нештатного поведения класса , и реже на траекториях нормального поведения, сохраняются и поступают на вход следующему этапу алгоритма:
i. Для каждого элементарного условия , выбранного ранее, создается аксиома , состоящая только из данного условия:  
	 ,  	
ii. Итеративное изменение набора аксиом .   Для каждой пары различных аксиом  и  в наборе  строется две новые аксиомы:  
	,  	
Если новая аксиома чаще выполняются на траекториях, содержащих участки нештатного поведения класса , и реже на траекториях нормального поведения, по сравнению с  и , то она добавляется в .
iii. Сокращение числа аксиом в  до заданного параметра , причем, сохраняются те аксиомы, которые чаще выполняются на траекториях, содержащих участки нештатного поведения класса , и реже на траекториях нормального поведения. 
iv. Если множество  не было обновлено на шаге ii или достигнуто заданное число итераций данного алгоритма, то происходит переход на этап 2 алгоритма. В противном случае – переход на шаг ii.
2. Формирование множества систем аксиом из построенных аксиом:
a. Для каждой аксиомы  создается система аксиом:  
	 ,  
b. Для каждой системы аксиом  из множества  запускается итеративный процесс ее дополнения аксиомами из набора :
i. Для системы  создается система аксиом  путем добавления аксиомы  c наименьшим приоритетом:  
	
ii. Для каждой построенной системы аксиом  формируются разметки эталонных траекторий для всех классов нештатного поведения. Эти разметки получаются из выборки  путем выделения наибольшей общей подпоследовательности разметок траекторий, содержащих участки нештатного поведения одного класса, относительно системы аксиом . 
iii. Для каждой построенной системы аксиом  вычисляется значение целевой функции  на обучающей выборке . Если значение  для  оказалось меньше, чем для , то  помещается в .
iv. Система  переходит из  в .
v. Если оказалось пусто или число итераций алгритма превысило заданный параметр, то происходит переход на этап 3, иначе – на шаг 2.b.
3. Выбор лучшей системы аксиом  по значению целевой функции  на контрольной выборке  среди всех систем аксиом в наборе . Выбранная система аксиом  является результатом работы алгоритма.
Основной особенностью предложенного алгоритма построения системы аксиом является то, что алгоритм позволяет выделять разметки участков нештатного поведения, используемые как разметки эталонных траекторий. Предложенный способ выделения разметок основан на том, что на этапах построения элементарных условий и аксиом формировались такие условия и такие аксиомы, которые выполняются на участках нештатного поведения и не выполняются на траекториях нормального поведения.


5. Результаты численного исследования 
 
Исследования показали, что предложенный метод позволяет получать алгоритмы распознавания, устойчивые к искажениям участков нештатного поведения по амплитуде и времени относительно эталонных траекторий. При искажениях по времени до 20% и амплитуде до 20% и при амплитуде шума в 5% от амплитуды сигнала были получены следующие результаты: число I первого рода – 51 (при длине анализируемой траектории в 30000 отсчетов), процент ошибок II рода – 8.5%. При искажениях по времени до 20% и амплитуде до 2.5% и при амплитуде шума в 15% от амплитуды сигнала получены следующие значения ошибок распознавания: 30 ошибок I рода (при длине анализируемой траектории в 30000 отсчетов) и 6% ошибок II рода.
Кроме того, проводилось исследование изложенного в работе подхода для решения практических задач. Среди них: прогнозирование микросна водителя, распознавание рукописного ввода букв, распознавания звуков и др. Были получены алгоритмы распознавания, демонстрирующие низкое число ошибок распознавания. Например, результаты алгоритма прогнозирования микрона водителя: в среднем, процент ошибок II рода составил 5%, а число ложных срабатываний в среднем составило около 15 на  отсчетов (что соответствует 6–7 часам наблюдения). Для задачи распознавания рукописного ввода букв были получены следующие результаты: число корректно распознанных букв составило 95%, число ложных срабатываний – 58 при общем числе траекторий – 2858.

6. Заключение

Результаты численного исследования свидетельствуют о том, что разработанные методы построения алгоритмов распознавания позволяют получать алгоритмы, обладающие высокой устойчивостью к нелинейным искажениям фазовых траекторий нештатного поведения по амплитуде и времени и, потому, могут быть использованы при проектировании и эксплуатации сложных систем, требующих автоматического контроля своего состояния. Разработанные методы в отличии от известных методов основанных на машинном обучении позволяют строить алгоритмы распознавания нештатного поведения систем для случая, когда время возникновения неисправности в системе неизвестно, т.е в траекториях обучающей выборки не указаны участки нештатного поведения, а указана лишь точка наступления аварии.


Список литературы

1. Рудаков К. В., Чехович Ю. В. О проблеме синтеза обучающих алгоритмов выделения трендов (алгебраический подход). // Прикладная математика и информатика N 8, М. Издательство факультета ВМиК МГУ, 2001. С. 97-114. 
2. Коваленко Д. С., Костенко В. А., Васин Е. А. Исследование применимости алгебраического подхода к анализу временных рядов. // Труды Второй Всероссийской Научной Конференции «Методы и средства обработки информации». Изд.: ВМиК МГУ, 2005. С. 553-559. 
3. Keogh E. J., Michael J. Pazzani Derivative Dynamic Time Warping. // Proceedings of the First SIAM International Conference on Data Mining (SDM'2001), Chicago, USA. 2001. http://www.ics.uci.edu/ pazzani/Publications/sdm01.pdf. 
4. Коваленко Д. С. Методы нечеткого сравнения и голосования для построения распознавателей нештатного поведения динамических систем.  // Труды V Московской международной конференции по исследованию операций «ORM-2007». Изд: МАКС Пресс, 2007. С.123-125. 
5. Воронцов К. В. Комбинаторный подход к оценке качества обучаемых алгоритмов. // Математические вопросы кибернетики. №13, 2004. С.5-36. http://www.ccas.ru/frc/papers/voron04mpc.pdf 
6. Барыбин А.К., Коваленко Д.С., Костенко В.А, Тумакин Д.А., Чельдиев М.И. Параллельный алгоритм обучения распознавателей нештатного поведения динамических систем. // Труды Третьей Всероссийской Научной Конференции «Методы и средства обработки информации», МСО-2009. Изд.: МАКС Пресс. С. 362-373. Программные системы и инструменты. Тематический сборник № 8, М.: Изд-во факультета ВМиК МГУ, 2007. – С.148-156.

Балаханов В.А., Костенко В.А.

Способы сведения задачи построения статико-динамического однопроцессорного расписания для систем реального времени к задаче нахождения на графе маршрута.

Введение
Алгоритмы оптимизации, имитирующие кооперативное поведение муравьев в колонии, впервые были предложены в 1992 году [1] для решения задачи коммивояжера. Впоследствии муравьиные алгоритмы были успешно использованы для решения таких комбинаторных задач, как квадратичная задача о назначениях [2], задача упаковки в контейнеры [3], задачи построения расписаний [4,5,6]. 
Идея муравьиных алгоритмов основана на моделировании поведения муравьев при нахождении кратчайшего пути от муравейника к источнику пищи. Муравьи при перемещении оставляют особое вещество феромон, который используется в дальнейшем другими муравьями при выборе маршрута. Чем выше концентрация феромона на том или ином маршруте, тем выше вероятность того, что муравьи будут выбирать для движения именно этот маршрут.
Общую схему работы муравьиных алгоритмов можно представить в следующем виде:
1. Задание начального количества феромона на ребрах графа.
2. Определение количества и начального положения муравьев.
3. Поиск муравьями решений в соответствии с заданным алгоритмом построения маршрута.
4. Обновление количества феромона на ребрах в зависимости от качества полученных решений.
5. Если условие останова не выполнено, то переход к п.2.
Муравьи строят маршруты, последовательно переходя от вершины к вершине, руководствуясь при этом определенным алгоритмом для определения списка вершин, доступных на данном этапе (например, при решении задачи коммивояжера используется табу-список недоступных вершин, в который добавляются пройденные муравьем вершины). Выбор очередной вершины зависит от количества феромонов и значения локальной эвристической функции на ребрах, ведущих из текущей вершины в доступные. Эти значения определяют вероятность перехода в ту или иную вершину, после чего очередная вершина определяется по правилу рулетки.
В конце каждой итерации для каждого найденного маршрута вычисляется значение целевой функции. Оно используется для вычисления количества феромона, добавляемого на ребра, входящие в данный маршрут.
Основными задачами, которые необходимо решить для того, чтобы использовать муравьиный алгоритм для решения конкретной задачи оптимизации, являются:
1. Сведение задачи оптимизации к задаче нахождения на графе маршрута, обладающего определенными свойствами.
2. Задание локальной эвристической функции на ребрах графа.
3. Определение алгоритма построения маршрута муравьем (например, определение правила формирования табу-списка вершин).
В данной работе рассматриваются два способа сведения задачи построения статико-динамического однопроцессорного расписания для систем реального времени к задаче нахождения на графе маршрута.
1. Задача построения статико-динамического однопроцессорного расписания для систем реального времени
Статико-динамическое расписание представляет собой набор окон, каждое из которых характеризуется временем открытия, временем закрытия и списком работ, выполняющихся внутри окна. При этом порядок выполнения работ внутри окна определяется динамически и заранее неизвестен. Длина окна должна быть не меньше, чем суммарное время выполнения работ внутри него. Наряду с заданным списком прикладных задач в вычислительной системе могут выполняться системные задачи, список которых заранее неизвестен. На выполнение системных задач в каждом окне должен быть отведен определенный резерв времени.
Использование таких расписаний при работе систем реального времени позволяет уменьшить время реакции на прерывания и переключение режимов работы. Однако системы реального времени накладывают дополнительные ограничения на расписание. Кроме времени выполнения, каждая работа характеризуется также директивным интервалом, в пределах которого возможно ее выполнение. При этом временной интервал окна должен лежать внутри каждого из директивных интервалов работ, выполняющихся в данном окне, чтобы гарантировать, что директивные интервалы работ не будут нарушены.
Примером систем реального времени, использующих статико-динамические расписания, являются системы, работающие по стандарту ARINC-653 [7]. Одним из основных понятий стандарта является понятие раздела: в системе имеется определенный набор разделов, и каждая работа характеризуется номером раздела. Работы из одного раздела могут выполняться непосредственно одна за другой, без задержек; для перехода из одного раздела в другой необходимо переключение контекста, которое требует определенного времени. Все работы внутри окна должны принадлежать одному разделу, таким образом, работы внутри окна могут выполняться непосредственно друг за другом, без временных затрат на переключение контекста, которое может производиться только между закрытием одного окна и открытием следующего. Таким образом, для каждой работы задано время выполнения, номер раздела и директивный временной интервал выполнения.
В данной работе будут рассматриваться системы, работающие в соответствии со стандартом ARINC-653. Приведем формальную постановку задачи построения расписания для таких систем:
Пусть задано множество работ: 
SW={ai=<si,fi,ti,pi>|i[1..n]}, где 
[si,fi) – директивный временной интервал;
ti – время выполнения работы;
pi – номер раздела работы.
В дальнейшем будем предполагать, что для i[1..n]:sifi и tifi–si.
Кроме того, заданы два параметра:  и , определяющие, соответственно, временные затраты на переключение контекста между окнами и резерв свободного времени внутри каждого окна.
Требуется построить расписание, представляющее собой набор окон:
SP={wi=<Si,Fi,SWi>|i[1..m]}, где
Si – время открытия окна;
Fi  – время закрытия окна;
SWi={aij}SW – множество работ, выполняемых внутри окна.
Будем предполагать, что окна упорядочены в порядке возрастания времени открытия Si.
При этом должны выполняться следующие ограничения:
1. (i,j)[1..m],ij:SWiSWj= – множества работ, размещенных внутри окон, не пересекаются;
2. i[1..n],j[1..m],aiSWj:siSj<Fjfi – временной интервал окна лежит внутри директивных интервалов работ, выполняющихся в окне;
3. (i,j)[1..n],k[1..m],ai,ajSWk:pi=pj – разделы работ, размещенных внутри одного окна, совпадают;
4. (i,j)[1..m],i<j:SjFi+ – окна не пересекаются и между любыми двумя соседними окнами есть промежуток не короче времени, необходимого на переключение контекста;
5.  – суммарное время выполнения всех работ из одного окна с учетом резерва времени не больше, чем длина окна.
Критерием оптимальности расписания является отношение количества размещенных работ к общему количеству заданных работ.
2. Первый способ сведения задачи построения статико-динамического расписания к задаче нахождения на графе маршрута
Построим полносвязный граф G=<N,A>, где:
N={ni|i[1..n]}{O} – множество вершин;
A={(ni,nj)|i,j[1..n],ij}{(O,ni)|i[1..n]}> – множество ребер. 
Каждой вершине графа соответствует одна из размещаемых работ. Кроме того, добавляется еще одна вершина О, соответствующая началу расписания. 
Муравьиный алгоритм строит маршруты, в которых все вершины включены ровно один раз. Каждому такому маршруту соответствует последовательность работ, такая что, в нее включены все работы из исходно заданного набора и каждая работа включена в данную последовательность один раз. Опишем алгоритм для построения расписания по такой последовательности работ. Пусть дана последовательность работ SL={aik|aikSW;i,k[1..n]}. Первый индекс означает номер работы, второй - номер места работы в последовательности. Построим расписание SP по следующему алгоритму:
1. Инициализация расписания: Time=0 – текущая длина расписания; k=1 – номер места размещаемой работы в SL; SW0= – список работ в добавляемом окне;
2. Установка начальных параметров окна: S=max(Time,sik), F=fik – границы добавляемого окна; T=2 – минимальная необходимая длина окна с учетом добавленных работ; R=rik – раздел для работ в окне;
3. Обновление значений параметров окна с учетом новой добавляемой работы: S’=max(S,sik), F’=min(F,fik),  T’=T+tik;
4. Добавление работы в текущее окно: если rik=R , T’F’–S’ (условия корректности не нарушаются), то:    S=S’, F=F’, T=T’, SW0=SW0{aik}, k=k+1, если kn (список SL еще не пройден), переход к п.3;
5. Проверка возможности добавления работы в новое окно: если fik–F–<tik , то k=k+1, если kn переход к п.3 – данная работа не может быть размещена ни в текущее окно, ни в новое окно (дальше в списке еще могут быть работы, которые можно разместить в текущее окно);
6. Закрытие окна: F=S+T – устанавливаем время закрытия окна минимально возможным;
7. Добавление данного окна в расписание: SP=SP{<S,F,SW0>};
8. Пересчет длины расписания: Time=F+, k=k+1; 
9. Если k  n (список еще не пройден), переход к п.2.
Расписание, построенное при помощи данного алгоритма, будет удовлетворять всем условиям корректности:
1. Условие корректности 1 выполняется, т.к. каждая вершина встречается в построенном маршруте ровно один раз, и соответствующая ей работа размещается лишь в одно окно;
2. Условие 2 выполняется, т.к. S’=max(S,sik)sik; F’=min(F,fik)fik  (п.3);
3. Выполнение условий 3 и 5 обеспечивается проверками в п.4 алгоритма – если ограничения нарушаются, работа не размещается в данное окно;
4. Условие 4 выполняется, т.к. Si+1Time (п.2), где Time=Fi+п.8
Таким образом, при помощи описанного алгоритма по заданной последовательности работ однозначно строится корректное расписание. Фактически, данный алгоритм устанавливает соответствие между пространством расписаний и пространством последовательностей работ, которое, в свою очередь, является пространством поиска для муравьиного алгоритма. 
Недостатком данного подхода является то, что множество корректных расписаний содержит больше элементов, чем множество последовательностей работ, т.е. существуют расписания, для которых не существует соответствующих им цепочек работ. Причина заключается в том, что последовательность работ не задает однозначно распределение работ по окнам. Более того, можно привести пример задач, для которых оптимальное расписание не будет принадлежать к пространству поиска муравьиного алгоритма. Пример исходных данных такой задачи: SW={a1=<0,11,4,1>,a2=<4,11,2,1>,a3=<4,11,2,1>}, ==1 (рис.1). Прямоугольниками показаны директивные интервалы, заштрихованными областями – время выполнения работ. Раздел у всех работ одинаковый.



Рисунок 1. Исходные данные.

На рис.2 показаны все возможные расписания, которые могут быть построены приведенным алгоритмом по различным маршрутам в графе. Все эти расписания не являются оптимальными.


Рисунок 2. Построенные расписания.

При этом расписание, в котором все работы размещены, существует (рис.3).


Рисунок 3. Оптимальное расписание.

Можно выдвинуть гипотезу, что не существует детерминированного полиномиального алгоритма A построения расписания по маршруту в графе G такого, что для (SW,,):SL:A(SL)=SP0, где SP0 – оптимальное расписание. Т.е. не существует детерминированного полиномиального алгоритма, который для любой частной задачи мог бы построить оптимальное расписание по одному из возможных маршрутов. По крайне мере, пока такой алгоритм найти не удалось, однако нет и доказательства, что такого алгоритма не существует.
3. Второй способ сведения задачи построения статико-динамического расписания к задаче нахождения на графе маршрута
Чтобы устранить недостаток первого подхода, предлагается использовать измененное представление задачи в виде поиска маршрута на графе, в котором каждой работе будет соответствовать не одна, а две вершины. Появление в маршруте первой из этих вершин будет означать размещение работы без закрытия текущего окна. Другая вершина будет соответствовать размещению работы с закрытием окна. Соответственно, в маршруте может присутствовать одна и только одна вершина из каждой такой пары.
Построим граф G’=<N’,A’>, где
N’={ni+,ni–|i[1..n]}{O} – множество вершин; вершина ni+ соответствует размещению работы без закрытия текущего окна, ni– – размещению работы с закрытием окна. Вершина О является началом всех маршрутов.
A’={(ni+,nj–),(ni+,nj+),(ni–,nj–)|i,j[1..n],ij} {(O,ni+),(O,ni–)|i[1..n]} – множество ребер. Вершины, соответствующие одной работе, ребрами не связаны.
Алгоритм построения расписания по заданной последовательности работ полностью аналогичен предыдущему, за исключением того, что в п.4 при размещении работы, соответствующей вершине nj– текущее окно закрывается принудительно (происходит переход к п.6). Расписание, построенное при помощи такого алгоритма, также будет удовлетворять условиям корректности.
Заметим, что расписания, которые строятся приведенными алгоритмами (как базовым, так и модифицированным), помимо условий корректности, обладают следующими свойствами: 
 - длина временного интервала окна является минимально допустимой.
(1)
 - время открытия окна является минимальным, без нарушения ограничений 2 и 4.
(2)
Покажем, что модифицированный алгоритм всегда может построить оптимальное расписание по некоторому пути в G’.
Теорема. Для любого корректного расписания SP можно найти такую последовательность вершин SL, что по данной последовательности модифицированный алгоритм восстановления расписания построит такое корректное расписание SP*, что i[1..k]:SWi*=SWi , количество окон в SP* не меньше количества окон в SP.
Доказательство: построим искомую последовательность SL={nip|nipN’,i[1..n],p{+,–}} следующим образом: SL=SL1SL2…SLm, где SLi – последовательность из вершин, соответствующих работам из i-го окна такая, что все вершины, за исключением последней соответствуют размещению работы без закрытия окна. Т.е., фактически, данная последовательность состоит из размещенных работ, упорядоченных по времени открытия окна, в которое они размещены. Вершины, соответствующие работам, не размещенным в SP, добавляются в конец последовательности SL в произвольном порядке (добавляется одна произвольная вершина из двух). При этом в последовательности SL присутствует только одна вершина, соответствующая каждой работе.
Докажем совпадение списков работ в окнах расписания SP* и расписания SP по индукции.
1. Базис индукции: Т.к. все вершины, соответствующие работам из первого окна, стоят в последовательности вершин друг за другом, не прерываются вершиной с закрытием окна, то они будут размещаться в одно и то же окно. Т.к. исходное расписание является корректным, это возможно без нарушения условий корректности 1-5. Следовательно, списки работ в первом окне в SP и SP* будут совпадать (поскольку список вершин, соответствующих работам из первого окна, заканчивается вершиной с закрытием окна, в данное окно не попадут «лишние» работы). Время открытия и закрытия первого окна могут различаться в SP* и SP, но при этом из свойств (1) и (2) следует, что S*1S1, F*1F1.
2. Шаг индукции: F*i-1Fi-1, и, следовательно (из свойства (2)), S*iSi, F*iFi; далее повторяя предыдущие рассуждения, получаем, что корректность i-го окна в SP гарантирует корректность соответствующего окна в SP* и совпадение списка работ, размещенных в них.
Неразмещенные в SP работы могут оказаться добавлены только в новые окна, т.к. последовательность вершин, соответствующих размещенным в SP работам, заканчивается вершиной с закрытием окна.
Теорема доказана.
Из утверждения теоремы также следует, что значение целевой функции для расписания SP* не меньше, чем для SP. Таким образом, доказано, что для любого корректного расписания SP существует последовательность вершин графа G’ такая, что модифицированный алгоритм способен построить корректное расписание, по крайней мере, не хуже данного с точки зрения целевой функции.
Следствие. Если SP0 корректное оптимальное расписание для множества работ SW, то существует такая последовательность вершин SL, что модифицированный алгоритм построит по ней корректное оптимальное расписание. Построенное расписание будет совпадать с расписанием SP0 по количеству размещенных в нем работ, количеству окон, по множеству работ выполняемых внутри каждого окна, но может отличаться по времени открытия и закрытия окон.
Заключение
Способ сведения задачи построения статико-динамических расписаний к задаче нахождения маршрута на графе, в котором каждой работе соответствуют две вершины, увеличивает пространство поиска муравьиного алгоритма. Однако, в отличие от способа, в котором каждой работе соответствует одна вершина графа, гарантирует принадлежность оптимального расписания к пространству поиска муравьиного алгоритма.
Список литературы
1. Dorigo M. Optimization, Learning and Natural Algorithms. // PhD Thesis. Dipartimento di Elettronica, Politechnico Di Milano, Milano. 1992.
2. Stuzle T., Dorigo M. ACO Algorithms for the Quadratic Assignment Problem. // New Ideas in Optimization, McGraw-Hills, 1999. P. 33-50.
3. Levine J., Ducatelle F. Ant Colony Optimization and Local Search for Bin Packing and Cutting Stock Problems. // Journal of the Operational Research Society, 2003.
4. Ritchie G. Static Multi-processor Scheduling with Ant Colony Optimization and Local Search. // Master’s Thesis. University of Edinburgh, Edinburgh. 2003.
5. Blum C., Sampels M. Ant Colony Optimization for FOP Shop Scheduling: A case study on different pheromone representation // In Proceedings of the 2002 Congress on Evolutionary Computations, Honolulu. 2002.
6. Гафаров Е.Р. Гибридный алгоритм решения задачи минимизации суммарного запаздывания для одного прибора // Москва, ВЦ РАН. 2006.
7. Arinc Specification 653. Airlines Electronic Engineering Committee. [PDF] (http://www.arinc.com).